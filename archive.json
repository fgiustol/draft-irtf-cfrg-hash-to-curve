{
  "magic": "B8n2c@e8kvfx",
  "timestamp": "2020-03-26T01:04:27.415679+00:00",
  "repo": "cfrg/draft-irtf-cfrg-hash-to-curve",
  "labels": [
    {
      "name": "bug",
      "description": null,
      "color": "ee0701"
    },
    {
      "name": "duplicate",
      "description": null,
      "color": "cccccc"
    },
    {
      "name": "enhancement",
      "description": null,
      "color": "84b6eb"
    },
    {
      "name": "help wanted",
      "description": null,
      "color": "33aa3f"
    },
    {
      "name": "good first issue",
      "description": null,
      "color": "7057ff"
    },
    {
      "name": "invalid",
      "description": null,
      "color": "e6e6e6"
    },
    {
      "name": "question",
      "description": null,
      "color": "cc317c"
    },
    {
      "name": "wontfix",
      "description": null,
      "color": "ffffff"
    },
    {
      "name": "WIP",
      "description": "Work in progress",
      "color": "fbca04"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWUyOTMzMDA1Njg=",
      "title": "Consider SWU as well?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/1",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-01-31T20:28:53Z",
      "updatedAt": "2018-02-12T15:48:15Z",
      "closedAt": "2018-02-12T15:48:15Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "https://eprint.iacr.org/2009/340.pdf\r\n",
          "createdAt": "2018-01-31T20:33:44Z",
          "updatedAt": "2018-01-31T20:33:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing. We are considering it.",
          "createdAt": "2018-02-12T15:48:15Z",
          "updatedAt": "2018-02-12T15:48:15Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "MDU6SXNzdWUzMDA2ODEyMjc=",
      "title": "Implement plain old SWU",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/2",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See the neat and tidy version in https://eprint.iacr.org/2009/340.pdf.\r\n",
      "createdAt": "2018-02-27T15:40:41Z",
      "updatedAt": "2018-06-01T00:30:30Z",
      "closedAt": "2018-06-01T00:30:29Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #25.\r\n",
          "createdAt": "2018-06-01T00:30:29Z",
          "updatedAt": "2018-06-01T00:30:29Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWUzMDA2ODE1NzI=",
      "title": "Write the section on curve mappings.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/3",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "grittygrease"
      ],
      "labels": [
        "enhancement"
      ],
      "body": "It's often useful to transform a Montgomery curve to a Weierstrass curve, and vice versa. We should provide details on how to do this.",
      "createdAt": "2018-02-27T15:41:29Z",
      "updatedAt": "2018-11-05T00:05:43Z",
      "closedAt": "2018-11-05T00:05:42Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Should also include transforming to (twisted) Edwards curve as well.\r\nWe will probably also need to mention different coordinate systems.",
          "createdAt": "2018-10-05T14:06:29Z",
          "updatedAt": "2018-10-05T14:06:29Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "(Coordinate systems, related to #4 )",
          "createdAt": "2018-10-05T14:06:57Z",
          "updatedAt": "2018-10-05T14:06:57Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Ideally this should just be a reference to some other document on how to transform. Otherwise it gets quite far away from the scope of the document, and starts being a complete doc on elliptic curves... I couldn't find anything suitable however.",
          "createdAt": "2018-10-05T18:32:22Z",
          "updatedAt": "2018-10-05T18:32:22Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "From the meeting:\r\n - Keep it brief, if you wish to use combinations not specified in this doc, there exist transformations (+ some minimal details).\r\n - The recommendations we present should obviate the need for applying transformations/composing alogrithms, since we specify precisely those recommended algorithms.",
          "createdAt": "2018-10-08T16:19:13Z",
          "updatedAt": "2018-10-08T16:19:13Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "body": "Please close if the section is deemed complete.",
          "createdAt": "2018-11-04T03:52:12Z",
          "updatedAt": "2018-11-04T03:52:12Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWUzMDA2ODE2NTk=",
      "title": "Include a projective coordinate version of Elligator2",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/4",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "enhancement"
      ],
      "body": "",
      "createdAt": "2018-02-27T15:41:41Z",
      "updatedAt": "2019-07-08T23:30:52Z",
      "closedAt": "2019-07-08T23:30:52Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I am on it.",
          "createdAt": "2019-01-25T19:51:17Z",
          "updatedAt": "2019-01-25T19:51:17Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWUzMDA2ODE3NDU=",
      "title": "Complete algorithm cost comparison table",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/5",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2018-02-27T15:41:53Z",
      "updatedAt": "2019-03-01T16:31:29Z",
      "closedAt": "2019-03-01T16:31:29Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Pending some quick checks, it seems most encoding algorithms are dominated by the cost of doing a modulo inverse. And then for FFSTV the cost is doubled. So instead of a complex table, we can just add something along those lines.\r\n\r\n(I suspect this issue was more relevant when we were going to have a range of options, as opposed to fixed recommendations).",
          "createdAt": "2019-02-10T03:05:37Z",
          "updatedAt": "2019-02-10T03:05:37Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #77.",
          "createdAt": "2019-03-01T16:31:29Z",
          "updatedAt": "2019-03-01T16:31:29Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWUzMDEyNDkzODg=",
      "title": "Investigate Jacobi symbol for non-constant-time quadratic residue computation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/6",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-03-01T01:47:40Z",
      "updatedAt": "2018-10-18T20:58:08Z",
      "closedAt": "2018-10-18T20:58:08Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@grittygrease @samscott89 do either of you think we should add this? (Sticking with constant time algorithms is probably best.)",
          "createdAt": "2018-06-01T00:32:18Z",
          "updatedAt": "2018-06-01T00:32:18Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Constant time seems like the safest by far (and the simplest).\r\n\r\nShould note, however, that it works for the Legendre symbol (i.e. denominator needs to be prime, but I think that's always the case?). ",
          "createdAt": "2018-06-01T18:48:42Z",
          "updatedAt": "2018-06-01T18:48:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, that's always the case for us. ",
          "createdAt": "2018-06-01T18:51:42Z",
          "updatedAt": "2018-06-01T18:51:42Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #56 ",
          "createdAt": "2018-10-18T20:58:08Z",
          "updatedAt": "2018-10-18T20:58:08Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWUzMDU5MDY1Mzk=",
      "title": "Clean up algorithm descriptions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/7",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "t &= \\mathsf{H}(\\alpha) \\\\\r\nx &= -t^2 \\\\ \r\nx_2 &= (-b / a) \\cdot (1 + (1 / (t^2 + t))) \\\\\r\nx_3 &= t \\cdot x_2 \\\\\r\nh_2 &= f(x_2) \\\\\r\nh_3 &= f(x_3) \\\\\r\n\\mathsf{Output} & (x_2, h_2^{(q + 1)/4}) \\text{ if } h_2 \\text{ is square, else} (x_3, h_3^{(q + 1)/4}) \r\n\r\nt & = \\mathsf{H}(\\alpha) \\\\\r\nv &= ((3A - t^4) / 6t) \\\\\r\nx & = (v^2 - b - (t^6 / 27))^{1/3} + (t^2 / 3) \\\\\r\ny & = tx + v \\\\\r\n\\mathsf{Output} & (x, y)\r\n\r\nr &= \\mathsf{H}(\\alpha) \\\\\r\nd &= -A / (1 + ur^2) \\\\\r\ne &= f(d)^{(p-1)/2} \\\\ \r\nu &= ed - (1 - e)A/u \\\\\r\n\\mathsf{Output} & (u, f(u))",
      "createdAt": "2018-03-16T12:17:09Z",
      "updatedAt": "2018-06-01T00:31:18Z",
      "closedAt": "2018-06-01T00:31:18Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed?",
          "createdAt": "2018-06-01T00:31:18Z",
          "updatedAt": "2018-06-01T00:31:18Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWUzMDY3ODg4NzI=",
      "title": "RFC 5639 Curves brainpoolP256r1 and brainpoolP512r1",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/8",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "These have p=2 mod 3.",
      "createdAt": "2018-03-20T09:35:37Z",
      "updatedAt": "2019-02-09T21:10:11Z",
      "closedAt": "2019-02-09T21:10:11Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing. These can be defined as additional ciphersuites should they be desired.",
          "createdAt": "2019-02-09T21:10:11Z",
          "updatedAt": "2019-02-09T21:10:11Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWUzMDg1NzYxMDQ=",
      "title": "Add NIST P-521, Curve1174, and Koblitz curves such as secp256k1",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/9",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-03-26T13:38:49Z",
      "updatedAt": "2019-03-01T16:30:51Z",
      "closedAt": "2019-03-01T16:30:51Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by several others. Closing.",
          "createdAt": "2019-03-01T16:30:51Z",
          "updatedAt": "2019-03-01T16:30:51Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWUzMDg1NzcwNzQ=",
      "title": "Simplified SWU description is wrong",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/10",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\"5. Output (-g * alpha) * (g * beta)\"\r\n\r\n- g was not defined here, except above as a function of x, but here it is being used in a multiplication.\r\n- g might be confused with the generator point for the curve\r\n- The output should be in the form of a point with coordinates x and y, should it not?",
      "createdAt": "2018-03-26T13:41:12Z",
      "updatedAt": "2018-06-01T00:30:18Z",
      "closedAt": "2018-06-01T00:30:18Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #25.",
          "createdAt": "2018-06-01T00:30:18Z",
          "updatedAt": "2018-06-01T00:30:18Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "MDU6SXNzdWUzMDg1Nzc2MTI=",
      "title": "Simplified SWU step #21 needs constant time comparison",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/11",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Step \"21\" indicates an equality comparison.  Unless implemented specially, these could lead to side-channel attacks as an equality check of equal values takes longer than one where the values are unequal. It might be more secure to separately compute both comparisons, i.e. also compute \"e_2 = (y2 ^ 2 == h3)\" as a mitigation strategy or alternative to implementing constant time equality checks, which might not be readily available in different BigInteger libraries/languages.\r\n",
      "createdAt": "2018-03-26T13:42:37Z",
      "updatedAt": "2018-10-22T20:33:48Z",
      "closedAt": "2018-10-22T20:33:48Z",
      "comments": []
    },
    {
      "number": 12,
      "id": "MDU6SXNzdWUzMDg1Nzg2NTA=",
      "title": "Consider variable-length hash function in HashToBase",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/12",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "An example is given that this can be any cryptographic hash function, such as SHA-256.  However, I think it would be better if this is defined as a method supporting variable length outputs.  For example, HKDF (Hmac Key Derivation Function).  The justification being that some elliptic curves operate on fields that are too large, even for SHA-512 (e.g. NIST P-521), and naive attempts at extending the length of a hash may otherwise be designed insecurely.\r\n\r\nIf the function is specified as HKDF (which operates on bytes rather than bits) there should be clarification as to which bits of the output are to be used (e.g. the left-most bits output by HKDF).",
      "createdAt": "2018-03-26T13:45:19Z",
      "updatedAt": "2019-02-09T16:34:45Z",
      "closedAt": "2019-02-09T16:34:45Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing for now.",
          "createdAt": "2019-02-09T16:34:45Z",
          "updatedAt": "2019-02-09T16:34:45Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "MDU6SXNzdWUzMDg1Nzk2OTg=",
      "title": "Clarify failure of probability for Try-and-Increment in terms of counter size",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/13",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Current pseudocode relies on I2OSP failing to avoid looping forever when ctr > 256^4. Although this only happens with probability 2^-32, perhaps it should be an explicit condition for the loop. This should also be acknowledged in the introduction, since the size of this counter determines the probability of failure, as in the MapToGroup approach.\r\n",
      "createdAt": "2018-03-26T13:47:58Z",
      "updatedAt": "2019-02-09T16:35:54Z",
      "closedAt": "2019-02-09T16:35:54Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as not needed.",
          "createdAt": "2019-02-09T16:35:54Z",
          "updatedAt": "2019-02-09T16:35:54Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWUzMDg1Nzk5Mzk=",
      "title": "Clarify meaning of 2n-octet string",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/14",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Clarify the meaning of \"2n-octet string\u201d when introducing RS2ECP. Also, RS2ECP is not explicitly defined in RFC8032, but in https://tools.ietf.org/id/draft-goldbe-vrf-01.html#suites. According to that, only when curve is Ed25519, RS2ECP is defined in Section 5.1.3 of [RFC8032].\r\n",
      "createdAt": "2018-03-26T13:48:32Z",
      "updatedAt": "2018-10-23T15:03:36Z",
      "closedAt": "2018-10-22T20:33:44Z",
      "comments": [
        {
          "author": "cygnusv",
          "authorAssociation": "NONE",
          "body": "I think this issue should be reopened. The Try-and-Increment Method should be generic, but the RS2ECP method described in Section 5.1.3 of [RFC8032] is not; in particular, it is defined for the curve used by Ed25519 (Section 5.1 is specific to that curve). For example, it assumes 32-byte strings. Other example is that step 1 of the method won't work for all types of curves. \r\n\r\nHow about using the method described in Section 2.3.4 of [SEC standard](http://www.secg.org/sec1-v2.pdf)? ",
          "createdAt": "2018-10-23T08:12:36Z",
          "updatedAt": "2018-10-23T08:12:36Z"
        },
        {
          "author": "cygnusv",
          "authorAssociation": "NONE",
          "body": "Oh disregard my comment, I was looking to the html doc, which seems outdated.",
          "createdAt": "2018-10-23T14:52:40Z",
          "updatedAt": "2018-10-23T14:52:40Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry about that. I've updated the repo files to avoid confusion (for the time being...). ",
          "createdAt": "2018-10-23T15:03:36Z",
          "updatedAt": "2018-10-23T15:03:36Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWUzMDg1ODE1NzQ=",
      "title": "Consider 2y^2=x^3+x/GF(8^91+5) curve",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/15",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "For what little it's worth, (I think that) none of the algorithms\r\nspecified in this I-D work for 2y^2=x^3+x/GF(8^91+5), because p=1 mod 3, p=1\r\nmod 4, and j=1728.\r\n\r\nFor this special curve, I sketched a modification of Elligator 2, which I\r\ncalled Elligator i, in Sections 5.2 (math) and C.10 (pseudocode) of\r\nhttps://datatracker.ietf.org/doc/draft-brown-ec-2y2-x3-x-mod-8-to-91-plus-5/\r\nthough I am not sure which set of curves it would generalize to.  (I admit I\r\ndon't recall trying Icart or SWU on this special curve: maybe some\r\nvariations of these would have worked just as well.)",
      "createdAt": "2018-03-26T13:52:35Z",
      "updatedAt": "2019-02-09T16:42:36Z",
      "closedAt": "2019-02-09T16:42:35Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We can probably use SWU for this case.",
          "createdAt": "2019-01-25T19:49:25Z",
          "updatedAt": "2019-01-25T19:49:25Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as NTBF.",
          "createdAt": "2019-02-09T16:42:35Z",
          "updatedAt": "2019-02-09T16:42:35Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWUzMDk0NTM0ODM=",
      "title": "Add algorithm for pairing-friendly curves",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/16",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://link.springer.com/chapter/10.1007/978-3-642-33481-8_1\r\nhttp://ieeexplore.ieee.org/abstract/document/6827966/\r\n\r\nThe technique builds on SWU and Icart's variant, with a new encoding function suitable for BN curves.",
      "createdAt": "2018-03-28T17:08:04Z",
      "updatedAt": "2019-03-01T16:25:43Z",
      "closedAt": "2019-03-01T16:25:43Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #86.",
          "createdAt": "2019-03-01T16:25:43Z",
          "updatedAt": "2019-03-01T16:25:43Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "MDU6SXNzdWUzMTA1ODkyNDA=",
      "title": "Clarify and discuss encoding, serialization, and hashing differences",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/17",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-04-02T19:51:42Z",
      "updatedAt": "2018-05-11T13:52:46Z",
      "closedAt": "2018-05-11T13:52:46Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "This was finished in the last few commits: f6fe5ded54cecffe34a555424202c64571e72bdd, d7836f3351825f4f02d150c49b9a7a5f372f80ba.",
          "createdAt": "2018-05-11T13:52:46Z",
          "updatedAt": "2018-05-11T13:52:46Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "MDU6SXNzdWUzMjI2NDQyMDg=",
      "title": "Include https://eprint.iacr.org/2013/373",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/22",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-14T01:09:29Z",
      "updatedAt": "2019-02-10T00:06:39Z",
      "closedAt": "2019-02-10T00:06:38Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this is the precursor to the Elligator paper, so I don't think there is anything to add?",
          "createdAt": "2019-02-09T21:22:01Z",
          "updatedAt": "2019-02-09T21:22:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Is it? I wasn't sure. Either way, I'm not sure there's new (or superior) material here, so I'm closing.",
          "createdAt": "2019-02-10T00:06:38Z",
          "updatedAt": "2019-02-10T00:06:38Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "MDU6SXNzdWUzMjI2NDQyNzM=",
      "title": "Include generic hash construction H(u,v) = F(u) + F(v)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/23",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "See https://eprint.iacr.org/2010/539 for details.",
      "createdAt": "2018-05-14T01:10:05Z",
      "updatedAt": "2019-01-26T01:35:39Z",
      "closedAt": "2019-01-26T01:35:39Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 Do you think we should have a section for this?",
          "createdAt": "2018-05-14T21:38:47Z",
          "updatedAt": "2018-05-14T21:38:47Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure what you mean by H(u, v)? But the construction H(m) = f(h1(m)) + f(h2(m)) should definitely be included, as well as H(m) = f(h1(m)) + h2(m)*G. And specifically, what encoding functions `f` are appropriate for each.",
          "createdAt": "2018-05-14T22:29:21Z",
          "updatedAt": "2018-05-14T22:29:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, sorry. Here, u=H1(m) and v=H2(m). I think a new section for this type of RO construction is probably needed.",
          "createdAt": "2018-05-14T22:30:53Z",
          "updatedAt": "2018-05-14T22:30:53Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Those two (which one depending on suitability of encoding functions f) should be the default answer to \"I need to hash to the curve\". In the absence of any other info, they give you a proper RO, whereas the others generally don't.\r\n\r\nYep, I'm planning to add something along these lines when I get the chance. ",
          "createdAt": "2018-05-14T22:32:06Z",
          "updatedAt": "2018-05-14T22:32:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Cool, that matches my understanding. I can take a crack at this section if you don't mind, and if you weren't planning on doing it in the next couple of days?",
          "createdAt": "2018-05-14T22:33:23Z",
          "updatedAt": "2018-05-14T22:33:23Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, please do!",
          "createdAt": "2018-05-14T22:40:11Z",
          "updatedAt": "2018-05-14T22:40:11Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Want to pick up this conversation from the merged PR:\r\n\r\n>>  We should probably cite Brier et al. https://link.springer.com/chapter/10.1007/978-3-642-14623-7_13 as the primary reference for the general construction (they proved it for Icart function only though). And also can use the other generalized construction H(m) = f(h1(m)) + h2(m)G which you can show holds for Elligator\r\n\r\n> Do we really want to specify two generic mechanisms when one would suffice?\r\n\r\nIdeally, no, but I'm not sure if the hash-encode-twice (HET) method can be applied for Elligator, whereas the hash-encode-basepoint (HEB) method has a much easier condition to prove for compatibility. The proof that Elligator holds for HEB is straightforward (needs to be checked though). Proving Elligator is compatible with HET seems to potentially require digging into the algebraic geometry. Might well be worth doing though.",
          "createdAt": "2018-05-28T15:28:16Z",
          "updatedAt": "2018-05-28T15:28:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 We should do it!",
          "createdAt": "2018-05-28T16:07:46Z",
          "updatedAt": "2018-05-28T16:07:46Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Even better if we can rope a mathematician into doing the Elligator/HET proof (or alternatively disproving it).",
          "createdAt": "2018-05-28T16:29:18Z",
          "updatedAt": "2018-05-28T16:29:18Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I concur. :)",
          "createdAt": "2018-05-28T16:46:48Z",
          "updatedAt": "2018-05-28T16:46:48Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "We have had this for a while under the name \"FFSTV13\"",
          "createdAt": "2019-01-26T01:35:39Z",
          "updatedAt": "2019-01-26T01:35:39Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWUzMjcwNzA1NTE=",
      "title": "Add hash-encode-basepoint (HEB) method",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/26",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See #23.",
      "createdAt": "2018-05-28T16:08:15Z",
      "updatedAt": "2019-03-19T02:10:48Z",
      "closedAt": "2019-03-19T02:10:48Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "This is my justification for why Elligator is compatible with the HEB method:\r\n\r\nFor an encoding function f to work with the HEB method, it needs to satisfy Definition 3 of Brier et al.\r\n\r\n> Definition 3 (Weak Encoding). A function f : S \u2192 R between finite sets is said\r\nto be an \u03b1 -weak encoding if it satisfies the following properties:\r\n\r\n> 1. Computable: f is computable in deterministic polynomial time.\r\n\r\n> 2. \u03b1 -bounded: for s uniformly distributed in S , the distribution of f ( s )\r\nis \u03b1 - bounded in R , i.e. the inequality Pr s [ f ( s )= r ] \u2264 \u03b1/ # R holds\r\nfor any r \u2208 R .\r\n\r\n> 3. Samplable: there is an efficient randomized algorithm I such that I ( r )\r\ninduces the uniform distribution in f ^{\u22121} ( r ) for any r \u2208 R . Additionally\r\nI ( r ) returns N_r =# f^{\u22121} ( r ) for all r \u2208 R\r\n\r\n(1) is certainly true for Elligator.\r\n(2) holds with \u03b1=2 since every point on the curve either has precisely 0 or 2 pre-images.\r\n(3) holds since that is precisely what the Elligator mapping achieves. For any r in E(Fp), f^{-1}(r) is either the empty set, or +/- t (where f(t) = r), and can be computed efficiently using the Elligator mapping.",
          "createdAt": "2018-05-28T16:41:54Z",
          "updatedAt": "2018-05-28T16:41:54Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "We are actually missing formal justification for the FFSTV(*) combinations... Some relevant discussion is here: https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/issues/23 ",
          "createdAt": "2019-02-09T21:24:27Z",
          "updatedAt": "2019-02-09T21:24:27Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Tracking the lack of proofs in #93. If we complete that, we can close this issue.",
          "createdAt": "2019-03-15T15:58:59Z",
          "updatedAt": "2019-03-15T15:58:59Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "This is unnecessary given conclusion in #93 ",
          "createdAt": "2019-03-19T02:10:47Z",
          "updatedAt": "2019-03-19T02:10:47Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWUzMjgzNDA1NzQ=",
      "title": "Add hacspec implementation of Elligator2",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/27",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-01T00:27:00Z",
      "updatedAt": "2018-07-13T20:23:42Z",
      "closedAt": "2018-07-13T20:23:42Z",
      "comments": []
    },
    {
      "number": 28,
      "id": "MDU6SXNzdWUzMjgzNDA2MDY=",
      "title": "Add hacspec implementation of Icart",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/28",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-01T00:27:10Z",
      "updatedAt": "2018-07-13T20:23:42Z",
      "closedAt": "2018-07-13T20:23:42Z",
      "comments": []
    },
    {
      "number": 29,
      "id": "MDU6SXNzdWUzMjgzNDA2Mzg=",
      "title": "Add hacspec implementation of SWU",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/29",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-01T00:27:22Z",
      "updatedAt": "2018-07-13T20:23:42Z",
      "closedAt": "2018-07-13T20:23:42Z",
      "comments": []
    },
    {
      "number": 30,
      "id": "MDU6SXNzdWUzMjgzNDA2NTk=",
      "title": "Add hacspec implementation of simplified SWU",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/30",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-01T00:27:32Z",
      "updatedAt": "2018-07-13T20:23:42Z",
      "closedAt": "2018-07-13T20:23:42Z",
      "comments": []
    },
    {
      "number": 32,
      "id": "MDU6SXNzdWUzMzU2MTAzMzY=",
      "title": "Include SPEKE",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/32",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "https://eprint.iacr.org/2014/585.pdf",
      "createdAt": "2018-06-26T00:03:54Z",
      "updatedAt": "2019-02-09T16:39:03Z",
      "closedAt": "2019-02-09T16:39:03Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We reference it already. Closing.",
          "createdAt": "2019-02-09T16:39:03Z",
          "updatedAt": "2019-02-09T16:39:03Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "MDU6SXNzdWUzNDExNDg1NzA=",
      "title": "Consider Elligator Squared",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/34",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://eprint.iacr.org/2014/043.pdf",
      "createdAt": "2018-07-13T20:23:22Z",
      "updatedAt": "2019-02-09T21:24:56Z",
      "closedAt": "2019-02-09T21:24:56Z",
      "comments": [
        {
          "author": "goldbe",
          "authorAssociation": "NONE",
          "body": "My g-d, elligator2 and elligator squared. And they are different. What are these insane naming conventions. that people come up with!",
          "createdAt": "2018-07-23T21:52:01Z",
          "updatedAt": "2018-07-23T21:52:01Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "We decided this was unnecessary.",
          "createdAt": "2019-02-09T21:24:56Z",
          "updatedAt": "2019-02-09T21:24:56Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWUzNDM4MDU2NDM=",
      "title": "Add \"ciphersuite\" configurations for curves",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/35",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "grittygrease"
      ],
      "labels": [],
      "body": "We should provide a \u201cciphersuite\u201d with test vectors for 25519 and 448, which requires us to provide explicit hash to base recommendations (minimum output size in general, algo in specific suites)\r\n",
      "createdAt": "2018-07-23T21:39:15Z",
      "updatedAt": "2019-02-09T16:07:56Z",
      "closedAt": "2019-02-09T16:07:55Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "From meeting discussion:\r\n - We should have one recommendation per curve. E.g. Ed25519 + elligator + SHA256.\r\n - This should be worded unambiguously.\r\n - This eliminates the need (in this doc) for ciphersuite options, since the curve dictates the choice?",
          "createdAt": "2018-10-08T16:16:55Z",
          "updatedAt": "2018-10-08T16:16:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 I'm closing this issue since we now have ciphersuites. Do you want to open a new issue to include the ciphersuite-per-curve recommendations? ",
          "createdAt": "2019-02-09T16:07:55Z",
          "updatedAt": "2019-02-09T16:07:55Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "MDU6SXNzdWUzNDM4MDU3NzA=",
      "title": "Are encodings injective or bijective?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/36",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-23T21:39:40Z",
      "updatedAt": "2019-02-09T21:05:46Z",
      "closedAt": "2019-02-09T21:05:46Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #74.",
          "createdAt": "2019-02-09T21:05:46Z",
          "updatedAt": "2019-02-09T21:05:46Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWUzNDM4MDU4MzM=",
      "title": "Propose an OpenSSL API (but not in the doc)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/37",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-23T21:39:54Z",
      "updatedAt": "2019-03-01T16:28:29Z",
      "closedAt": "2019-03-01T16:28:29Z",
      "comments": []
    },
    {
      "number": 38,
      "id": "MDU6SXNzdWUzNDM4MDU4OTQ=",
      "title": "Fix u=2 for Elligator2 (Curve25519)?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/38",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-23T21:40:07Z",
      "updatedAt": "2018-10-22T20:33:38Z",
      "closedAt": "2018-10-22T20:33:38Z",
      "comments": []
    },
    {
      "number": 39,
      "id": "MDU6SXNzdWUzNDM4MDU5NTA=",
      "title": "Add bitcoin curve recommendation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/39",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-23T21:40:18Z",
      "updatedAt": "2019-03-01T16:29:18Z",
      "closedAt": "2019-03-01T16:29:18Z",
      "comments": [
        {
          "author": "cygnusv",
          "authorAssociation": "NONE",
          "body": "This is covered by issue #9, which asks for secp256k1, so I guess this issue is redundant.\r\n\r\nBTW, are you going to provide a recommendation for this curve? There are lot of projects that would benefit from such recommendation.",
          "createdAt": "2019-02-12T06:36:55Z",
          "updatedAt": "2019-02-12T06:36:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing. @cygnusv, please reopen if necessary.",
          "createdAt": "2019-03-01T16:29:18Z",
          "updatedAt": "2019-03-01T16:29:18Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "MDU6SXNzdWUzNDQyNzY0NzU=",
      "title": "Specify HashToBase details",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/40",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Per Richard Barnes' email:\r\n\r\n1. Interpret H(x) as a big-endian integer h\r\n2. Reduce h mod 2^(log2(p) + 1)\r\n3. Reduce h mod p",
      "createdAt": "2018-07-25T03:13:27Z",
      "updatedAt": "2019-02-09T21:06:52Z",
      "closedAt": "2019-02-09T21:06:52Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "This was done across #56 and #72",
          "createdAt": "2019-02-09T21:06:52Z",
          "updatedAt": "2019-02-09T21:06:52Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "MDU6SXNzdWUzNDQyNzcyNjY=",
      "title": "Remove use of alpha variable in simple_swu algorithm",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/41",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-25T03:17:48Z",
      "updatedAt": "2019-02-09T16:00:55Z",
      "closedAt": "2019-02-09T16:00:55Z",
      "comments": []
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWUzNDQyNzc1MjY=",
      "title": "Make clear that prepended 0/1 are bytes in FFSTV13 section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/42",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-25T03:19:16Z",
      "updatedAt": "2018-10-22T20:12:10Z",
      "closedAt": "2018-10-22T20:12:10Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed in #59.\r\n",
          "createdAt": "2018-10-22T20:12:10Z",
          "updatedAt": "2018-10-22T20:12:10Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "MDU6SXNzdWUzNDQ1NjgzMzg=",
      "title": "Composition of encoding + Ristretto/Decaf",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/43",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "samscott89"
      ],
      "labels": [],
      "body": "The Decaf approach \r\n\r\nhttps://www.shiftleft.org/papers/decaf/\r\n\r\nhttps://ristretto.group/",
      "createdAt": "2018-07-25T19:03:28Z",
      "updatedAt": "2019-10-27T06:15:25Z",
      "closedAt": "2019-10-27T06:15:25Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "To be discussed: how to best handle this. Although these seem like \"the right choices\" for implementers choosing a curve, they aren't yet fully specified.\r\n\r\nIt would be ideal if we could (a) add them when well specified, and (b) target compatibility between the hashing approaches.",
          "createdAt": "2018-10-05T18:29:13Z",
          "updatedAt": "2018-10-05T18:29:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Based on the meeting, we will update the such that the curve->algorithm table maps curves->output group, where output group is one of (all)P-256, Ristretto (prime order subgroup of Curve25519), etc.",
          "createdAt": "2018-10-08T16:53:10Z",
          "updatedAt": "2018-10-08T16:53:10Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "body": "After a deeper dive into Ristretto, I no longer think this is necessary. If the output of h2c is an Edwards point, the algorithm can treat that as the representative element of the Ristretto group. From there they can use regular Edwards arithmetic and the Ristretto comparison function. When they need to serialize a point in the group, they can use the Ristretto encoding.",
          "createdAt": "2018-11-04T03:24:26Z",
          "updatedAt": "2018-11-04T03:24:26Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "See [this comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/146#issuecomment-509231171) re: Ristretto h2c",
          "createdAt": "2019-07-08T20:15:32Z",
          "updatedAt": "2019-07-08T20:15:32Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "In fact, Ristretto has two possible implementations based on an Ed25519, depending upon the branch of the inverse square root used.  These two choices result in compatible wire formats, so any purely Ristretto tests would pass no matter which you choose, but If two implementations employ different branches then they have different map between Edwards and Ristretto.  \r\n\r\nRistretto authors have chosen never to expose the map, which prevents interoperation of protocols using Ed25519 and Ristretto keys, and prevents extending older Ed25519 protocols with Ristretto in particular, but their choice ensures Ristretto itself has less risk of non-compliant implementations. ",
          "createdAt": "2019-07-08T22:00:01Z",
          "updatedAt": "2019-07-08T22:00:01Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "We're in the process of hashing out separation of responsibilities between h2c and the ristretto draft with the ristretto authors. The most likely path seems to be that there will not be a map specified in h2c for Ristretto. I am closing this; we will create a new issue to track action items once the path ahead is clear.\r\n\r\n(#174 is tracking the discussion with Ristretto authors for now)",
          "createdAt": "2019-10-27T06:15:25Z",
          "updatedAt": "2019-10-27T06:15:25Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "MDU6SXNzdWUzNTQ0MTA5MTM=",
      "title": "Simplified SWU sign of t^2",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/45",
      "state": "CLOSED",
      "author": "reyzin",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/chris-wood/draft-sullivan-cfrg-hash-to-curve/blob/fdb70a5f0c836a4ab8090c5a84952c688e5ccc35/draft-irtf-cfrg-hash-to-curve.txt#L566\r\n\r\nShould the sign in front of t^2 be minus rather than plus (see step 4 of the algorithm, which computes alpha^2 + alpha where alpha is -t^2; see also Proposition 7 of https://eprint.iacr.org/2009/340.pdf)",
      "createdAt": "2018-08-27T17:42:41Z",
      "updatedAt": "2019-02-09T16:42:05Z",
      "closedAt": "2019-02-09T16:42:05Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@reyzin this is now fixed, although I think we have a similar bug in the main SWU algorithm.",
          "createdAt": "2019-02-09T16:42:05Z",
          "updatedAt": "2019-02-09T16:42:05Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "MDU6SXNzdWUzNTQ0MTM0ODQ=",
      "title": "CMOV condition: only 0 or 1?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/46",
      "state": "CLOSED",
      "author": "reyzin",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/chris-wood/draft-sullivan-cfrg-hash-to-curve/blob/fdb70a5f0c836a4ab8090c5a84952c688e5ccc35/draft-irtf-cfrg-hash-to-curve.txt#L350\r\n\r\nThe CMOV called for in the draft is quite general: it allows the condition to be not only 1 or 0, but any value. The uses of CMOV later in the draft rely on this. However, it is more complicated to implement a time-invariant CMOV for such a case. In fact, OpenSSL's CMOV assumes 0 or 1 (see https://github.com/openssl/openssl/blob/7d38ca3f8bca58bf7b69e78c1f1ab69e5f429dff/crypto/ec/curve25519.c#L1475), and thus the more general CMOV may be unavailable to a developer. Moreover, a developer may not realize that the CMOV available in code is not the same as the more powerful CMOV called for in the draft, because the name is the same.",
      "createdAt": "2018-08-27T17:50:04Z",
      "updatedAt": "2019-02-07T15:41:15Z",
      "closedAt": "2019-02-07T15:41:15Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed in #64 with the following text:\r\n\r\n```\r\n  Common software implementations of constant-time selects assume c = 1 or c = 0. CMOV\r\n\t  may be implemented by computing the desired selector (0 or 1) by ORing all bits of c\r\n\t  together. The end result will be either 0 if all bits of c are zero, or 1 if at least\r\n\t  one bit of c is 1.\r\n```\r\n\r\nPlease re-open if this does not satisfy the issue!",
          "createdAt": "2019-02-07T15:41:15Z",
          "updatedAt": "2019-02-07T15:41:15Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "MDU6SXNzdWUzNTYyMzg2NTk=",
      "title": "s/Random Oracles/Indifferentiable Hashing title name",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/47",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-01T23:00:41Z",
      "updatedAt": "2019-02-07T15:43:27Z",
      "closedAt": "2019-02-07T15:43:27Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing for now, since I can't recall why we opened this. @grittygrease @samscott89 please re-open if you can remember the rationale!",
          "createdAt": "2019-02-07T15:43:27Z",
          "updatedAt": "2019-02-07T15:43:27Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "MDU6SXNzdWUzNTYyMzkxNTI=",
      "title": "Add example table usage",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/48",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-01T23:11:24Z",
      "updatedAt": "2019-02-09T21:05:40Z",
      "closedAt": "2019-02-09T21:05:40Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #74.",
          "createdAt": "2019-02-09T21:05:40Z",
          "updatedAt": "2019-02-09T21:05:40Z"
        }
      ]
    },
    {
      "number": 49,
      "id": "MDU6SXNzdWUzNTYyMzkxNjc=",
      "title": "Remove restriction to non-binary curves in section 2.2.1",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/49",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-01T23:11:41Z",
      "updatedAt": "2018-10-22T19:29:48Z",
      "closedAt": "2018-10-22T19:29:48Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Should be fixed!",
          "createdAt": "2018-10-22T19:29:48Z",
          "updatedAt": "2018-10-22T19:29:48Z"
        }
      ]
    },
    {
      "number": 50,
      "id": "MDU6SXNzdWUzNTYyMzkyNTY=",
      "title": "Various edits",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/50",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "1. Section 2 states that n = qh + r, where n is order of the group of elliptic curve points, q is a prime order of a subgroup of the group of elliptic curve points, h is a cofactor and r is a remainder. Is there any sense to use value r? Every nonzero r directly violates Lagrange's theorem.\r\n\r\n2. In the sixth paragraph of Section 2 states that n can be estimated using Hasse's theorem as |n-p| < 2 * sqrt(p). This is true for the prime field case, otherwise we have to use Hasse-Weil theorem.\r\n\r\n3. The same paragraph refers that if point (x, y) belongs to some curve, then (x, -y) also does. It must be stated explicitly, that it is true for certain curve forms \u2013 because this is not true for some coordinate forms like twisted Edwards.\r\n\r\n4. The second paragraph of Section 2.1.1 states that \"In most cases, the curve E is over a finite field GF(p^k), with p > 2.\". Are you sure about it? The vast majority of standardized curves defined over extension fields seems to have p = 2.\r\n\r\n5. Some clarifications about two separate HashToBase implementations should be added into Section 5.2.2.\r\n\r\n6. Section 5.2.2, paragraph 6. Add word <<short>> before <<Weierstrass form>>.\r\n\r\n7. Section 5.2.4. Description of Elligator2 method uses f(x) function and returns its value instead of a pair of coordinates.\r\n\r\n8. Appendix B, paragraph 1. \u201cSection Section\u201d.\r\n\r\n9. Appendix B, algorithm description, step 4E. Does symbol ^ stay here for scalar point multiplication?\r\n\r\n10. I believe that the HashToBase function has to be described as explicitly as it is possible (including byte order, possible hash function sets for different curves) (the same issue with \u201cbe as explicit as possible\u201d applies to our \u201cRandomness improvements \u2026\u201d draft also J\r\n\r\n11. Appendix A.5. \u201c&#8746\u201d instead of cup symbol?\r\n\r\n12. Misprints: \u201cartbirary\u201d, \u201csimplified\u201d.",
      "createdAt": "2018-09-01T23:13:39Z",
      "updatedAt": "2018-10-22T19:29:13Z",
      "closedAt": "2018-10-22T19:29:13Z",
      "comments": [
        {
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "body": "- [x] 1. Definitely. I suggest we remove r and say that q is the largest prime factor.\r\n- [x] 2. Also true. Generally, we use curves over prime fields as examples in this document but I don't see why these algorithms wouldn't apply to, say extension fields. We can add the Hasse-Weil bound here as well, but maybe it's better to ask if we need to say anything about the order of the curve group vs the field. I don't think we do. Consider dropping this paragraph?\r\n- [x] 3. Yes. We should state that this is true in Weierstrass form, and that every curve is isogenous to a curve that can be expressed in Weierstrass form. (side note: \"Elliptic curves come in many variants\" should also be rephrased appropriately as \"Elliptic curves can be represented by equations of different standard forms\" or something)\r\n- [x] 4. Right. Binary curves (p=2) are a thing, and more common than the extension field curves defined for pairing-based cryptography. The good thing about elements of binary curves is you can express them as bit strings pretty easily. A line about that should resolve this.\r\n- [x] 5. #59 takes care of this\r\n- [x] 6. TODO?\r\n- [x] 7.  The first lines are still confusing here\r\n- [x] 8. Resolved?\r\n- [x] 9. Needs to be changed to scalar point multiplication\r\n- [x] 10. #59 \r\n- [x] 11. Yes\r\n- [x] 12. To be fixed?",
          "createdAt": "2018-10-19T23:05:09Z",
          "updatedAt": "2018-10-21T20:11:45Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "MDU6SXNzdWUzNTYyMzk2MDI=",
      "title": "Include HashToBase recommendation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/51",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-01T23:22:25Z",
      "updatedAt": "2018-10-09T05:19:51Z",
      "closedAt": "2018-10-09T05:19:51Z",
      "comments": []
    },
    {
      "number": 52,
      "id": "MDU6SXNzdWUzNTYyMzk2Mzg=",
      "title": "Note u=0/1 cases for modular inverse, and possible edge cases with side channel",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/52",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-01T23:23:09Z",
      "updatedAt": "2019-06-03T22:48:04Z",
      "closedAt": "2019-06-03T22:48:04Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Many algorithms take modular inverses, where the input can be zero. Forcing this to happen requires finding inputs to HashToBase which produce 0. We could require computing inverses as `x^(p-1)` to plug this.",
          "createdAt": "2019-02-09T22:20:38Z",
          "updatedAt": "2019-02-09T22:20:38Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "#104 defined `inv0`, which handles this case, so I believe this issue can be closed.",
          "createdAt": "2019-06-03T22:37:04Z",
          "updatedAt": "2019-06-03T22:37:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. Closing with #104.",
          "createdAt": "2019-06-03T22:48:04Z",
          "updatedAt": "2019-06-03T22:48:04Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "MDU6SXNzdWUzNjcyODA1Nzg=",
      "title": "Fix Elligator2 definition",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/53",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently the return statement of Elligator 2 is\r\n\r\n```\r\n19. Output (u, f(u))\r\n```\r\nBut this should be `sqrt(f(u))`.\r\nHowever, this requires guidance on which square root to choose.",
      "createdAt": "2018-10-05T16:22:04Z",
      "updatedAt": "2019-02-09T21:25:59Z",
      "closedAt": "2019-02-09T21:25:58Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "A couple of other bugs:\r\n```\r\n11.  e = v3 * v (mod p)\r\n...\r\n13.  e = v2 * e (mod p)\r\n```\r\nThese should both be `+`. Otherwise `e = Av^6` instead of `e = v^3 + Av^2 + v` !!\r\nAlso, it needs to be `e = v3 + B*v` for general curves.\r\n\r\n",
          "createdAt": "2018-10-05T16:40:42Z",
          "updatedAt": "2018-10-05T16:40:42Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "While we're at it. Some other improvements:\r\n - inconsistent variable naming\r\n - shadowing of parameters (`u`).\r\n\r\n(thanks to Eric Crockett for point out all of these issues)",
          "createdAt": "2018-10-05T16:58:30Z",
          "updatedAt": "2018-10-05T16:58:30Z"
        },
        {
          "author": "crockeea",
          "authorAssociation": "NONE",
          "body": "Line 4 of the \"alternate\" Elligator2 algorithm is `u = ed - (1 - e)A/u`, but the paper uses `u = ed - (1 - e)A/2`.",
          "createdAt": "2018-10-08T20:44:58Z",
          "updatedAt": "2018-10-08T20:44:58Z"
        },
        {
          "author": "crockeea",
          "authorAssociation": "NONE",
          "body": "Please be consistent with the output of the algorithms. The first algorithm in 5.2.4 outputs just the `y` coordinate. The second \"alternate\" algorithm outputs nothing, or just the `x` coordinate, depending on your interpretation. The implementation outputs a pair.",
          "createdAt": "2018-10-08T21:06:17Z",
          "updatedAt": "2018-10-08T21:06:17Z"
        },
        {
          "author": "crockeea",
          "authorAssociation": "NONE",
          "body": "Here's a proposal for fixes to section 5.2.4 (alignment excepted). My changes are in bold.\r\n\r\n-----\r\n\r\nThe following map2curve_elligator2(alpha) implements the Elligator2 method from [Elligator2].  This algorithm works for any curve with a point of order 2 and j-invariant != 1728.  Given curve equation f(x) = y^2 = x(x^2 + Ax + B), i.e., a Montgomery form with the point of order 2 at (0,0), **and a fixed non-square value in Fp,** this algorithm works as shown below.  (Note that any curve with a point of order 2 is isomorphic to this representation.)\r\n\r\n   1. r = HashToBase(alpha)\r\n**2. v= -A/(1+ur^2)**\r\n**3. If f(v) is a square, then output (v, f(v)^(1/2))**\r\n**4. Else, output (-v-A, f(-v-A)^(1/2))**\r\n\r\nAnother way to express this algorithm is as follows:\r\n\r\n   1. r = HashToBase(alpha)\r\n   2. v = -A / (1 + ur^2)\r\n   3. e = f(v)^((p-1)/2)\r\n   4. x = ed - (1 - e)A/**2**\r\n   **5. Output (x,f(x)^(1/2))** \r\n\r\nHere, e is the Legendre symbol of **z = v^3 + Av^2 + Bv**, which will be 1 if z is a quadratic residue (square) mod p, and -1 otherwise. (Note that raising z to ((p -1) / 2) is a common way to compute the Legendre symbol.)\r\n\r\nThe following procedure implements this algorithm.\r\n\r\n   map2curve_elligator2(alpha)\r\n\r\n   Input:\r\n\r\n     alpha - value to be encoded, an octet string\r\n\r\n     u - fixed non-square value in Fp.\r\n     f() - Curve function\r\n\r\n   Output:\r\n\r\n     (x, y) - a point in E\r\n\r\n   Steps:\r\n\r\n1.   r = HashToBase(alpha)\r\n2.   r = r^2 (mod p)\r\n   3.   r = r * u (mod p)\r\n   4.   r = r + 1 (mod p)\r\n   5.   r = r^(-1) (mod p)\r\n   6.   v = A * r (mod p)\r\n   7.   v = v * -1 (mod p)   // -A / (1 + ur^2)\r\n   8.   v2 = v^2 (mod p)\r\n**9.   e = v2 * v (mod p)**\r\n**10. v2 = v2 * A (mod p)**\r\n**11. v = v * B (mod p)**\r\n**12.  e = v2 + e (mod p)**\r\n**13.  e = v + e (mod p)**\r\n   14.  e = e^((p - 1) / 2) **(mod p)**  // Legendre symbol\r\n   15. nv = v * -1 (mod p)\r\n   16  **x1** = CMOV(v, nv, e)   // If e = 1, choose v, else choose nv\r\n   17. **x2** = CMOV(0, A, e)    // If e = 1, choose 0, else choose A\r\n**18.  x = x1 - x2 (mod p)**\r\n   19. Output (x, f(x)^(1/2))\r\n\r\n   Elligator2 can be simplified with projective coordinates.\r\n",
          "createdAt": "2018-10-08T21:39:48Z",
          "updatedAt": "2018-10-08T21:39:48Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "These were completed in #72",
          "createdAt": "2019-02-09T21:25:58Z",
          "updatedAt": "2019-02-09T21:25:58Z"
        }
      ]
    },
    {
      "number": 54,
      "id": "MDU6SXNzdWUzNjcyODI0NjM=",
      "title": "Choosing the sign of the encoded point",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/54",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As in #53, many algorithms require taking a square root and choosing one. In some cases we have an additional bit left over from HashToBase (e.g. with Curve25519 and SHA256, there is a free bit).\r\nWe can consider using this bit as a sign (as at the end of 2.6 of https://signal.org/docs/specifications/xeddsa/#hashing-to-a-point-with-elligator-2).",
      "createdAt": "2018-10-05T16:28:01Z",
      "updatedAt": "2019-06-04T15:38:45Z",
      "closedAt": "2019-06-04T15:38:45Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "I think as per some of the discussion in #59, it's better to think of the bit as choosing the sign of the point, as opposed to the square root. This also helps with the ambiguity in whether it's `(x, +/-y)` or `(+/-u, v)` or something.",
          "createdAt": "2018-10-20T16:02:43Z",
          "updatedAt": "2018-10-20T16:02:43Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "This question is worth answering in the context of other maps, too.\r\n\r\nSWU and SW (a.k.a. Fouque-Tibouchi) both rely only on hash2base(alpha)^2, so the sign of hash2base(alpha) can be used to select the sign of the output point.",
          "createdAt": "2019-04-26T23:00:43Z",
          "updatedAt": "2019-04-26T23:00:43Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "#104 defined the sign for every encoding, which addresses this issue.",
          "createdAt": "2019-06-03T22:37:48Z",
          "updatedAt": "2019-06-03T22:37:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as fixed in #104.",
          "createdAt": "2019-06-04T15:38:45Z",
          "updatedAt": "2019-06-04T15:38:45Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "MDU6SXNzdWUzNjcyODMxNTQ=",
      "title": "Consider parity with Signal spec",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/55",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As per the title, as one concrete existing implementation of this functionality, plus an existing spec. We should consider whether we want to agree with the existing Signal specification https://signal.org/docs/specifications/xeddsa/.",
      "createdAt": "2018-10-05T16:30:08Z",
      "updatedAt": "2019-01-26T01:30:48Z",
      "closedAt": "2019-01-26T01:30:48Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "We decided to drop this as a goal.",
          "createdAt": "2019-01-26T01:30:48Z",
          "updatedAt": "2019-01-26T01:30:48Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "MDU6SXNzdWUzNzI1MjExMjQ=",
      "title": "Icart Issues",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/61",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Some issues from Greg Rubin:\r\n> Please check steps 15-17 in map2curve_icart on page 7. It doesn't make sense.\r\nAccording to the comment (and code) at the end of step 16, `t1 = (2p - 1)/3`, however in step 17 you raise _x_ (with a current value of `v^2 - b - u^6/27` from step 14) to the power of _t1_ and claim the result is `(v^2 - b - u^6/27) ^ (1/3)`.  Unless I'm missing something in the math, you actually get `(v^2 - b - u^6/27) ^ ((2p - 1)/3)`.\r\n\r\n> Thinking about it, step 15 doesn't really make sense anyway. As the whole thing is `mod p`, isn't that step just equivalent to `t1 = -1 mod p`? I'm clearly missing something.\r\n\r\nStep 15 is in the group of exponents, i.e. `mod (p-1)`. Which is what gives the equivalence required (2p-1)/3 = 1/3 `mod (p-1)`.\r\n",
      "createdAt": "2018-10-22T13:27:35Z",
      "updatedAt": "2018-10-22T20:42:34Z",
      "closedAt": "2018-10-22T20:42:34Z",
      "comments": []
    },
    {
      "number": 62,
      "id": "MDU6SXNzdWUzNzI1MzkzMjk=",
      "title": "Code improvements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/62",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Some requested improvements to the algorithms:\r\n\r\n - > Please do *not* reuse variables across different data types. (Step 2 of Simplified SWU changes the type of _alpha_ from an octet string to an integer.)\r\n - > Please add at least one known answer test for each algorithm (you don't need it per curve)\r\n - > separate your precomputable/reusable values from those which aren't. ",
      "createdAt": "2018-10-22T14:15:02Z",
      "updatedAt": "2019-02-09T21:26:37Z",
      "closedAt": "2019-02-09T21:26:37Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Done in #72  :)",
          "createdAt": "2019-02-09T21:26:29Z",
          "updatedAt": "2019-02-09T21:26:29Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "MDU6SXNzdWUzNzI1Mzk1OTU=",
      "title": "Add flow-chart to determine algorithm for an arbitrary curve",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/63",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-10-22T14:15:42Z",
      "updatedAt": "2019-11-05T07:21:08Z",
      "closedAt": "2019-11-05T07:21:08Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I think #185 handles this. @samscott89 if you disagree please feel free to reopen.",
          "createdAt": "2019-11-05T07:21:08Z",
          "updatedAt": "2019-11-05T07:21:08Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "MDU6SXNzdWUzNzI2ODkwNDk=",
      "title": "SWU  with p = 1 (mod 4)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/66",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "For SWU, we write\r\n>  This algorithm works for any curve over F_{p^n}. \r\n\r\nWhich is true, but as far as I understand, to make it work with p = 1 (mod 4), (ignoring n>1 case for now), you need to use a modified Tonelli-Shanks algorithm to keep it constant time. We should probably specify this.",
      "createdAt": "2018-10-22T20:37:05Z",
      "updatedAt": "2019-02-10T03:10:40Z",
      "closedAt": "2019-02-10T03:10:40Z",
      "comments": []
    },
    {
      "number": 69,
      "id": "MDU6SXNzdWUzNzI4Njk0MzU=",
      "title": "SWU when A=0 in curve equation?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/69",
      "state": "CLOSED",
      "author": "cygnusv",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Current version of the draft asserts the following with respect to the SWU method:\r\n\r\n> This algorithm works for any curve over F_{p^n}\r\n\r\n\r\n> Every elliptic curve can be converted to an equivalent curve in short Weierstrass form ([BL07] Theorem 2.1), making SWU a generic algorithm that can be used for all curves\r\n\r\nHowever, the SWU method (and its simplified version) require the computation of `-B/A`, which is undefined when `A=0`. \r\n\r\nThis is related to #9 and #39, since it's a problem for curve SECP256K1, with curve equation `y^2 = x^3 + 7` (i.e, `A=0` and `B=7`).",
      "createdAt": "2018-10-23T08:24:18Z",
      "updatedAt": "2019-02-09T22:06:20Z",
      "closedAt": "2019-02-09T22:06:20Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, good catch. We will make sure to address this in the next version.",
          "createdAt": "2018-10-23T15:00:40Z",
          "updatedAt": "2018-10-23T15:00:40Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Covered in #72 ",
          "createdAt": "2019-02-09T22:06:20Z",
          "updatedAt": "2019-02-09T22:06:20Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "MDU6SXNzdWUzNzI5NTc1MzM=",
      "title": "Safe encoding of inputs to HashToBase",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/70",
      "state": "CLOSED",
      "author": "cygnusv",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The motivation of this question is that current draft doesn't state what's the intended behaviour of HashToBase if the input `x` and parameter `label` are empty bytestrings. If they are simply ignored (e.g., `\"abc\" || empty_bytestring == \"abc\"`), then there are potential collisions in HashToBase.\r\n\r\nLet's focus on the input of the hash function during the first step of HashToBase:\r\n`H(\"h2c\" || label || I2OSP(i, 4) || x)`\r\n\r\nAssume that `I2OSP(i, 4)` has some specific value (e.g., '00000000', which is the default). The hash `H(\"h2c\" || 00000000 || 00000000)` corresponds to two different configurations:\r\n\r\n- `label = 00000000` and `x` is empty\r\n- `label` is empty and `x = 00000000`\r\n\r\nA possible solution is to prepend the length of `label` and `x` to both values.",
      "createdAt": "2018-10-23T11:46:56Z",
      "updatedAt": "2019-02-09T22:06:45Z",
      "closedAt": "2019-02-09T22:06:45Z",
      "comments": [
        {
          "author": "cygnusv",
          "authorAssociation": "NONE",
          "body": "A more generic example is the following. Let `j` and `k` be 4-byte strings. The hash `H(\"h2c\" || j || k)` corresponds to two different configurations:\r\n\r\n- `label=j`, `i=k`, and `x` empty\r\n- `label` is empty, ' i=j` and `x=k`\r\n\r\n",
          "createdAt": "2018-10-23T14:38:30Z",
          "updatedAt": "2018-10-23T14:38:30Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "_Theoretically_ `label` should be a fixed value, corresponding to the ciphersuite (as in [Section 8](https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-02#section-8)), which would be a fixed string in all cases.\r\nBut, this does seem like a potential footgun, and we should also consider how to protect against length extension attacks for example.",
          "createdAt": "2018-10-23T14:57:45Z",
          "updatedAt": "2018-10-23T14:57:45Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Covered in #72",
          "createdAt": "2019-02-09T22:06:45Z",
          "updatedAt": "2019-02-09T22:06:45Z"
        }
      ]
    },
    {
      "number": 71,
      "id": "MDU6SXNzdWU0MDI3NjQ0OTY=",
      "title": "Rewrite random oracle construction to work around incomplete Montgomery point addition",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/71",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-01-24T15:36:17Z",
      "updatedAt": "2019-06-05T16:52:10Z",
      "closedAt": "2019-06-05T16:52:10Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as NTBF. @armfazh please re-open if needed!",
          "createdAt": "2019-06-05T16:52:10Z",
          "updatedAt": "2019-06-05T16:52:10Z"
        }
      ]
    },
    {
      "number": 73,
      "id": "MDU6SXNzdWU0MDUwMTQzNDI=",
      "title": "Step 8 of SWU is incorrect",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/73",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It reads:\r\n```\r\n   8. Output (X3(t, u), sqrt(g(X3)))\r\n```\r\nwhereas it should be:\r\n```\r\n   8. Output (X3, sqrt(g(X3)))\r\n```\r\n\r\n",
      "createdAt": "2019-01-30T23:36:41Z",
      "updatedAt": "2019-02-07T15:38:57Z",
      "closedAt": "2019-02-07T15:38:57Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I just patched the file directly without a PR. Closing!",
          "createdAt": "2019-02-07T15:38:57Z",
          "updatedAt": "2019-02-07T15:38:57Z"
        }
      ]
    },
    {
      "number": 79,
      "id": "MDU6SXNzdWU0MDg5OTI4NzU=",
      "title": "Multiplying by cofactor",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/79",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Bug: points calculated by Elligator2 suite must be multiplied by the cofactor at the end (Sage script does not do that). Also I consider this task is not optional as the document says.\r\n\r\n_Originally posted by @armfazh in https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/77#issuecomment-462507667_",
      "createdAt": "2019-02-11T21:50:36Z",
      "updatedAt": "2019-06-05T14:53:11Z",
      "closedAt": "2019-06-05T14:53:11Z",
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "NONE",
          "body": "Hi. I'm not sure if this should require a separate issue, but in section 5.3.5 \"Fouque-Tibouchi method\" I don't see mentioned that multiplying by the cofactor is \"usually\" necessary for BLS curves either.\r\nTo quote Fouque-Tibouchi: \r\n> Our results apply almost without change to any elliptic curve of the form [\u2026]: this includes in  particular the curves constructed by Barreto, Lynn and Scott in [2, \u00a73.1] and [\u2026]\r\n> The elliptic curve group in those cases is not usually of prime order, [\u2026], so hashing to the prime order subgroup requires multiplying the point obtained with the technique described herein by the cofactor. This does not affect indifferentiability, as was shown in [12, \u00a76.1].\r\n\r\nIn a recent work of [Budroni and Pintore](https://eprint.iacr.org/2017/419.pdf)  present a (much) faster way of multiplying by the cofactor in G2.\r\n\r\n Would it be welcome a pull request that mentions in which cases it is necessary to multiply by the cofactor? \r\nWould it be pertinent to mention also Pintore-Budroni as a way of performing fast multiplication by the cofactor? \r\nShould there be a sage poc?\r\n\r\n/cc. @AnitaDurr\r\n/cc. @armfazh (a little bird told me you're the right person for asking this!)",
          "createdAt": "2019-03-17T12:14:57Z",
          "updatedAt": "2019-03-17T14:14:35Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Your comments were moved to #95.\r\n@mmaker\r\n@AnitaDurr\r\n",
          "createdAt": "2019-03-19T17:08:47Z",
          "updatedAt": "2019-03-19T17:08:47Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "All encodings now invoke `clear_h()` as the last step, which (at least abstractly) addresses this issue by making cofactor clearing non-optional.\r\n\r\nSo this is addressed in the document, but not here. We could move the impl part into #112 and close this one.",
          "createdAt": "2019-06-03T22:40:36Z",
          "updatedAt": "2019-06-03T22:40:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as resolved for the main document, and moving the implementation work to #112.",
          "createdAt": "2019-06-05T14:53:11Z",
          "updatedAt": "2019-06-05T14:53:11Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "MDU6SXNzdWU0MDg5OTQ1NDE=",
      "title": "Consider to remove index in Hash2base input",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/80",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I am aware that the index allows to separate calls to `hash2base` function inside of SWU and on the construction of Random Oracles. \r\nHowever, I think that the index can be handled externally as follows:\r\n```\r\nRandomOracle(alpha) = hash2Base( alpha || 0 ) + hash2Base( alpha || 1 )\r\n```\r\nand SWU can be handled in the same fashion.  \r\n```\r\ndef SWU(alpha):\r\n    u = hash2Base(label || alpha || 0 ) \r\n    v = hash2Base(label || alpha || 1 )\r\n```\r\nThis modification eases the internal implementation of `hash2base` function and does not require to indicate default values for index in the cases where it is not present.\r\n",
      "createdAt": "2019-02-11T21:55:12Z",
      "updatedAt": "2019-03-01T16:28:11Z",
      "closedAt": "2019-03-01T16:28:11Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "@grittygrease ",
          "createdAt": "2019-02-11T22:26:31Z",
          "updatedAt": "2019-02-11T22:26:31Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "body": "What is your proposed change to the text?",
          "createdAt": "2019-02-11T22:31:44Z",
          "updatedAt": "2019-02-11T22:31:44Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I was thinking on something like this. (PR will come soon)\r\n\r\n```\r\nHashToBase(x)\r\n\r\nParameters:\r\n\r\n  H - cryptographic hash function to use\r\n  hbits - number of bits output by H\r\n  p - order of the base field Fp\r\n  label - context label for domain separation\r\n\r\nPreconditions:\r\n\r\n  floor(log2(p)) + 1 >= hbits\r\n\r\nInput:\r\n\r\n  x - value to be hashed, an octet string\r\n\r\nOutput:\r\n\r\n  y - a value in the field Fp\r\n\r\nSteps:\r\n\r\n  1. t1 = H(\"h2c\" || label || I2OSP(len(x), 4) || x)\r\n  2. t2 = OS2IP(t1)\r\n  3. y = t2 (mod p)\r\n  4. Output y\r\n```\r\n",
          "createdAt": "2019-02-11T22:52:05Z",
          "updatedAt": "2019-02-11T22:52:05Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "If we were to make this change, we would have to make sure the encoding of the index in the external call is handled correctly. E..g in `RandomOracle(alpha) = hash2Base( alpha || 0 ) + hash2Base( alpha || 1 )`, fixing it to be `RandomOracle(alpha) = hash2Base( alpha || 0x00 ) + hash2Base( alpha || 0x01 )`, so that it is exactly one byte. \r\n\r\nBut this seems reasonable since we only have 4 indexes.",
          "createdAt": "2019-02-12T18:41:19Z",
          "updatedAt": "2019-02-12T18:41:41Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "On the other hand, what I like about the current use of the index, is to make it clear that you are doing domain separation. ",
          "createdAt": "2019-02-12T18:42:36Z",
          "updatedAt": "2019-02-12T18:42:36Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Domain separation is right and using just one byte is enough. Decide whether this byte should be pre- or post-fixed.\r\n",
          "createdAt": "2019-02-12T19:04:17Z",
          "updatedAt": "2019-02-12T19:04:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't see a strong reason to change this, so I would prefer to leave the text as is.",
          "createdAt": "2019-02-12T19:10:35Z",
          "updatedAt": "2019-02-12T19:10:35Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "The reason is simplicity. There are only two cases (SWU & RandomOracles) that require domain separation. And this can be handled externally to the `HashToBase` function.\r\n",
          "createdAt": "2019-02-12T20:01:47Z",
          "updatedAt": "2019-02-12T20:01:47Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Why is including the index and concatenating inside HashToBase more difficult than concatenating before calling HashToBase? I think seeing a PR would help clear this up.",
          "createdAt": "2019-02-12T20:05:33Z",
          "updatedAt": "2019-02-12T20:05:33Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "A: It is equivalent concatenating before or inside the function calling.\r\nHowever, my point is that each function must have only one job to do. and I consider that `HashToBase` is getting overloaded with details that only concern to specific algorithms, particularly SWU.",
          "createdAt": "2019-02-12T20:24:50Z",
          "updatedAt": "2019-02-12T20:24:50Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That's a fair point. Functions with optional arguments are annoying. Can you prepare a PR for us to discuss?",
          "createdAt": "2019-02-12T21:25:04Z",
          "updatedAt": "2019-02-12T21:25:04Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Look at PR #83 for proposed changes.",
          "createdAt": "2019-02-13T00:41:11Z",
          "updatedAt": "2019-02-13T00:41:11Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #83.",
          "createdAt": "2019-03-01T16:28:11Z",
          "updatedAt": "2019-03-01T16:28:11Z"
        }
      ]
    },
    {
      "number": 81,
      "id": "MDU6SXNzdWU0MDkwMDU3ODY=",
      "title": "Consider to deprecate hash2increment?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/81",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The purpose of the document is to avoid this bad practice (hash&increment), maybe it must be deprecated or recommended at last resort.\r\n@grittygrease ",
      "createdAt": "2019-02-11T22:26:44Z",
      "updatedAt": "2019-03-01T16:25:26Z",
      "closedAt": "2019-03-01T16:25:26Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Do you mean try and increment? I'm not sure it's bad practice, so I think deprecation is a bit extreme. Perhaps we can ask the list?",
          "createdAt": "2019-02-11T22:28:36Z",
          "updatedAt": "2019-02-11T22:28:36Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we should leave it, but not give it a ciphersuite or recommend its use.",
          "createdAt": "2019-02-11T22:35:59Z",
          "updatedAt": "2019-02-11T22:35:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing for now. We can re-open if others really want to see this happen.",
          "createdAt": "2019-03-01T16:25:26Z",
          "updatedAt": "2019-03-01T16:25:26Z"
        }
      ]
    },
    {
      "number": 82,
      "id": "MDU6SXNzdWU0MDkwMDc0MjM=",
      "title": "Fix a selection method for roots",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/82",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "### background\r\nThe `sqrt(x)` function mathematically provides two correct answers, say r0, r1 \\in Fp such that `r0^2=r1^2=x` and r0+r1 = p\r\n### issue\r\nMost of the encoding papers prove how to obtain points on a elliptic curve internally using the `sqrt` function and this is enough for mathematical purposes. \r\nHowever, for implementation purposes this could bring a source of errors/incompatibilities if the `sqrt` function is not defined accordingly. \r\nI see two options to fix this issue:\r\n\r\n1. Declare explicitly how to compute the `sqrt` function for each case. Although that for `p=3 mod 4` is easy, the remainder cases are not easy to state.\r\n\r\n2. Declare explicitly which root to choose. Relying on math, the document can state, for example, that the valid root to use is the one that is odd (or even). It is known that either `r0` or `r1` will be odd. This allows the implementer to use the best-known algorithm for computing `sqrt` as soon as the root returned by it be the one that is odd (or even).\r\n\r\nI believe that Option 2 is suitable and more flexible. \r\nHappy to hear your comments about it.\r\n\r\n",
      "createdAt": "2019-02-11T22:31:35Z",
      "updatedAt": "2019-06-04T15:38:25Z",
      "closedAt": "2019-06-04T15:38:24Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Related to #54.",
          "createdAt": "2019-02-11T22:34:03Z",
          "updatedAt": "2019-02-11T22:34:03Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Something that inspires this issue was the following script.\r\n```\r\np = 11\r\nF = GF(p)\r\nF(4) ** ((p+1)//4) == sqrt(F(4))  \r\n```\r\nThis should print `true` however is not, because `sqrt` from Sage not always follows the formula for p=3 mod 4.\r\n\r\n",
          "createdAt": "2019-02-11T22:35:10Z",
          "updatedAt": "2019-02-11T22:35:10Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "body": "Good point. We should be explicit. How do you determine whether an element is odd or even in an extension field?",
          "createdAt": "2019-02-11T22:39:52Z",
          "updatedAt": "2019-02-11T22:39:52Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "If `a \\in Fp` (a prime field), then `ZZ(a) mod 2 = {even,odd}`.\r\nIn the case of an extension field, we can think about testing the first component of the element.\r\nExample: if `a \\in Fp^3` then the element can be written as  `a= a_2x^2+a_1x+a_0`, thus testing `ZZ(a_0) mod 2 = {even,odd}` gives the desired property.",
          "createdAt": "2019-02-11T22:48:35Z",
          "updatedAt": "2019-02-11T22:48:35Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "As far as I can tell, this is only an issue in the case of a non-deterministic/non-constant time square root?\r\n\r\nSince we are recommending CT implementations, this might not be an issue (other than updating the sage checks). This was partially addressed in https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/76.\r\n\r\nFor all of the ciphersuites we describe, we have the constant time method via exponentiation.  Are there other popularly used curves/fields which don't fit into those two scenarios?\r\n\r\n",
          "createdAt": "2019-02-12T20:12:43Z",
          "updatedAt": "2019-02-12T20:12:43Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh might you have time to take a stab at this?",
          "createdAt": "2019-02-28T01:35:35Z",
          "updatedAt": "2019-02-28T01:35:35Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "My initial observation is to allow the implementer to use any algorithm for calculating `sqrt` and the hash2curve mapping must state which of the roots to use.\r\nThere are two evidences of this reasoning:\r\n1) In the future, better algorithms for `sqrt` could appear. \r\n  Example: It is known that for p=3 mod 4, the exponent (p+1)/4 gives us one of the roots. However, in the future, it could be a better algorithm that computes `sqrt` that does not obtain the same root as the one obtained by the previous method. \r\n2) Notice that in EdDSA, the calculation of `sqrt` is not explicitly stated, but what is explicitly stated is which root to choose using one bit.  \r\n2.1) In the RFC8032 (Ed25519/448), there is a recommendation about how to compute `sqrt`, but any correct method can work as well.\r\n\r\nThe problem now is how to choose one root over the other. This can be done as I mentioned [above](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/issues/82#issuecomment-462526235). Such a method works, except for elements on extension fields.\r\nThe next task is to find a method that allows distinguishing the roots on extension fields.\r\n\r\n\r\n\r\n",
          "createdAt": "2019-03-01T20:41:06Z",
          "updatedAt": "2019-03-01T20:41:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh, your approach sounds reasonable to me. Can you please prepare a PR?",
          "createdAt": "2019-03-04T16:07:15Z",
          "updatedAt": "2019-03-04T16:07:15Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Future proofing for an improved constant time square root algorithm feels like premature optimization. Won't the majority of use cases use the simple deterministic algorithms? I would support adding guidance in the appendix for the other cases, however.",
          "createdAt": "2019-03-04T16:51:59Z",
          "updatedAt": "2019-03-04T16:51:59Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "It is true, deterministic algorithms is what is required for `sqrt`.\r\n\r\nHowever, calculating `sqrt(a)` gives two possible answers, the problem now is: which root to choose in order to `hash2curve` be also deterministic. \r\n\r\nWe can offer guidance on how to choose a root in order to make test vectors reproducible.\r\nI can prepare a small paragraph summarizing this discussion.\r\n",
          "createdAt": "2019-03-04T18:00:22Z",
          "updatedAt": "2019-03-04T18:00:22Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "I guess my point is whether we should specify precisely how to calculate square root in a deterministic way. Which makes the choice of root redundant, since a deterministic algorithm already \"chooses\" a root inherently.\r\n\r\nIf it were the case that all algorithms only need to use `a^(p-1)/2` or similar, then the resulting implementation is substantially simpler - just compute the exponentiation, there is no awkward root-choosing code.\r\n\r\nIf, on the hand, we allow people to implement `sqrt` however they wish, then I agree this is necessary. It just seems to me that we should be leaning towards the former scenario as much as possible.\r\n\r\n---\r\n\r\nEdit to add: I'm generally thinking of this as \"constant time if and only if deterministic\". We require the former, and achieving the latter motivates not needing a selection method",
          "createdAt": "2019-03-10T20:16:47Z",
          "updatedAt": "2019-03-10T20:18:40Z"
        },
        {
          "author": "hoeteck",
          "authorAssociation": "NONE",
          "body": "This issue also comes up in the context of serialization of curve points (that is, representing curve points as bits), when using the compressed-point representation. I'd suggest coordinating with the folks handling the pairing-curves draft.\r\n\r\nMeanwhile, here's a pointer to how serialization is handled in zcash\r\nhttps://github.com/zkcrypto/pairing/blob/183a64b08e9dc7067f78624ec161371f1829623e/src/bls12_381/ec.rs#L837",
          "createdAt": "2019-04-16T19:21:22Z",
          "updatedAt": "2019-04-16T19:21:22Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "The changes in #104 fix the sign of the output rather than the sign of the sqrt, which addresses this issue. In addition, #115 gives explicit sqrt functions for p = 3 mod 4, p = 5 mod 8, and p = 9 mod 16, which covers essentially every case of interest.",
          "createdAt": "2019-06-03T22:41:56Z",
          "updatedAt": "2019-06-03T22:42:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Indeed. Closing as fixed in #104.",
          "createdAt": "2019-06-04T15:38:24Z",
          "updatedAt": "2019-06-04T15:38:24Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "MDU6SXNzdWU0MDk5NDkzNTY=",
      "title": "Awkward description of FFSTV",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/85",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I think the way we specify the FFSTV (and potentially all the algorithms) is a bit clunky (at best) or ambiguous.\r\n\r\nIf we look at https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/blob/master/draft-irtf-cfrg-hash-to-curve.md#general-construction-ffstv13-ffstv\r\n\r\n```\r\n~~~\r\nhash2curve(alpha) = F(H0(alpha)) + F(H1(alpha))\r\n~~~\r\n\r\nThis construction works for the Icart, SWU, and Simplfied SWU encodings.\r\n\r\nHere, H0 and H1 are constructed as follows:\r\n\r\n~~~\r\nH0(alpha) = HashToBase(alpha || 0x2)\r\nH1(alpha) = HashToBase(alpha || 0x3)\r\n~~~\r\n```\r\n\r\nJust to check we are in agreement with what this is/should be doing. As it is written, you will hash alpha (with 0x02 or 0x03), pass the result to F. Which generally speaking will compute another hash. \r\n\r\nI.e. in Icart, you would effectively have `u = HashToBase(HashToBase(alpha || 0x02))` when computing the first of those? Which is a bit confusing since HashToBase outputs an element in Fp.\r\n\r\nAs an alternative, would we consider rewriting the algorithms to all be `Fp -> E`... Which saves the redundant hashing for some algorithms, but is messy since SWU actually needs `(Fp x Fp) -> E`.\r\n\r\nAnyway, just checking that the above is a correct reading.",
      "createdAt": "2019-02-13T18:50:14Z",
      "updatedAt": "2019-03-01T18:29:19Z",
      "closedAt": "2019-03-01T18:29:18Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I just updated #84 concerning this issue.\r\n",
          "createdAt": "2019-02-13T19:36:22Z",
          "updatedAt": "2019-02-13T19:36:22Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Nice! That looks like a clean way to address this.",
          "createdAt": "2019-02-13T23:19:41Z",
          "updatedAt": "2019-02-13T23:19:41Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #84 ",
          "createdAt": "2019-03-01T18:29:18Z",
          "updatedAt": "2019-03-01T18:29:18Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "MDU6SXNzdWU0MTUyNjMxODA=",
      "title": "Two minor bugs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/87",
      "state": "CLOSED",
      "author": "crockeea",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In the description of HashToBase in section 4, there is a requirement that \u201cH is a hash function which outputs at least floor(log2(p))+**2** bits. In appendix C.5 however, the precondition says that the hash function should output >= floor(log2(p))+**1** bits. I'm not sure which is correct, but they should be consistent.\r\n\r\nIn the algorithm for SimpleSWU, the overview says that the right factor of alpha is (1+(1/(t^4 **+** t^2))), but the original paper (Prop 7) shows (1+(1/(t^4 **-** t^2))). The problem is only in the overview; the algorithm details look correct because step 3 negates alpha.\r\n",
      "createdAt": "2019-02-27T18:23:12Z",
      "updatedAt": "2019-03-01T16:23:55Z",
      "closedAt": "2019-03-01T16:23:55Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "The second error was fixed in the current version (github) of the draft.\r\nSee https://raw.githubusercontent.com/chris-wood/draft-irtf-cfrg-hash-to-curve/master/draft-irtf-cfrg-hash-to-curve.md\r\n",
          "createdAt": "2019-02-27T19:36:17Z",
          "updatedAt": "2019-02-27T19:36:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@crockeea I pushed a fix for the first issue to master. It should just be 1 bit.",
          "createdAt": "2019-03-01T16:23:54Z",
          "updatedAt": "2019-03-01T16:23:54Z"
        }
      ]
    },
    {
      "number": 88,
      "id": "MDU6SXNzdWU0MTYxNzg3ODU=",
      "title": "Consider renaming HashToBase to hash2base for consistency",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/88",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-03-01T16:24:34Z",
      "updatedAt": "2019-03-01T21:13:31Z",
      "closedAt": "2019-03-01T21:13:31Z",
      "comments": []
    },
    {
      "number": 90,
      "id": "MDU6SXNzdWU0MTk1OTMyNzI=",
      "title": "wrong BLS reference curve vs signature",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/90",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\r\nin section 5.3.5. Fouque-Tibouchi Method\r\nThe reference to BLS curve points to the work of BLS signatures.\r\nBLS signatures ->  [BLS01]\r\nBLS curve -> [BLS02]\r\n\r\n[BLS02] Paulo S. L. M. Barreto, Ben Lynn, and Michael Scott. Constructing elliptic curves with prescribed embedding degrees. SCN. 2002",
      "createdAt": "2019-03-11T17:29:06Z",
      "updatedAt": "2019-03-11T18:48:00Z",
      "closedAt": "2019-03-11T18:48:00Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh can you prepare a PR quickly to fix this? We can update the version shortly thereafter.",
          "createdAt": "2019-03-11T17:30:05Z",
          "updatedAt": "2019-03-11T17:30:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #91.\r\n",
          "createdAt": "2019-03-11T18:48:00Z",
          "updatedAt": "2019-03-11T18:48:00Z"
        }
      ]
    },
    {
      "number": 93,
      "id": "MDU6SXNzdWU0MjE1ODk3MjE=",
      "title": "Are all encodings \"well-distributed\" as defined in FFSTV?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/93",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug",
        "help wanted"
      ],
      "body": "Edit: See below, the core issue is showing whether all encodings are \"well-distributed\" which is necessary to use the FFSTV `F(H1(m)) + F(H2(m))` generic RO mechanism.\r\n\r\n----\r\n\r\nWe are missing proofs for using the FFSTV encoding -> RO mechanism for most of the ciphersuites. The original paper (IIRC) proved it for Icart.\r\n\r\nRelated issues: #23 #26 ",
      "createdAt": "2019-03-15T15:58:21Z",
      "updatedAt": "2019-03-19T02:10:24Z",
      "closedAt": "2019-03-19T02:09:57Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "The FFSTV paper states that \r\n```\r\nH(m) = F(H1(m)) + F(H2(m)) \r\n```\r\nis indistinguishable of a random oracle for any encoding `F` that is well-distributed.\r\nHence, this construction is not restricted to the Icart function.\r\n\r\nIs there something I am missing related to this issue?\r\n\r\n",
          "createdAt": "2019-03-15T21:55:13Z",
          "updatedAt": "2019-03-15T21:55:13Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "You're right, I should word it differently. As far as I'm aware the proof for well-distributed(ness) of the other encoding methods is missing.\r\n\r\nRelevant summary from the intro: ![sec](https://imgur.com/orw3NHQ.png)\r\n\r\nI would love to be wrong if there are existing proofs for Elligator, SWU,etc to meet the well-distributed condition. But the line\r\n\r\n> but the proof requires rather technicaltools from algebraic geometry, and uses many particular properties of Icart\u2019s function, which makesit difficult to adapt to other encodings\r\n\r\nMake that sound unlikely?\r\n\r\nI had a rough proof for Elligator2 meeting the conditions of the easier construction `F(H1(m)) + H2(m)G` for . (Requires it being an \"admissable encoding\").",
          "createdAt": "2019-03-16T15:28:22Z",
          "updatedAt": "2019-03-16T15:28:22Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "My understanding of the FFSTV paper is that they were able to prove that \r\n```\r\nH(m) = F(h_1(m))+ ... + F(h_s(m))\r\n```\r\nis a random oracle assuming two new things: \r\n -  `s > 1=genus(E)` and \r\n - the condition for `F` is **relaxed** from _admissible_ to **well-distributed**.\r\n\r\nNow, in order to prove that `F` is well-distributed can be done through bounding character sums (algebraic techniques), instead of using algebraic-geometry techniques. \r\n\r\nProofs for well-distributed(ness):\r\n - Icart (FFSTV Section 5.1)\r\n - SWU (FFSTV Section 5.3)\r\n - Elligator 1 (Tib. Section 4.2) \r\n - FT method for BN Curves (FT2012 and TIB Section 4.3)\r\n\r\nA similar argument as for Elligator 1 can be used for proving that Elligator2 is well-distributed.\r\n\r\n\r\n##### Refs:\r\n[FFSTV] Indifferentiable deterministic hashing to elliptic and hyperelliptic curves\r\n[TIB] Elligator squared (Tibouchi)\r\n[FT] Indifferentiable hashing to barreto-naehrig curves.\r\n\r\n",
          "createdAt": "2019-03-18T23:37:39Z",
          "updatedAt": "2019-03-18T23:37:39Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Ahh, you're right, I was misreading it, but the statement from before was applied to previous results. Okay, that's great. Closing this.",
          "createdAt": "2019-03-19T02:09:57Z",
          "updatedAt": "2019-03-19T02:10:24Z"
        }
      ]
    },
    {
      "number": 95,
      "id": "MDU6SXNzdWU0MjI4NDEzMDc=",
      "title": "encoding for pairings G1 and G2",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/95",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is about this comment: https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/issues/79#issuecomment-473659903\r\n\r\n@mmaker\r\n@AnitaDurr\r\n\r\n",
      "createdAt": "2019-03-19T16:48:03Z",
      "updatedAt": "2019-10-27T06:01:46Z",
      "closedAt": "2019-10-27T06:01:46Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "From the current draft:\r\n> The map2curve_ft(alpha) implements the Fouque-Tibouchi's method {{FT12}} (Sec. 3, Def. 2) which covers the case of pairing-friendly curves E : y^2 = x^3 + B. Note that for pairing curves the destination group is usually a subgroup of the curve, hence, a scalar multiplication by the cofactor will be required to send the point to the desired subgroup.\r\n\r\n#### Facts\r\nIn all the cases, draft recommends to multiply by the cofactor to get a point in a subgroup of the curve. \r\nFor both G1 and G2, there is required to multiply by a cofactor. However, it is true that for G2, the cofactor multiplication is more expensive than on G1.\r\n\r\n#### Comments\r\nAt the end of the day, cofactor multiplication is a scalar multiplication, which can be optimized according to the parameters of the curve.\r\nI think that explaining the techniques used for efficiently perform this scalar multiplication is out of the scope of this draft. \r\nDevelopers are free to chose any method that calculates cP for a cofactor c, where the point P was obtained through the techniques presented in this draft, i.e P=H(m).\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2019-03-19T17:07:41Z",
          "updatedAt": "2019-03-19T17:07:41Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "NONE",
          "body": "Hi Armando, \r\nthanks for your reply. I thought that it was worth mentioning them since there are not many other motivations for scott and fuentes' methods except hashing -- and in \"Guide to pairing-based cryptography\" I see they're illustrated as a part of hashing into the curve. \r\n\r\nCheers.",
          "createdAt": "2019-03-19T17:18:16Z",
          "updatedAt": "2019-03-19T17:18:48Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Of course, references to these works will be very useful for the community. Thanks for pointing this out.",
          "createdAt": "2019-03-19T17:30:20Z",
          "updatedAt": "2019-03-19T17:30:20Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "One thing that's probably worth pointing out is that in general the fast cofactor elimination methods don't multiply by the cofactor `h`, but some multiple `k h` for some small-ish `k` that is coprime to the order of the subgroup. This is germane because you will not get the same result if you clear the cofactor with\r\n\r\n    P_out = h * P\r\n\r\nvs\r\n\r\n    P_out = fast_cofactor_elimination(P)\r\n\r\n(For specific examples, see [Budroni and Pintore](https://eprint.iacr.org/2017/419)'s work on explicit constructions of fast endomorphisms for Barreto-Lynn-Scott curves based on the work of Scott et al. and Fuentes-Castaneda et al.)\r\n\r\nSo, it's slightly concerning if the standard specifies that the correct way to clear the cofactor is to multiply by exactly `h`, since in practice for G2 of a pairing-friendly curve this is going to be slow.",
          "createdAt": "2019-04-20T02:13:16Z",
          "updatedAt": "2019-04-20T02:54:24Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing, since this is handled in the suites with h_eff.",
          "createdAt": "2019-10-27T06:01:46Z",
          "updatedAt": "2019-10-27T06:01:46Z"
        }
      ]
    },
    {
      "number": 96,
      "id": "MDU6SXNzdWU0Mjg0MTY1Mzg=",
      "title": "BLS integration considerations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/96",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "1. For pairing-friendly curves, it might be helpful to have separate cipher\r\nsuites for G1 and G2.\r\n\r\n2. Indeed BLS12-381 is currently missing. For G1, the Fouque-Tibouchi\r\nmethod as written should already work. But for G2, you would need to extend\r\n5.3.5 to handle field extensions. Here\u2019s a pointer to the Chia\r\nimplementation which addresses both:\r\n\r\nhttps://github.com/Chia-Network/bls-signatures/blob/master/SPEC.md",
      "createdAt": "2019-04-02T20:03:08Z",
      "updatedAt": "2019-10-27T06:02:20Z",
      "closedAt": "2019-10-27T06:02:20Z",
      "comments": [
        {
          "author": "hoeteck",
          "authorAssociation": "NONE",
          "body": "May I suggest the ciphersuite string \"H2C-BLS12_381_1-SHA512-FT-\" for hashing to G_1 in BLS12-381 using the Fouque-Tibouchi method with SHA-512?",
          "createdAt": "2019-04-16T19:26:00Z",
          "updatedAt": "2019-04-16T19:26:00Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing. This is handled by Suites and the BLS draft.",
          "createdAt": "2019-10-27T06:02:20Z",
          "updatedAt": "2019-10-27T06:02:20Z"
        }
      ]
    },
    {
      "number": 98,
      "id": "MDU6SXNzdWU0MzI3ODE5MzU=",
      "title": "Update reference code quality",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/98",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "This includes things like updating names, building a framework for testing the hash2curve implementations, and generating test vectors via a script.",
      "createdAt": "2019-04-12T23:44:35Z",
      "updatedAt": "2019-10-28T19:09:46Z",
      "closedAt": "2019-10-28T19:09:45Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as Nice to Have.",
          "createdAt": "2019-10-28T19:09:45Z",
          "updatedAt": "2019-10-28T19:09:45Z"
        }
      ]
    },
    {
      "number": 99,
      "id": "MDU6SXNzdWU0MzM1Mzk4MTM=",
      "title": "Define the amount of additional bits for hashing to Fp",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/99",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Tracking: The main text is imprecise about the amount of bits required to reduce mod p from {0,1}^k to Fp.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "createdAt": "2019-04-16T01:10:29Z",
      "updatedAt": "2019-06-05T14:56:46Z",
      "closedAt": "2019-06-05T14:56:46Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "@mmaker We will track here your derivation for hashing to Fp.",
          "createdAt": "2019-04-16T01:42:22Z",
          "updatedAt": "2019-04-16T01:42:22Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@mmaker will you be able to transcribe your derivation into a PR, or should we take a crack at it?",
          "createdAt": "2019-05-19T01:04:15Z",
          "updatedAt": "2019-05-19T01:04:15Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "According to Brier et al. paper, we can include a line such as:\r\n\r\nIf k is the security parameter, and log2(p)=2k, then the hash function must output at least 3k bits to get 2^-k of statistical distance.\r\n\r\n",
          "createdAt": "2019-05-21T01:07:46Z",
          "updatedAt": "2019-05-21T01:07:46Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh That works, too!",
          "createdAt": "2019-05-21T16:41:15Z",
          "updatedAt": "2019-05-21T16:41:15Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "{{hash2base}} \"Security and performance considerations\" currently says more or less that. Not clear that it requires a cite since it's a pretty straightforward fact, but we could add one.\r\n\r\n> To control bias, the input msg should be hashed to an integer comprising more than log2(p) bits. In particular, reducing an integer of ceil(log2(p)) + k bits modulo p gives bias at most 2^-k, which is a safe choice for a cryptosystem with k-bit security.\r\n\r\nAlso note [thread 1](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/104#discussion_r285818221) and [thread 2](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/104#discussion_r285819630) from #104 about this.",
          "createdAt": "2019-05-21T21:10:45Z",
          "updatedAt": "2019-05-21T21:11:20Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "One more thought on this:\r\n\r\nThe current version of hash2base (and also the updated version of #116 ) relies on H for two purposes:\r\n\r\n1. to hash the input message in a collision-resistant way, and\r\n2. as a pseudorandom generator.\r\n\r\nAssume that H outputs `b` bits, and that the curve being hashed to is part of a ciphersuite giving `k` bits of security.\r\n\r\nTo satisfy (1), we want `b >= 2 * k`, so that the birthday bound is around 2^-k bits.\r\n\r\nRequirement (2) can only be satisfied by assumption; certainly, modeling H as a random oracle is sufficient to satisfy this requirement. Avoiding assumptions of this kind is hard, for the same reason that we don't expect to be able to write down a proof that AES-128 gives 128-bit security.\r\n\r\nWhat's currently written in this section (only) partially captures (2), and I think in #104 @armfazh was keying on the fact that the text does not really deal with (1). To address this, I propose the following:\r\n\r\n- Include the requirement that H outputs `b >= 2 * k` bits, for collision resistance. This takes care of (1).\r\n\r\n- Make explicit that hash2base models H as a random oracle, and therefore H should be a battle-tested primitive.\r\n\r\nThe SHA-2 family is probably the most extensively studied option for H, so it might make sense for the standard to suggest its use. It may also be reasonable to recommend SHA-3 as an alternative.\r\n\r\n--\r\n\r\nA more complicated version of hash2base might separate the hash function used to compute `m'` from the PRG that expands `m'` into pseudorandom values. In that case, one might use (say) SHA256 as H and AES-128 as the PRG. I'm not strongly in favor of this, because it complicates implementations, but it would be a reasonable choice.",
          "createdAt": "2019-05-24T00:16:12Z",
          "updatedAt": "2019-05-24T00:16:12Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this issue is taken care of by the combination of #104 and #116: the document now specifies both the required number of bits for the output of H and the number of invocations of H in hash2base in terms of the security parameter.",
          "createdAt": "2019-06-03T22:36:08Z",
          "updatedAt": "2019-06-03T22:36:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, agreed. Closing due to #104 and #116, as well as implicit text suggesting H is a random oracle for hash2base.",
          "createdAt": "2019-06-05T14:56:46Z",
          "updatedAt": "2019-06-05T14:56:46Z"
        }
      ]
    },
    {
      "number": 100,
      "id": "MDU6SXNzdWU0MzUzNDc1MDA=",
      "title": "Fouque and Tibouchi method: relwork / attribution issue",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/100",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Hi folks,\r\n\r\nThanks for the hard and excellent work on this!\r\n\r\nThere are a couple small issues with the discussion of hashing to pairing-friendly curves.\r\n\r\n1. I notice in the current draft that the section discussing the work of Fouque and Tibouchi at Latincrypt 2012 does not correctly attribute the work. The FT12 paper is clear that the map the authors describe is an instantiation of the Shallue--van de Woestijne method, with constants selected in a way that is convenient for Barreto-Naehrig curves. So a cite of S--vdW (ANTS 2006) would probably be appropriate here.\r\n\r\n2. ~~It's probably important to point out in this section that the map is undefined when u = 0 and when u = sqrt(-1-B). The first case can happen for any curve. The second case can only happen when (-1-B) is square. For BN curves this will never be true, but for BLS curves is can and likely will be. (As a specific example, -1-B is square for BLS12-381, so the map as described is undefined at +/-sqrt(-5).)~~\r\n\r\n~~In fact, the second comment might be true more generally. A brief search of the document doesn't turn up any instances discussing what to do if/when the map is undefined. This is probably important, since in practice many of these maps will have some undefined inputs, and it would be unfortunate if different implementations diverged in their behavior.~~\r\n\r\n~~Since the document appears to be encouraging constant-time implementations, it's not clear that there's a good blanket recommendation that would apply to every map. So it might be useful to think about how to handle undefined behavior on a map-by-map basis, in a way that is amenable to constant-time implementations. I'm happy to help out with this.~~",
      "createdAt": "2019-04-20T02:35:19Z",
      "updatedAt": "2019-05-21T21:38:04Z",
      "closedAt": "2019-05-21T21:38:04Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I moved the undefined cases question to its own issue #103",
          "createdAt": "2019-04-26T20:31:58Z",
          "updatedAt": "2019-04-26T20:31:58Z"
        }
      ]
    },
    {
      "number": 101,
      "id": "MDU6SXNzdWU0MzU5MTQ3Mzc=",
      "title": "New BLS hash2curve algorithm",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/101",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See https://eprint.iacr.org/2019/403",
      "createdAt": "2019-04-22T22:15:54Z",
      "updatedAt": "2019-06-02T21:26:13Z",
      "closedAt": "2019-06-02T21:26:13Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "#104 closed this. Looks like I forgot to note that in the commit messages there. Sorry about that.",
          "createdAt": "2019-06-02T21:09:47Z",
          "updatedAt": "2019-06-02T21:09:47Z"
        }
      ]
    },
    {
      "number": 102,
      "id": "MDU6SXNzdWU0Mzc4MzE1NTc=",
      "title": "suggestion: remove (non-\"simplified\") Shallue--van de Woestijne--Ulas algorithm",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/102",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Hi folks,\r\n\r\nI think there is no reason to suggest in the standard that implementors use non-\"simplified\" SWU (i.e., the one from Ulas 2007). The non-simplified version is less efficient than simplified one and is no more general (i.e., it doesn't apply to any curves that simplified doesn't).\r\n\r\nNote: the second half of the above claim is maybe not totally obvious, but in [our recent work](https://eprint.iacr.org/2019/403) we show a very simple way to extend simplified SWU to curves over fields of any characteristic (not just Fp, p = 3 mod 4).",
      "createdAt": "2019-04-26T20:21:49Z",
      "updatedAt": "2019-05-21T21:38:04Z",
      "closedAt": "2019-05-21T21:38:04Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The non-simplified version is less efficient than simplified one and is no more general (i.e., it doesn't apply to any curves that simplified doesn't).\r\n\r\nI thought the simplified version only applied to curves where `q = 3 mod 4`, whereas this condition was not applicable for the non-simplified version. Is this not true? If it is true, is the claim that there are no curves where `q \\neq 3 mod 4`?",
          "createdAt": "2019-05-19T01:03:06Z",
          "updatedAt": "2019-05-19T01:03:06Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Our [recent eprint (\u00a74.1)](https://bls-hash.crypto.fyi) shows how to extend the simplified version to p != 3 mod 4. It's just a tiny tweak. I rolled this into the omnibus PR (that's the `\\xi` constant).",
          "createdAt": "2019-05-19T02:17:46Z",
          "updatedAt": "2019-05-19T02:17:46Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam I missed that -- thank you!",
          "createdAt": "2019-05-20T15:23:30Z",
          "updatedAt": "2019-05-20T15:23:30Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "MDU6SXNzdWU0Mzc4MzQ3MTY=",
      "title": "handling undefined cases for maps",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/103",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "(moved here from #100)\r\n\r\nA brief search of the document doesn't turn up any instances discussing what to do if/when the map is undefined. This is probably important, since in practice many of these maps will have some undefined inputs, and it would be unfortunate if different implementations diverged in their behavior.\r\n\r\nSince the document appears to be encouraging constant-time implementations, it's not clear that there's a good blanket recommendation that would apply to every map. So it might be useful to think about how to handle undefined behavior on a map-by-map basis, in a way that is amenable to constant-time implementations. I'm happy to help out with this.",
      "createdAt": "2019-04-26T20:31:19Z",
      "updatedAt": "2019-06-02T21:08:41Z",
      "closedAt": "2019-06-02T21:08:41Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "#104 closes this.",
          "createdAt": "2019-06-02T21:08:41Z",
          "updatedAt": "2019-06-02T21:08:41Z"
        }
      ]
    },
    {
      "number": 105,
      "id": "MDU6SXNzdWU0NDU3ODA0NTQ=",
      "title": "style nits: spacing around math operators",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/105",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "In a previous commit I tried to improve consistency for spacing around math operators, but I didn't quite catch them all.\r\n\r\n~~I think the biggest remaining one is whether `=` should have surrounding spaces or not.~~ done (#136)\r\n\r\nTODO: implement consistent style",
      "createdAt": "2019-05-19T04:58:33Z",
      "updatedAt": "2019-10-27T02:46:15Z",
      "closedAt": "2019-10-27T02:46:15Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Generalizing to spacing: also need to decide about \"Elligator 2\" (as written in the Elligator paper) vs. Elligator2 (no space).",
          "createdAt": "2019-05-21T18:18:32Z",
          "updatedAt": "2019-05-21T18:18:32Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "TODO: decide whether to use `=` or `==`",
          "createdAt": "2019-06-02T18:09:16Z",
          "updatedAt": "2019-06-02T18:09:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's my $0.02:\r\n\r\n- Yes, include spaces around `=`.\r\n- Use `==` for equality statements, i.e., \"if `x == 2`\", and reserve `=` for variable assignment only.\r\n- Write as Elligator2, despite its deviation from the paper.\r\n\r\n@armfazh, what do you think?",
          "createdAt": "2019-06-05T15:05:11Z",
          "updatedAt": "2019-06-05T15:05:48Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood are we good to close this, then?",
          "createdAt": "2019-10-27T02:26:25Z",
          "updatedAt": "2019-10-27T02:26:25Z"
        }
      ]
    },
    {
      "number": 106,
      "id": "MDU6SXNzdWU0NDU3ODA2ODg=",
      "title": "sqrt: split by field characteristic",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/106",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@chris-wood suggested splitting the sqrt description into three separate cases:\r\n\r\n> Perhaps we should re-write this section as a series of algorithms for the different conditions? That might help ease implementation should people choose to use one of them.\r\n\r\n_Originally posted by @chris-wood in https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/104_",
      "createdAt": "2019-05-19T05:03:39Z",
      "updatedAt": "2019-05-31T17:12:51Z",
      "closedAt": "2019-05-31T17:12:51Z",
      "comments": []
    },
    {
      "number": 107,
      "id": "MDU6SXNzdWU0NDU3ODA4NzE=",
      "title": "discuss point conversions (perhaps in appendix)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/107",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@chris-wood suggested:\r\n\r\n> Should we generalize the Montgomery->Edwards point conversion function? (I would have benefited from such a function being written in cleartext *somewhere* earlier this year.) We might then also include conversion from, say, Weierstrass to Montgomery, among others.\r\n\r\n_Originally posted by @chris-wood in https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/104_",
      "createdAt": "2019-05-19T05:07:35Z",
      "updatedAt": "2019-10-27T03:06:16Z",
      "closedAt": "2019-10-27T03:06:16Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Related to this: in an offline conversation, @reyzin pointed out that the Montgomery->Edwards conversions as currently specified don't quite match up with the ones in RFC 7748. Specifically, in the case of Ed25519 this document's values for A and B give a curve isomorphic to the curve in 4.1 of that RFC. Either is *correct*, but it would be best to be consistent with that document.\r\n\r\nI've got a TODO to figure out a good way of handling this, and probably this issue should also comprehend that.",
          "createdAt": "2019-05-19T05:12:36Z",
          "updatedAt": "2019-05-19T05:12:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing, since I consider this resolved.",
          "createdAt": "2019-10-27T03:06:16Z",
          "updatedAt": "2019-10-27T03:06:16Z"
        }
      ]
    },
    {
      "number": 108,
      "id": "MDU6SXNzdWU0NDU3ODE5Mjk=",
      "title": "sgn0: make impl in poc/ match description in document",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/108",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The version of sgn0 in common.sage does the same thing as the description in the document, but is probably more confusing than necessary.\r\n\r\nTODO: rewrite to match impl from the document",
      "createdAt": "2019-05-19T05:26:30Z",
      "updatedAt": "2019-06-03T20:53:30Z",
      "closedAt": "2019-06-03T20:53:30Z",
      "comments": []
    },
    {
      "number": 109,
      "id": "MDU6SXNzdWU0NDU3ODI5MzE=",
      "title": "possible enhancement: mapping to projective coordinates everywhere",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/109",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Most of the maps can be made faster by dealing in projective rather than affine coordinates, since this should suffice to eliminate inversions (maybe with one more trick here and there).\r\n\r\nIf the goal is to suggest nicely optimized implementations everywhere, one possibility is to allow all map definitions to give projective outputs and then separately handle conversion back to affine coordinates.\r\n\r\nMapping to a projective point and then clearing the denominator is just as fast as mapping directly to an affine coordinate. In most cases, it's faster end-to-end: if the higher-level application does further operations on the output of the map, it's safe to assume those operations will be over projective coordinates, in which case converting to affine coordinates first is unnecessary and strictly slower.\r\n\r\nThis probably requires a small discussion (appx? elsewhere?) about projective coordinates, conversions, etc. Happy to take a crack at this.",
      "createdAt": "2019-05-19T05:41:29Z",
      "updatedAt": "2019-10-27T03:04:43Z",
      "closedAt": "2019-10-27T03:04:43Z",
      "comments": []
    },
    {
      "number": 110,
      "id": "MDU6SXNzdWU0NDY3NTc1MDg=",
      "title": "style nits: variable naming",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/110",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "@armfazh prefers short variable names (per comments in #104).\r\n\r\n@chris-wood observed that there are some inconsistencies in naming, e.g., `msg` vs `alpha`.\r\n\r\nMy changes in #104 were aimed at avoiding overloaded symbols.\r\n\r\nI think it's possible to resolve all of these simultaneously, with some thought. Let's discuss what the names should be (short? descriptive? `msg`? `alpha`? `x`?), write down a \"style guide,\" and update the document to follow it.",
      "createdAt": "2019-05-21T18:16:42Z",
      "updatedAt": "2020-03-03T18:58:53Z",
      "closedAt": "2020-03-03T18:58:53Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "~~TODO: the \"Try-and-Increment Method\" appendix has some overloading of the variable `h`~~\r\n\r\nremoved by #122",
          "createdAt": "2019-05-21T18:41:39Z",
          "updatedAt": "2019-06-05T18:01:57Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "~~spell out \"to\" rather than number 2 everywhere?~~\r\n\r\n~~hash2field/hash_to_field vs hash2base vs hash_to_base_field, etc.~~\r\n\r\ntaken care of by #130",
          "createdAt": "2019-06-05T16:23:39Z",
          "updatedAt": "2019-06-27T20:01:51Z"
        },
        {
          "author": "jedisct1",
          "authorAssociation": "NONE",
          "body": "`_to_` rather than `2` improves readability.",
          "createdAt": "2019-06-05T16:32:24Z",
          "updatedAt": "2019-06-05T16:32:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We can close this now.",
          "createdAt": "2020-03-03T18:58:53Z",
          "updatedAt": "2020-03-03T18:58:53Z"
        }
      ]
    },
    {
      "number": 111,
      "id": "MDU6SXNzdWU0NDY3NzgxMjY=",
      "title": "optimized straight-line implementations: generic or specific?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/111",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Right now the document gives straight-line procedures for evaluating each map, which seem to be aimed at being general purpose.\r\n\r\nWe've discussed in #104 an alternative approach in which these straight-line implementations are geared toward *specific* curves (e.g., standardized and widely-used curves). This would likely be more useful for implementors, both because they would be able to port these directly (rather than having to understand and adapt the generic procedures) and because it would allow us to roll in more optimizations.\r\n\r\nThe `poc/` directory gives us a good start on the list of curves that should be supported in this way. I'm happy to propose a list of curves and write down optimized straight-line implementations for each.",
      "createdAt": "2019-05-21T19:08:06Z",
      "updatedAt": "2019-10-27T06:13:21Z",
      "closedAt": "2019-10-27T06:13:21Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "TODO: if the decision is to target specific rather than generic curves, make sure to cover cofactor clearing in each curve's implementation\r\n\r\n[see conversation from 104](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/104#discussion_r282707881)",
          "createdAt": "2019-05-21T19:09:14Z",
          "updatedAt": "2019-05-21T21:06:24Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Probably #109 gets resolved by this decision, too.",
          "createdAt": "2019-05-21T19:42:40Z",
          "updatedAt": "2019-05-21T19:42:40Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh [notes](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/104#discussion_r286204135):\r\n\r\n> There is a section that is missing to be written, which is the instantiations of suites. In such a section, draft must specify all the parameters for a given curve. For example, the suite correspondent to BLS12-381 will state which isogeny was used and all other relevant parameters.\r\n\r\nTODO: make sure this is covered\r\n\r\nNote that commit fe7df96 removes text about finding isogenies. Can bring back if required.",
          "createdAt": "2019-05-21T20:56:53Z",
          "updatedAt": "2019-05-21T21:03:40Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "discussion with @chris-wood:\r\n\r\nintroduce new appx, \"curve-specific impls\". For each of a list of well-known curves, provide a highly optimized implementation of the recommended map for that curve.\r\n\r\nReason: This encourages implementors to use the \"right\" map for common curves, and gives them a nice implementation.",
          "createdAt": "2019-06-05T16:52:20Z",
          "updatedAt": "2019-06-05T16:52:20Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I am agree that there are lots of implementation tricks that can be used for implementing the suites. (number theoretic tricks, projective coordinates, isogenies, birational mappins,)\r\nAs a developer I would be happy to have all of these resources off-the-shelf.\r\n\r\nHowever, I think #126 is a dependency that must be solved first.\r\nBesides of what is pointed there, another concern is about the length of the document. \r\nSimplicity is an aspect to consider too. A concise and simple description of the mappings together with compatible test vectors should be enough.\r\n\r\nA MITM suggestion is to write a complete set of optimizations in a second document that we can post publicly on eprint and arXiv targeting developers.\r\n",
          "createdAt": "2019-06-13T09:58:40Z",
          "updatedAt": "2019-06-13T10:26:47Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "stashing a note from [this comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/127#discussion_r297413871): check forward refs from mapping descriptions to example code, and be systematic (one way or another) about listing curves to which an encoding applies.",
          "createdAt": "2019-06-26T06:44:02Z",
          "updatedAt": "2019-06-26T06:44:02Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "The decision was to keep body text generic and make optimized appendices.\r\n\r\nSeparately, we still need to add more optimized impls to the appx. I've created #181 to capture that.",
          "createdAt": "2019-10-27T06:13:21Z",
          "updatedAt": "2019-10-27T06:13:21Z"
        }
      ]
    },
    {
      "number": 112,
      "id": "MDU6SXNzdWU0NDY3OTY4NjM=",
      "title": "meta-issue: implementation cleanup",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/112",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Moving these from #104.\r\n\r\n- [x] consider removing unused implementations (e.g., ell2edwards, fouquetibouchi)\r\n\r\n- [ ] update test vectors\r\n\r\n- [x] ~~update hacspec implementations to cover new encodings~~ remove hacspec for now (can bring back later if necessary)\r\n\r\n- [x] clear cofactors to match the document\r\n\r\n- [x] edwards448: use 4-isogeny from RFC7748 rather than current rational map\r\n\r\n- [x] #117 --- make sure to use CMOV in straight-line impls",
      "createdAt": "2019-05-21T19:55:18Z",
      "updatedAt": "2020-03-03T18:58:36Z",
      "closedAt": "2020-03-03T18:58:35Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "TODO: the edwards448 impl doesn't use the 4-isogeny from RFC7748. Fix this.",
          "createdAt": "2019-06-28T01:02:37Z",
          "updatedAt": "2019-06-28T01:02:37Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I kind of like the generic approach in `poc/svdw_new.sage`, which effectively copies the two generic impls from the text and tests that they give the same value, etc. My vote would be to do one such impl for each map, and use those impls to generate test vectors. We can also test the curve-specific code from the appendices against these generic impls.\r\n\r\nHappy to push this forward once we're done with Singapore prep.",
          "createdAt": "2019-10-27T06:17:42Z",
          "updatedAt": "2019-10-27T06:17:42Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I've ticked the above boxes based on #188. From my perspective, all that remains is updating test vectors.",
          "createdAt": "2019-11-05T07:24:51Z",
          "updatedAt": "2019-11-05T07:24:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. Closing and duping to #216, which tracks test vectors.",
          "createdAt": "2020-03-03T18:58:35Z",
          "updatedAt": "2020-03-03T18:58:35Z"
        }
      ]
    },
    {
      "number": 113,
      "id": "MDU6SXNzdWU0NDY3OTc4NTE=",
      "title": "related work: points as bitstrings",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/113",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Moved from #104 \r\n\r\n- [x] Consider mentioning related work on points-as-bitstrings (Elligator, Elligator Squared, Binary Elligator Squared)",
      "createdAt": "2019-05-21T19:57:52Z",
      "updatedAt": "2019-06-04T21:16:53Z",
      "closedAt": "2019-06-04T21:16:53Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "see #122",
          "createdAt": "2019-06-04T01:03:44Z",
          "updatedAt": "2019-06-04T01:03:44Z"
        }
      ]
    },
    {
      "number": 117,
      "id": "MDU6SXNzdWU0NDg1NjcyOTI=",
      "title": "Use cmov-like instructions instead of brancing",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/117",
      "state": "CLOSED",
      "author": "vanhoefm",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In some parts, examples use branching statements instead of cmov-like instructions. Examples of this are in the hacspec code: https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/blob/master/draft-irtf-cfrg-hash-to-curve.md#simplified-swu-method-sswu\r\n\r\nIt is better to use cmov-like instructions everywhere, to avoid developers from using conditional branches in their code (which possibly will lead to side-channel attacks).",
      "createdAt": "2019-05-26T13:28:36Z",
      "updatedAt": "2019-10-24T19:54:27Z",
      "closedAt": "2019-10-24T19:54:27Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "You're totally right. Note that the sample code is out of date at this point. I'm hoping to address that, which should comprehend both this issue and #112, in the not-too-distant future.",
          "createdAt": "2019-06-02T21:12:38Z",
          "updatedAt": "2019-06-02T21:12:38Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "This is comprehended in #112, so I'm closing.",
          "createdAt": "2019-10-24T19:54:27Z",
          "updatedAt": "2019-10-24T19:54:27Z"
        }
      ]
    },
    {
      "number": 120,
      "id": "MDU6SXNzdWU0NTE2ODAxOTM=",
      "title": "ROM order of operations: clear cofactor after point addition",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/120",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The current descriptions of the maps include cofactor clearing. In the ROM case this is not good: ofactor clearing is potentially an expensive operation, and it commutes with point addition.\r\n\r\nTODO: the standard should be written in a way that makes clear that the cofactor clearing operation happens *after* point addition in the ROM case.\r\n\r\n#118 and #119 should probably handle this issue.",
      "createdAt": "2019-06-03T20:42:26Z",
      "updatedAt": "2019-06-18T19:58:44Z",
      "closedAt": "2019-06-18T19:58:43Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We can close this once #118 and #119 land.",
          "createdAt": "2019-06-05T15:07:58Z",
          "updatedAt": "2019-06-05T15:07:58Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> We can close this once #118 and #119 land.\r\n\r\n#121 is the unique dependence.\r\n",
          "createdAt": "2019-06-13T09:33:59Z",
          "updatedAt": "2019-06-13T09:33:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #121. ",
          "createdAt": "2019-06-18T19:58:43Z",
          "updatedAt": "2019-06-18T19:58:43Z"
        }
      ]
    },
    {
      "number": 124,
      "id": "MDU6SXNzdWU0NTI4NTIyNDE=",
      "title": "ciphersuites and domain separation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/124",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Chris and I discussed the issue of ciphersuites and domain separation in hash-to-curve. Put concisely, the question is, should hash-to-curve provide domain separation among the suites, or should domain separation be left to the upper-level protocol? We decided that the best way to proceed is to get feedback from the CFRG list by coming up with and sending two specific proposals along with a discussion of pros and cons.\r\n\r\nFrom chatting with the BLS and VRF folks, my impression is that they prefer to keep ciphersuites out of hash-to-curve. Their argument is (paraphrasing), the upper-level protocol needs to ensure domain separation, so what's the point of doing it redundantly in hash-to-curve? There was also serious concern about variable-length ciphersuite strings (currently used in the poc impls but not specified in the document), because that is a potential source of confusion and bugs. [Right now](https://github.com/pairingwg/bls_standard/blob/master/minutes/spec-v1.md), the BLS sigs standard is proceeding with no ciphersuite in hash-to-curve, only in the BLS signature itself.\r\n\r\nBut there may be room to meet in the middle. For example, it would be essentially free to add a short, fixed-length ciphersuite (say, <20 bytes) in hash2base. It might be worth running this by the BLS and VRF folks before we go to the list, to hear out the likely objectors first and see if we can get buy-in.\r\n\r\nConcretely, I propose that we consider the following two options.\r\n\r\n#### option 1: no ciphersuite\r\n\r\nThis preserves the current version of hash2base as specified in the document. The important line is the one in which msg gets hashed. In the current version, that's\r\n\r\n```\r\nm' = H(msg) || I2OSP(ctr, 1)\r\n```\r\n\r\n#### option 2: fixed string + 4-byte ciphersuite in hash2base\r\n\r\n```\r\nm' = H(\"HASH-TO-CURVE\" || ciphersuite || msg) || I2OSP(ctr, 1)\r\n```\r\n\r\nEDIT: or, maybe slightly preferable so that \"prehash-for-free\" still works:\r\n\r\n```\r\nm' = \"HASH-TO-CURVE\" || ciphersuite || H(msg) || I2OSP(ctr, 1)\r\n```\r\n\r\nEDIT 2: I think it's safe to assume that \"ciphersuite\" here would be generated following something like the procedure in [this comment, below](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/124#issuecomment-507069455). This avoids issues with ciphersuites for curves not discussed in the spec document.\r\n\r\nNote that the string \"HASH-TO-CURVE\" ensures domain separation even from other protocols that use a 4-byte ciphersuite tag. It might be nice for protocols to adopt this approach more genreally.\r\n\r\n(Actually, I kind of like the idea of using the RFC number (e.g., \"RFC1234\" for RFC 1234's domain separation string), but that has the downside that the protocol's test vectors can't be finalized until the RFC number is assigned.)\r\n\r\nThoughts on the above two proposals? Any other issues we should consider?",
      "createdAt": "2019-06-06T06:23:51Z",
      "updatedAt": "2019-10-27T06:07:27Z",
      "closedAt": "2019-10-27T06:07:26Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "If we assume a fixed-length value for the cipher suite, e.g., a 2 or 4 byte value that maps to a ciphersuite and is maintained by a registry, I think I'm more comfortable with option 2. While it may be redundant, it seems as though it would help prevent possible misuse or failure to add domain separation by the calling code or protocol. @armfazh @grittygrease @samscott89, please chime in!",
          "createdAt": "2019-06-06T16:27:59Z",
          "updatedAt": "2019-06-06T16:27:59Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I will go for not including domain separation inside the definition of the suite.\r\n\r\nHash-to-curve functions must be as generic as possible. Note that the interface receives a string of opaque bytes. \r\nThen, the job of the caller is to produce a meaningful string according to him/her purposes. As a consequence, providing or not a domain separation string must be decided by the top-level protocol.\r\n\r\nI also consider, the document must provide recommendations about the usage of the suites, providing advise on the cases where domain separation is necessary.\r\n\r\nI might not be considering all the scenarios, feedback is appreciated.",
          "createdAt": "2019-06-13T10:16:24Z",
          "updatedAt": "2019-06-13T10:16:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "As a point of comparison, HPKE [1] bakes the cipher suite into the context string used inside the Seal and Open functions. I'm not sure doing something similar here, with a fixed-length suite, would negatively impact generality, especially since the ciphersuite already uniquely determines the set of algorithms used to construct `hash_to_curve`. In other words, including the suite provides further separation between `hash_to_curve` implementations based on different ciphersuites. \r\n\r\n[1] https://tools.ietf.org/html/draft-barnes-cfrg-hpke-00#section-5.1",
          "createdAt": "2019-06-13T15:39:25Z",
          "updatedAt": "2019-06-13T15:39:25Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I thought about this a bit more over the past few days, and I tend to think that domain separation in hash-to-curve will not do much for security in practice; I explain below. But as @chris-wood says, if it doesn't hurt performance or generality, I'd tend to err on the side of caution, with two caveats. First, if we include domain separation, we should also do as @armfazh suggests and add either language or a citation that recommends domain separation strings in upper-level protocols; otherwise, the worry is that we'd give users the incorrect impression that domain separation at the protocol level was unnecessary. Second, we need to make sure we have an interop story for curves that are not in the \"official\" ciphersuite table; see my comment immediately below.\r\n\r\n(Come to think of it: are there any CFRG guidelines or informational documnents that talk about domain separation? Should there be? It might be nice if there were a uniform way of doing domain separation, and if every CFRG protocol just did it that way.)\r\n\r\nOK, why should we think it won't do much? Recall that one reason to use domain separation is to make sure that random oracle security proofs still hold when protocols are composed---in particular, that composition doesn't break the freshness of random oracle queries. Concretely, if protocol A's security proof relies on making a fresh random oracle query on input X, and an attacker can force composed protocol B to make a query on input X first, the security of the composition may be broken.\r\n\r\nNow, let's think about a scenario where we're composing two protocols that both use hash-to-curve, and in which neither protocol uses domain separation strings. In this case, whether or not domain separation at the hash-to-curve level helps depends on whether or not the two protocols use the same hash-to-curve suite. Specifically, if the two protocols use different curves, h2c domain separation would help them. But if they use the same curve and h2c suite, it wouldn't.\r\n\r\nSo: if we think that composed protocols would end up using the same suite in almost all cases, then we should probably conclude that h2c domain separation won't do much. My inclination is to believe that implementors will prefer to use a single hash-to-curve codebase, i.e., that they'll actively try to use a common suite when composing protocols---which defeats the h2c domain separation.\r\n\r\nBut like I said, if adding separation is really free, then maybe there's no reason not to do it...",
          "createdAt": "2019-06-13T17:43:25Z",
          "updatedAt": "2019-06-19T21:56:29Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "On the question of whether h2c is really free, I have a concern: if domain separation includes an opaque ciphersuite ID from a table, there is the possibility that interop will be broken for curves/suites that aren't in the table.\r\n\r\nI think this qualifies as a real downside, and it's something we have to think carefully about if we include suite IDs in hash2base.\r\n\r\nAlong these lines, if we're going to have a ciphersuite table in the RFC, how and when does that table get updated with new suites? Would it make sense to run an informal registry of not-yet-standardized suites, e.g., on GitHub? (I see this ties into #126)",
          "createdAt": "2019-06-13T17:49:47Z",
          "updatedAt": "2019-06-13T17:53:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Come to think of it: are there any CFRG guidelines or informational documnents that talk about domain separation? Should there be? It might be nice if there were a uniform way of doing domain separation, and if every CFRG protocol just did it that way.\r\n\r\nInteresting idea! At the very least, it seems like something worth discussing in Montreal. Shall we put down something in writing?",
          "createdAt": "2019-06-13T19:32:43Z",
          "updatedAt": "2019-06-13T19:32:43Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Interesting idea! At the very least, it seems like something worth discussing in Montreal. Shall we put down something in writing?\r\n\r\nOh, good idea! Let me think a bit about this. (But: is it reasonable to assume that the in-writing bit is lower priority than getting this draft updated?)",
          "createdAt": "2019-06-13T23:54:51Z",
          "updatedAt": "2019-06-13T23:54:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": ">  is it reasonable to assume that the in-writing bit is lower priority than getting this draft updated?\r\n\r\nAbsolutely!",
          "createdAt": "2019-06-14T12:46:05Z",
          "updatedAt": "2019-06-14T12:46:05Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "After thinking about this for a few more days, I still don't see a clear path to a good interop story for curves that aren't enumerated in the document. Because of that, I'm worried that adding a ciphersuite tag will hurt the interop story for hash-to-curve without a compensating improvement in security (for reasons given in my prior comments).\r\n\r\nSo: I think my preference is tending towards adding language that encourages upper-level protocols to add domain separation, but not to add it in hash-to-curve.\r\n\r\nI've asked the BLS and VRF standards authors for their thoughts; I'm hopeful that they'll come and add comments to this issue.",
          "createdAt": "2019-06-19T22:01:05Z",
          "updatedAt": "2019-06-19T22:01:05Z"
        },
        {
          "author": "reyzin",
          "authorAssociation": "NONE",
          "body": "I tend to agree with @kwantam. The security benefits of domain separation at the hash-to-curve level are unclear to me, but the logistical drawbacks are. If you add ciphersuites to this draft and someone wants to use hash-to-curve with a new hash function or a new curve, they would have to figure out the IETF process for adding a new ciphersuite to this standard, in addition to whatever other standardization and implementation efforts they are already undertaking. Increasing logistical barriers means some people just won't bother and will choose their own options, ignoring this process.\r\n\r\nI think the value of hash-to-curve draft is that it covers a broad range of use cases, hash functions, base fields, and curves. Adding ciphersuites will reduce this value.\r\n\r\nAlso, adding ciphersuties will make existing implementations already deployed in the wild (such as implementations of the [VRF draft](https://datatracker.ietf.org/doc/draft-irtf-cfrg-vrf/)) incompatible.",
          "createdAt": "2019-06-20T18:31:34Z",
          "updatedAt": "2019-06-20T18:31:34Z"
        },
        {
          "author": "hoeteck",
          "authorAssociation": "NONE",
          "body": "I also tend to agree with both @kwantam and @reyzin, namely that ciphersuite and domain separation should be provided/enforced by the high-level application.\r\n\r\nHere's a slightly different take on the issue: do we expect a ciphersuite string in hash-to-curve to contain any additional information that's not already in the ciphersuite string for the high-level application (e.g. BLS signatures)? To me, that shouldn't be, because the latter should completely determine which hash-to-curve algorithm will be used. If so, I don't see any advantage to having the same information appear twice; if anything, there's only disadvantages, namely aesthetics, and as @reyzin pointed out, logistic drawbacks to maintaining consistency.\r\n\r\nSide note / clarification: I think it'd still be useful for hash-to-curve to specify a table of ciphersuite strings (which will be referred to by the higher-level applications), but the ciphersuite string should not be part of the input to hash2base.",
          "createdAt": "2019-06-21T04:35:59Z",
          "updatedAt": "2019-06-21T04:35:59Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "The arguments put forth here seem reasonable. Trying not to overthink it, but there are 4 scenarios, where you have the application author and library author are different people, each of whom can either use domain separation or not.\r\n\r\n1. Domain separation in both -> redundant info, and logistical drawbacks\r\n2. App does separation, not library (as suggested here) -> all good!\r\n3. App does not do separation, neither does library (app author is not following RFC properly) -> potential cross-protocol attacks\r\n4. App does not do separation, but library does (app author not following RFC, but library author follows our alternative, i.e. what we previously had) -> Perhaps cannot mount some attack against swapping out curves, but still potentially can do cross-protocol against app usage elsewhere?\r\n\r\nThe point being, the difference between 3 and 4 doesn't seem particularly meaningful, but the gap between 1 and 2 does. Unless there's a convincing reason why 4 is a bad situation.\r\n\r\nThe reason I think this is an important distinction, is the number of implementations of h2c should be much fewer than the numbers of implementations of applications.\r\n",
          "createdAt": "2019-06-21T15:33:52Z",
          "updatedAt": "2019-06-21T15:33:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The point being, the difference between 3 and 4 doesn't seem particularly meaningful, but the gap between 1 and 2 does. Unless there's a convincing reason why 4 is a bad situation.\r\n\r\nIMO this is the crucial bit. I don\u2019t think we can assume applications will add domain separation, even if we say they MUST do so. That seems to imply that we\u2019re left considering the pros and cons of 1+4 (library does it) versus 2+3 (library doesn\u2019t do it). \r\n\r\nWhat\u2019s more troubling is that while I agree with all of the downsides, from logistical nightmares to additional complexity and less re-use, the upsides are not well understood. That is, we have some concerns about possible cross-protocol attacks if h2c doesn\u2019t perform domain separation. (Perhaps these are silly and not well founded \u2014 I\u2019m not an expert here.) I think some more rigor would help make the decision easier. And it\u2019s probably time to take this issue to the list for wider discussion. :-)",
          "createdAt": "2019-06-21T17:36:44Z",
          "updatedAt": "2019-06-21T17:36:44Z"
        },
        {
          "author": "reyzin",
          "authorAssociation": "NONE",
          "body": "@chris-wood you are right, we should consider potential upsides. Here are the upsides as I understand them. The main value of domain separation that I know is if the same secret key is used in multiple different schemes. In that case, domain separation may (but won't always!) help a security proof for the joint security of these schemes to go through, because at least random oracle queries of the two schemes will not overlap, so whatever arguments required fresh randomness / programmability are more likely to still go through.\r\n\r\nI have not seen a convincing case for domain separation besides the above scenario.\r\n\r\nBut in general using the same SK for multiple purposes requires a thorough analysis, and simply putting in domain separation is insufficient. Moreover, domain separation only at the level of hash-to-curve is even less likely to be sufficient, because it will not necessarily ensure domain separation in the upstream apps -- esp. if the apps are using the same curve.\r\n\r\nBasically, app-level domain separation is where you would get the upsides. The chances of the upsides coming from domain separation in hash-to-curve are low, because if people are using the same SK for different schemes, they are likely using the same curve, too.",
          "createdAt": "2019-06-21T18:28:16Z",
          "updatedAt": "2019-06-21T18:28:16Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Another issue that came up in discussing #132: if hash-to-curve injects a ciphersuite string, and assuming that (say) curve25519 and edwards25519 have different ciphersuites, then these two hash functions won't be compatible. It would probably be nicer if hash-to-curve25519 and hash-to-edwards25519 gave points that are equivalent via the birational map specified in RFC7748.",
          "createdAt": "2019-06-28T00:33:51Z",
          "updatedAt": "2019-06-28T00:33:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@reyzin I concur :-) and I don't have a convincing case to deliver. I was simply advocating for weighing the options. It seems most folks (at least here on GitHub) are in favor of pushing the burden of domain separation to hash-to-curve callers, which is probably fine. Minimally, we should add some text describing why we find this tradeoff acceptable, if we go down that route. ",
          "createdAt": "2019-06-28T04:59:12Z",
          "updatedAt": "2019-06-28T04:59:12Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I was chatting with @henrycg about this last night, and he pointed out something that's perhaps a second-order concern, but certainly worth writing down: a case where h2c domain separation would *potentially* be useful is when a single protocol makes queries to two distinct hash-to-curve oracles, and relies on those queries being uncorrelated.\r\n\r\n(Note that this is a case where we expect that a protocol's ciphersuite string is *not* sufficient to give domain separation, which answers @hoeteck's question above in a perhaps unexpected way.)\r\n\r\nOur discussion was in the context of a contrived example of a protocol that hashes to both Curve25519 and P-256, but I think there's a much more natural one. Consider a protocol (vaguely reminiscent of the one by [Muller](https://link.springer.com/chapter/10.1007/978-3-540-30108-0_21)) that uses points on both an elliptic curve and on its quadratic twist. Suppose that this hypothetical protocol relies on hashing to both the curve and its twist, and models these two hash functions as independent random oracles.\r\n\r\nIn this case, simply following the hash-to-curve document would *not* yield independent random oracles. Since the curve and its twist by definition reside in the same base field, the hash_to_base function for both curves will make exactly the same calls to H (say, SHA256), and will return exactly the same value. Now it's not at all obvious that the two oracles are uncorrelated!\r\n\r\nTo be clear, I don't know of any protocol like the above. But you could certainly imagine that a reader of the current hash-to-curve draft who is trying to implement such a protocol might incorrectly assume that hashes to two different curves can be treated as orthogonal random oracles!\r\n\r\nThere are a couple possible remedies here:\r\n\r\n1. In the forthcoming section of the document that discusses domain separation, make clear that different hash functions *cannot* be treated as orthogonal random oracles, and upper-level protocols that hash to multiple curves must add domain separation between those curves.\r\n\r\n2. Reconsider the ciphersuite question, again! @henrycg and I discussed a method for coming up with domain separation tags that might work. I'll specify it in a separate comment.",
          "createdAt": "2019-06-30T20:52:52Z",
          "updatedAt": "2019-06-30T22:03:17Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Summarizing the practical concerns with adding a domain separation tag to hash-to-curve, the primary concerns are\r\n\r\n1. How can someone derive a conforming ciphersuite tag for a curve that's not specified in the document, and\r\n\r\n2. How can we give the very nice property that (for example) hash-to-curve25519 and hash-to-edwards25519 return equivalent points? More generally, we'd like it to be the case that isogenous curves have equivalent hash functions, in the sense that hashing any string s to isogenous curves E and E' returns points that are related by the isogeny map.\r\n\r\nHandling (1), at a high level, requires us to specify some deterministic algorithm to compute a ciphersuite tag given the parameters of an elliptic curve. Handling (2) is slightly trickier, but it appears to be possible. Here's how:\r\n\r\nIt is a theorem (due to Tate) that any two curves over a field F having the same number of points are isogenous. (In fact, the implication goes both ways; the other direction is obvious by the definition of an isogeny.) Thus, the algorithm that is used to derive a ciphersuite tag will give equivalent outputs for isogenous curves in the case that the input to the algorithm is F, the field, and n, the order of the elliptic curve group. Here is a candidate such algorithm:\r\n\r\n```\r\nciphersuite_id(F, n, W, H)\r\n\r\nInputs:\r\n- F, a field (extension) parameterized by p and m, such that F = GF(p^m)\r\n- n, the cardinality of the group of rational points on E over F\r\n- W, the parameter from hash_to_base\r\n- H, the hash function from hash_to_base\r\n\r\nOutput: csid, a 4-byte ciphersuite ID string\r\n\r\nSteps:\r\n1.    L1 = ceiling(log_base_256(p))    // i.e., # of bytes necessary to represent p\r\n2.    L2 = ceiling(log_base_256(n))    // i.e., # of bytes necessary to represent n\r\n3.     L = max(L1, L2)\r\n4. L_str = I2OSP(L, 4)\r\n5. W_str = I2OSP(W, 4)\r\n6. m_str = I2OSP(m, 4)\r\n7. p_str = I2OSP(p, L)\r\n8. n_str = I2OSP(n, L)\r\n9. c_pre = H(L_str || W_str || m_str || p_str || n_str)\r\n10. return c_pre[0:4]                  // i.e., the first 4 bytes of c_pre\r\n```\r\n\r\nThis 4-byte tag would be used as described in option 2 in the 1st message of this thread:\r\n\r\n    m' = \"HASH-TO-CURVE\" || csid || H(msg) || I2OSP(ctr, 1)\r\n\r\nNote that for a given curve, csid is fixed for all time, so it can just be a hard-coded constant. There's no need to evaluate the ciphersuite_id function at runtime.\r\n\r\nTo be clear: I'm not sure yet whether I'm in favor of this or not. But at least this clears away some of the deployment / pragmatic concerns with using ciphersuites and lets us focus on whether or not this is desirable strictly from a security perspective.",
          "createdAt": "2019-06-30T21:35:11Z",
          "updatedAt": "2019-07-02T19:33:17Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "The above proposal, while perhaps an improvement, is by no means perfect. Here are some concerns that I can think of, off the top of my head:\r\n\r\n1. It doesn't give domain separation between a supersingular curve and its quadratic twist, because such curves have the same number of points. This isn't an issue with the algorithm as much as with the specification that isogenous curves should have the same ciphersuite ID: a supersingular curve is isogenous to its quadratic twist, so it has the same ciphersuite ID.\r\n   \r\n   So the question is, will the lack of domain separation between a supersingular curve and its twist have any practical effects on security? Right now the answer seems to be no, but Murphy is always lurking. Maybe adding some text warning about this case would be sufficient, if we took the decision to add separation as described above.\r\n\r\n2. Should the ciphersuite string comprehend elements of the ciphersuite beyond the curve? For example, the ciphersuite will specify whether and how to clear cofactors, and whether to use encode_to_curve (not a random oracle) or hash_to_curve (indifferentiable from random oracle). These aren't comprehended in the above proposal; is that OK?\r\n   \r\n   Unlike the case of hashing to both a curve and its twist (which may itself be implausible!), it seems really hard to imagine that one protocol would want two orthogonal hash functions to the same curve, where one hashes to the full curve and the other hashes to a prime-order subgroup. So maybe this isn't an issue. But it wouldn't be so hard to add a few more fields to `c_pre` if we wanted to comprehend these. Importantly, it seems possible to do this without breaking (say) curve25519/edwards25519 compatibility.\r\n\r\n3. Related to the above: it might be a misfeature right now that `hash_to_curve` invokes `hash_to_base` with `ctr = 0` and `ctr = 1`, rather than with `ctr = 1` and `ctr = 2`. The reason to prefer the latter case is that `encode_to_curve` invokes `hash_to_base` with `ctr = 0`, so using 1 and 2 ensures that `encode` and `hash` make orthogonal random-oracle queries, totally for free.\r\n   \r\n   Actually, probably a better alternative is to change the spec for `encode_to_curve` to use `ctr = 2`. This also gives orthogonality, but doesn't break compatibility with the current BLS signatures spec, which currently specifies indifferentiable hashing using `ctr = 0` and `ctr = 1` and already has some implementations.",
          "createdAt": "2019-06-30T21:54:47Z",
          "updatedAt": "2019-06-30T22:02:25Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "One more possibility related to domain separation that came up when chatting with @henrycg that I forgot to mention earlier today.\r\n\r\nLet's assume that we're not doing any kind of ciphersuite-specific domain separation. In that case, it might still make sense to inject a hash-to-curve--specific (but not ciphersuite-specific) string into the hash_to_base function, with the aim of orthogonalizing the invocations of `H` in hash_to_base from other invocations of the same hash function within a given higher-level protocol. Specifically, consider a protocol that's using SHA-256 as a random oracle both in hash_to_base and in some other subroutine unrelated to hash-to-curve.\r\n\r\nLike in the case a few comments above, protocol designers might reasonably expect that these random oracle invocations are orthogonal---and in all likelihood they are, considering the highly stylized H() invocations in hash_to_base. But adding an extra layer of protection is essentially free and might give a tiny bit of peace of mind. Concretely, I'm thinking something like this\r\n\r\n    m' = \"HASH-TO-CURVE\" || H(msg) || I2OSP(ctr, 1)\r\n\r\ninside hash_to_base.\r\n\r\nIn other words, there's a third option that sits in between \"no domain separation\" and \"per-ciphersuite domain separation,\" namely, adding a fixed string that's the same for all ciphersuites in hash_to_base. This ensures that invocations of H in hash-to-curve are orthogonal to other invocations of H.\r\n\r\nI think this is another instance in which an application-level ciphersuite string isn't enough. And it seems like not enforcing separation between calls to H() inside hash_to_base and calls to H() elsewhere in an upper-level protocol may really be inviting badness.",
          "createdAt": "2019-07-01T06:08:45Z",
          "updatedAt": "2019-07-02T02:42:50Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> ...uses points on both an elliptic curve and on its quadratic twist. Suppose that this hypothetical protocol relies on hashing to both the curve and its twist, and models these two hash functions as independent random oracles.\r\n> In this case, simply following the hash-to-curve document would _not_ yield independent random oracles. Since the curve and its twist by definition reside in the same base field, the hash_to_base function for both curves will make exactly the same calls to H (say, SHA256), and will return exactly the same value. Now it's not at all obvious that the two oracles are uncorrelated!\r\n\r\nIf I am not wrong, the curve and its twist have different curve equations, so how it is possible to get the same point since the elliptic curve coefficients play role in the mappings?\r\n\r\n",
          "createdAt": "2019-07-01T17:14:21Z",
          "updatedAt": "2019-07-01T17:14:21Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> If I am not wrong, the curve and its twist have different curve equations, so how it is possible to get the same point since the elliptic curve coefficients play role in the mappings?\r\n\r\nYou're right that the *mapping* will return a different point. I was pointing out that *hash_to_base* will return the same value for both curves when invoked on the same string, because hash_to_base only depends on F (which is definitely the same) and W and H (which are almost certainly the same).\r\n\r\nIf that happens, then the same `u` value is given as the input to two (presumably very similar) map_to_curve functions, one for the curve and one for the twist. As far as I can tell, there's no reason to believe that these two functions will give statistically uncorrelated results. Certainly they're not designed to, and as far as I know there's no analysis of such a situation in the literature.",
          "createdAt": "2019-07-01T17:36:56Z",
          "updatedAt": "2019-07-01T17:37:23Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Folks, I'd like to submit a PR on domain separation by EoD tomorrow, so I'd appreciate any last-minute thoughts on the above.\r\n\r\nHere's my concrete proposal:\r\n\r\n1. Change hash_to_base in the way proposed in [this comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/124#issuecomment-507128652), namely, add a fixed string to separate the use of H in hash_to_base from other uses of H in the invoking protocol.\r\n   \r\n   The justification for this change is effectively the principle of least surprise: hash-to-curve doesn't *look* like SHA-256, so it's kind of surprising for it to require domain separation from SHA-256. I'd guess that even with a stern warning in the document, many users will get this wrong---especially if they're just invoking a hash-to-curve implementation from a library rather than reading the document and implementing it themselves.\r\n\r\n2. Change to `ctr = 2` for `encode_to_curve`, as discussed in point (3) in [this comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/124#issuecomment-507070611). This is paranoia, but it's totally free, so we may as well do it.\r\n\r\nThis leaves us with the question of per-curve domain separation. Status quo appears to be that we will clearly state that this document does *not* guarantee domain separation between encodings to different curves. If a protocol invokes two different encodings and requires the results to be orthogonal, the protocol MUST inject its own domain separation tags.\r\n\r\nI have to admit, I don't love this solution. Adding a 4-byte, deterministically-generated domain separation tag via something like [`ciphersuite_id`](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/124#issuecomment-507069455) is cheap, and has none of the practical downsides we've discussed upthread. And once again appealing to the principle of least surprise, it just seems like intuitively, oracles to different curves should be uncorrelated.",
          "createdAt": "2019-07-02T03:46:44Z",
          "updatedAt": "2019-07-02T03:47:39Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "This is mostly a note-to-self: to avoid adding another compression function invocation in hash_to_base, we can have at most 23 bytes beyond H(msg) in m'. Right now we add 3, namely, ctr, i, and j. \"HASH-TO-CURVE\" is 13 bytes, so we could in principle have up to a 7-byte csid without spilling into another compression invocation.",
          "createdAt": "2019-07-02T03:50:50Z",
          "updatedAt": "2019-07-02T03:51:48Z"
        },
        {
          "author": "hoeteck",
          "authorAssociation": "NONE",
          "body": "\r\nIf I understand correctly, the latest issue with the curve and its twist goes away if we include the curve in the ciphersuite_id, and the high-level application calls hash_to_curve with the ciphersuite_id. Is that right?\r\n\r\nGoing back to the higher-level discussion, I don't think we should be trying to protect *protocol designers* from deviating from the recommendations of this draft; that incurs too much overhead and takes us down a deep rabbit hole.\r\n\r\nMore generally, we need to distinguish between implementation errors and design errors. I agree with the general principle of resilience to *implementation* errors (e.g. resilience to weak randomness and side channel attacks). On the other hand, I'm a lot less sympathetic to paying a price for resilience to *design* errors.\r\n\r\n\r\n\r\n",
          "createdAt": "2019-07-02T12:26:35Z",
          "updatedAt": "2019-07-02T12:26:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> If I understand correctly, the latest issue with the curve and its twist goes away if we include the curve in the ciphersuite_id, and the high-level application calls hash_to_curve with the ciphersuite_id. Is that right?\r\n\r\n@hoeteck more or less -- I assumed that the *implementation* of the specific cipher suite would just include ciphersuite_id, i.e., the caller would not pass anything beyond the message to hash.\r\n",
          "createdAt": "2019-07-02T16:05:23Z",
          "updatedAt": "2019-07-02T16:05:23Z"
        },
        {
          "author": "hoeteck",
          "authorAssociation": "NONE",
          "body": "How about the following as a compromise?\r\n\r\nhash-to-curve does incorporate a ciphersuite_id with an extra 8 (or 16) bits, which are zeroes by default, but can be changed by higher-level applications.\r\n\r\nIn particular, we can use\r\n\r\noption 2: fixed string + 4-byte ciphersuite in hash2base\r\nm' = H(ciphersuite || msg) || I2OSP(ctr, 1)\r\n\r\n// note I removed \"HASH-TO-CURVE\".\r\n\r\nbut the first 2 bytes of ciphersuite are always 0 by default (we can think of 0x00 as encoding the string \"HASH-TO-CURVE\"). Moreover, the hash-to-curve spec should explicitly allow higher-level applications to modify those 2 bytes.\r\n",
          "createdAt": "2019-07-02T17:07:36Z",
          "updatedAt": "2019-07-02T17:07:36Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> If I understand correctly, the latest issue with the curve and its twist goes away if we include the curve in the ciphersuite_id, and the high-level application calls hash_to_curve with the ciphersuite_id. Is that right?\r\n\r\nMaybe---it depends what you mean by *the* ciphersuite id. The issue is that a single, protocol-level ciphersuite ID isn't sufficient in this case---the protocol has to use a separate ID tag for each curve it hashes to, in order to ensure that those hashes are orthogonal.\r\n\r\nConcretely, imagine that a protocol implements two functions, hash_to_curve and hash_to_twist, and wants to be sure that they are orthogonal. Then the following is OK:\r\n\r\n    Pcurve = hash_to_curve(ciphersuite_id || \"CURVE\" || msg)\r\n    Ptwist = hash_to_twist(ciphersuite_id || \"TWIST\" || msg)\r\n\r\nbut this is not OK:\r\n\r\n    Pcurve = hash_to_curve(ciphersuite_id || msg)\r\n    Ptwist = hash_to_twist(ciphersuite_id || msg)\r\n\r\nTo me, that's a reasonably subtle distinction, and it seems like \"hash_to_curve\" and \"hash_to_twist\" should be doing that work, not their callers.\r\n\r\n---\r\n\r\nI completely agree that it's impossible to prevent people from misunderstanding or ignoring the recommendations. On the other hand, to me it makes sense to try to anticipate insidious misunderstandings and to make those misunderstandings *implementation errors* that can be caught in one place (with test vectors), rather than subtle bugs at individual call sites that may very well go unnoticed.\r\n\r\nI know I sound like a broken record, but the case of library users really worries me. Library users should not need to understand detailed security recommendations from the hash-to-curve document in order to safely invoke a hash-to-curve function that someone else wrote. Or, maybe more accurately: library users just *will not* read this document. To whatever extent is reasonable, complying implementations should protect them anyway.",
          "createdAt": "2019-07-02T17:09:00Z",
          "updatedAt": "2019-07-02T17:09:00Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> hash-to-curve does incorporate a ciphersuite_id with an extra 8 (or 16) bits, which are zeroes by default, but can be changed by higher-level applications.\r\n\r\nI think I'm not quite understanding your proposal:\r\n\r\n1. Doesn't the current interface already do this, since the caller is already welcome to prefix `msg` with arbitrary tags? In other words: is this any different? How?\r\n\r\n2. Why remove \"HASH-TO-CURVE\"?\r\n\r\n3. Are you proposing to change the API to something like hash_to_curve(msg, ciphersuite) ?\r\n\r\n4. Does this really improve the situation compared to the no-ciphersuite option? By default there's still no domain separation for SHA-256 inside hash_to_base, and random oracles to different curves are not orthogonal.",
          "createdAt": "2019-07-02T17:19:55Z",
          "updatedAt": "2019-07-02T17:19:55Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> On the other hand, I'm a lot less sympathetic to paying a price for resilience to _design_ errors.\r\n\r\nI realize that you don't mean a price in the literal sense, but to be clear: there is no computational overhead when adding a per-curve ciphersuite. hash_to_base invokes exactly the same number of rounds of SHA2 in either case.",
          "createdAt": "2019-07-02T17:23:20Z",
          "updatedAt": "2019-07-02T17:23:20Z"
        },
        {
          "author": "hoeteck",
          "authorAssociation": "NONE",
          "body": "There are a couple issues being discussed, but here, I'm focusing on the issue of option 1 vs option 2 at the beginning of this thread, in the context of BLS signatures. In BLS signatures, we want to support additional ciphersuite information beyond what's in hash-to-curve, let's suppose we only need a single byte (concretely, this byte would indicate different mechanisms for preventing rogue-key attacks, e.g. 0x01 for proof of possession and 0x02 for message augmentation).\r\n\r\nTo answer,\r\n\r\n> 1. ... the caller is already welcome to prefix msg with arbitrary tags?\r\n> In other words: is this any different? How?\r\n\r\nLet's suppose we go with option 2 with pre-hashed for free, namely:\r\n\r\n`m' = \"HASH-TO-CURVE\" || ciphersuite || H(msg) || I2OSP(ctr, 1)`\r\n\r\nLet's supposed we want to sign the message \"Hello\" using BLS signatures with option 0x01 over BLS12-381 curve. Looking up the current table, I'd use \"H2C-0008\". Now, what would m' be?\r\n\r\n* option H1. set msg in m' := 0x00 || \"Hello\" (What Riad referred to as prefix msg with arbitrary tag).\r\n\r\n     `m' = \"HASH-TO-CURVE\" || H2C-0008 || H(0x01 || \"Hello\") || I2OSP(ctr, 1)`\r\n\r\n* option H1b. The same thing, but with pre-hashed for free, namely:\r\n\r\n     `m' = \"HASH-TO-CURVE\" || H2C-0008 || H(0x01 || H(\"Hello\")) || I2OSP(ctr, 1)`\r\n\r\n* option H2. allow higher-level applications to modify first bytes of ciphersuite (as I suggested above). Then, in the pre-hashed for free setting, we get:\r\n\r\n     `m' = \"HASH-TO-CURVE\" || H2C-0108 || H(\"Hello\") || I2OSP(ctr, 1)`\r\n\r\nI see two advantages in option H2:\r\n\r\n* (concrete efficiency) comparing option H1b and H2, we save one hash.\r\n* (\"aesthetics\") all the ciphersuite information go into the same place, namely `H2C-0108`. This makes defining ciphersuite for higher-level applications much cleaner, namely\r\n\r\n    `higher-level specific options || hash-to-curve options`\r\n\r\nMore generally, we can have H2C-xxyyzz with 3 bytes, with xx defaulting to 00 and reserved for high-level applications.\r\n\r\n> 2. Why remove \"HASH-TO-CURVE\"?\r\n\r\nThis is mostly aesthetic, but if we include a string \"HASH-TO-CURVE\" in m', then we should also include \"BLS-SIGN\" in m', and I don't know a clean way to do in option 2. But let's put this aside for now.\r\n\r\nHope that clarifies things somewhat! :)\r\n",
          "createdAt": "2019-07-02T18:01:52Z",
          "updatedAt": "2019-07-02T18:01:52Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> * option H2. allow higher-level applications to modify first bytes of ciphersuite (as I suggested above). Then, in the pre-hashed for free setting, we get:\r\n>   `m' = \"HASH-TO-CURVE\" || H2C-0108 || H(\"Hello\") || I2OSP(ctr, 1)`\r\n\r\nI agree this is nice from a performance perspective, but in my mind it doesn't provide meaningful domain separation. This is related to pairingwg/bls_standard#17. The issue is that one byte is not sufficient to ensure that different protocols make distinct calls to the random oracle. Concretely, if protocols A and B both use a one-byte ciphersuite tag, there's a really good chance that both of them will compute exactly the same value for `m'`---especially if they just enumerate their ciphersuites starting from 0 the way BLS is currently doing.\r\n\r\nThis is exactly the situation we're trying to avoid with domain separation: the protocols need to somehow include a globally unique (we hope) string inside `m'`. This is why I'm strongly in favor of \"HASH-TO-CURVE\", \"BLS-SIGN\", \"RFC7748\", or whatever.\r\n\r\nI'm also not in favor of weakening the abstraction / complicating the interface between hash-to-curve and upper-level protocols. In my mind, the signature of the hash-to-curve functions should be\r\n\r\n    {0, 1}^* -> E\r\n\r\nAnd they should behave in a way that, to the greatest extent possible, aligns with intuition. For the purposes of this thread, from my perspective \"intuitive\" means that different hash functions are fully distinct from all other random oracles in a protocol. This is the best possible guarantee that hash-to-curve can give. That doesn't mean that higher-level protocols don't need to do domain separation among themselves! but it *does* mean that it's safe to treat conforming hash-to-curve implementations as a black box. In other words, of course hash-to-curve functions *can* be misused, but the simplest and most obvious way to use them is probably the right way, modulo responsibilities that only the upper-level protocol is in a position to discharge.\r\n\r\nAs far as performance goes, in my mind the calling protocol should *only* be passing tagged messages to *any* random oracle. This means that there really is no extra cost for computing\r\n\r\n    H(\"MY-PROTOCOL\" || 0x01 || original_message)\r\n\r\nbecause the upper-level protocol should *never* call `H(original_message)`, to a first approximation.\r\n\r\n---\r\n\r\nEDIT: this is sort of separate from the above, but I think it's pretty clear from the discussion upthread that fixing a table of ciphersuite IDs is a non-starter. So let's assume that we'd compute the ciphersuite ID using a deterministic algorithm. I've edited the first post in the thread to that effect.",
          "createdAt": "2019-07-02T19:01:33Z",
          "updatedAt": "2019-07-02T19:30:08Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "To add another perspective:\r\n\r\nI spoke with Dan (Boneh) about this today, and his take was that this is very application dependent, so it might be best to leave it to the applications to decide whether they want per-curve domain separation rather than arbitrarily decree that there shall be separation just between isogeny classes. So that's another vote against per-curve separation.\r\n\r\nDan *is* in favor of adding some fixed string to the H() calls inside hash_to_base, roughly as discussed [here](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/124#issuecomment-507128652). But he suggested that it is probably better to use HKDF than to \"roll our own\" PRG. Let's leave that to an orthogonal discussion---I've created #137.\r\n\r\n---\r\n\r\nSince it seems like there's little enthusiasm to go all-in on per-curve domain separation, I'm fine adding text that explicitly delegates this task to the upper-level protocols, at least for now. We can revisit this decision in the future if necessary, but I'd rather get *some* text about domain separation before the deadline, since that's probably the most effective way to solicit feedback from the broader community.",
          "createdAt": "2019-07-02T22:21:27Z",
          "updatedAt": "2019-07-02T22:21:53Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I created #139 capturing more or less what's here, tabling the question of per-curve domain separation for now since there seems to be little enthusiasm for it. Comments appreciated.",
          "createdAt": "2019-07-03T06:31:44Z",
          "updatedAt": "2019-07-03T06:31:44Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "We reached a consensus on domain separation, so I'm closing this issue.",
          "createdAt": "2019-10-27T06:07:26Z",
          "updatedAt": "2019-10-27T06:07:26Z"
        }
      ]
    },
    {
      "number": 126,
      "id": "MDU6SXNzdWU0NTU2NDYwMDc=",
      "title": "Scoping the definition of suites",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/126",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Let's explicitly enumerate the groups of interest for instantiating suites.\r\nPlease also consider the following points:\r\n   1) Which are the groups of interest?\r\n   2) Should we cover curves standardized by agencies different than NIST and IETF? \r\n   3) What is the criteria for not to include a specific curve?\r\n   4) Should we provide a way to generate extensible suites for addressing curves not considered in the doc?\r\n\r\nAnswering these questions will help us to have a clearer path for finishing the last part of the document.",
      "createdAt": "2019-06-13T09:55:38Z",
      "updatedAt": "2019-10-27T06:09:14Z",
      "closedAt": "2019-10-27T06:09:14Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "The list of curves I have written down are:\r\n\r\n- FIPS 186-4 curves: p256, p384, p521. Not p192 or p224, though: they're not used much, and we shouldn't encourage them to be.\r\n- RFC 7748: Curve25519, Curve448\r\n- RFC 8032: Ed25519, Ed448\r\n- Bitcoin et al: SECP256K1\r\n- Pairing-friendly curves: BLS12-381 for sure, since BLS signatures is going to use it. The [pairing-friendly curve draft](https://github.com/pairingwg/pfc_standard/) also mentions BN256 (100-bit security), BN462, and BLS48-581. Probably we should coordinate with them and make sure to cover the curves they standardize.\r\n- SIKEP503 - currently in poc code. What about [other post-quantum candidate curves](https://github.com/microsoft/PQCrypto-SIDH)?\r\n- SS132 - a supersingular curve apparently from RFC5091",
          "createdAt": "2019-06-13T18:14:19Z",
          "updatedAt": "2019-06-13T18:14:19Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Here is a larger list of curve (https://eprint.iacr.org/2015/1060.pdf)\r\n\r\nThe point for discussion that I want to raise is not whether we must encourage or not the use of CurveX instead of CurveY. \r\n\r\nMy point is that covering exhaustively all cases could not be possible since there are many curves and there will be more curves in the future. So, I think the document must provide a general guideline for an implementer using the brand-new CurveXYZ be able to instantiate a suite not deviating from the framework and algorithms we are proposing. And for the most popular curves (it could be the curves used for TLS) provide enumerated suites.\r\n\r\n\r\n",
          "createdAt": "2019-06-13T18:42:07Z",
          "updatedAt": "2019-06-13T18:42:07Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, I think I was unclear.\r\n\r\nI completely agreed that we can't cover all curves exhaustively, and that we should give people enough information to make good choices for curves that aren't covered.\r\n\r\nBut we can do this while also choosing suites that accomplish other useful goals. In particular, here's what I'd like to see:\r\n\r\n1. Every suite entry should have a corresponding \"straight-line implementation\" in the appendix of the document that uses every optimization we know.\r\n\r\n2. Because of (1), the suites should be chosen to cover curves that are standardized and in widespread use. It's good for the community if we spend the time thinking carefully about efficient implementations for widely-used curves and document the results. This is the reason I suggested the FIPS curves, '25519 and '448, and SECP256K1, and it's also also why I included the pairing-friendly curves: those curves and related applications are in the process of being standardized. TLS is a great suggestion, @armfazh; do you have specific suggestions other than the ones I listed above?\r\n\r\n3. Beyond the curves in (2), I think we should make sure that the defined suites include at least one curve for each map in the document. For this purpose it's OK to relax the \"widespread use\" requirement. The reason for this is, even if implementors don't use exactly the curve we give as an example, having a careful implementation of the map available, even for a different curve, will be helpful to implementors. This is why I included SIKE-P503 and SS-132: these are examples of \"Elligator A=0\" and \"Boneh-Franklin,\" respectively.\r\n\r\n> The point for discussion that I want to raise is not whether we must encourage or not the use of CurveX instead of CurveY.\r\n\r\nAh, but here's the thing: including any curve in the document *is* tacitly endorsing that curve for use, whether we want it to be or not. Because of this, we should be careful about which curves we suggest---hence my suggestion to leave out p192 and p224.\r\n\r\nAlso, related to using curves that aren't covered: as I said in #124, if we require including the hash-to-curve ciphersuite identifier for domain separation, we have to be *extra* careful to allow a path forward for curves we didn't cover. This is quickly becoming my biggest concern with the ciphersuite/domain separation issue.",
          "createdAt": "2019-06-13T22:24:53Z",
          "updatedAt": "2019-06-13T22:24:53Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Per @chris-wood's [comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/121#discussion_r290771878), we should decide whether or not to add non-RO suites. (Probably yes...)",
          "createdAt": "2019-06-17T22:36:44Z",
          "updatedAt": "2019-06-17T22:36:44Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks like we've got a good handle on suites at this point, so I'm closing this issue.\r\n\r\nIf anyone wants to add a new curve to suites, they can open a separate issue or PR.",
          "createdAt": "2019-10-27T06:09:14Z",
          "updatedAt": "2019-10-27T06:09:14Z"
        }
      ]
    },
    {
      "number": 128,
      "id": "MDU6SXNzdWU0NTk1ODAyMTQ=",
      "title": "map2curve / appendix : more detailed discussion",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/128",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the discussion of #127, @samscott89 [suggested](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/127#discussion_r296278246) a more in-depth discussion of some properties of the map2curve functions: injectivity, invertibility, well-distributedness, etc.\r\n\r\nI agree with the above-linked comment that it could be useful for future documents to refer to a nice summary of these properties. On the other hand, since they're a bit lower level than what's necessary for the purpose of standardizing (implementations of) hashes to curves, and in particular since they're not likely to be of interest to implementors in most cases, it seems like this might be a good candidate for an appendix that briefly summarizes the relevant properties and cites the appropriate primary sources (FFSTV13, for example).\r\n\r\nI think there are some other issues that need to be addressed first, so I'm stashing an issue and we can revisit in the future.",
      "createdAt": "2019-06-23T14:08:47Z",
      "updatedAt": "2019-06-26T17:04:04Z",
      "closedAt": "2019-06-26T17:04:04Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "I think a sentence/comment might well suffice in this case. It's just that this document might end up having a better description of map2curve functions than exist elsewhere. So perhaps worth keeping a few pertinent pieces of information in there, without letting this doc expand into a elliptic curve encyclopedia.",
          "createdAt": "2019-06-24T00:48:40Z",
          "updatedAt": "2019-06-24T00:48:40Z"
        }
      ]
    },
    {
      "number": 129,
      "id": "MDU6SXNzdWU0NjA0OTkxOTg=",
      "title": "meta-issue: triage for July 8th draft update",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/129",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The deadline for getting drafts updated before IETF 105 is [July 8th](https://datatracker.ietf.org/meeting/105/important-dates/). This is an attempt at triaging the open issues and known TODOs to hit that date.\r\n\r\nPlease let me know if anything seems to be miscategorized!\r\n\r\n## Really should have\r\n\r\n- [x] Definitions: maps, encodings, etc. (#127, #128) - making sure that the definitions and high-level framing are clear is important for getting useful feedback on the next draft. Plus, these should be very close to converging!\r\n\r\n- [x] Fix point conversions for Edwards -> Montgomery to agree with existing RFCs (#107) - see second comment in linked issue. VRF won't reference us until this is fixed. #132 handles this.\r\n\r\n- [x] Update list of suites / decide on suite scope (#96, #126) - my hope is that we can take an initial cut at this and then solicit feedback.\r\n\r\n- [x] Cofactor clearing (#95) - @chris-wood and I discussed including \"cofactor clearing value\" in the suites table. For curves that have optimized cofactor clearing (generally, pairing-friendly curves), this is sufficient to make sure that people who don't implement the optimization can still output the correct point via scalar multiplication. Adding a column in the suites table addresses this.\r\n\r\n## Nice to have\r\n\r\n- [ ] Submit PR to VRF folks to refer to this draft rather than describing its own version of hash-to-curve - not sure if we can coordinate this in time, but we should try!\r\n   \r\n   (EDIT: I'm in a conversation with the VRF folks about this. Looks like we won't make it before July 8th, but that's fine---we'll make it happen as we can.)\r\n\r\n- [ ] Projective coordinates / optimized implementations (#4, #43, #109, #111, #117) - once we have an updated list of suites, we should put optimized impls in the appx.\r\n\r\n- [x] Domain separation (#124) - the discussion in the issue seems at this point to have identified the main pros and cons, so it seems like we should open this up for discussion on-list or at the meeting. We might not get this feedback in time, but we should try.\r\n   \r\n   (EDIT: marked this completed because #139 landed. Not sure if that means we can close #124, though.)\r\n\r\n## Not a blocker\r\n\r\n- [ ] Flow chart (#63, #118) - these will be very useful, but (as far as I know) we can't include non-ASCII diagrams in the draft, so it probably doesn't make sense to spend too much time on these before the deadline.\r\n\r\n- [ ] Code quality (#98, #112) - reference code isn't gated by the draft process, so we can de-prioritize.\r\n\r\n- [ ] style nits (#105, #110) - would be great to cover these, but not a killer if we don't.",
      "createdAt": "2019-06-25T15:38:36Z",
      "updatedAt": "2019-08-13T16:03:40Z",
      "closedAt": "2019-08-13T16:03:40Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "On the topic of compatibility with the [VRF draft](https://tools.ietf.org/html/draft-irtf-cfrg-vrf-04):\r\n\r\nmap_to_curve_elligator2 is compatible with what's described in steps 8-12 of section 5.4.1.2, other than the sign of the point (which they appear to always set to the positive value after converting to Edwards form). Also, the way they convert from a Montgomery to an Elligator point is exactly the way that is described in RFC7748.\r\n\r\nSo they can't just say \"use encode_to_curve\" in the VRF document, since they way they hash to the input `u` to map_to_curve_elligator2 is not the same as hash_to_base, but they can simplify their text a good deal.\r\n\r\nI'll ping the VRF authors this evening.",
          "createdAt": "2019-06-28T23:04:03Z",
          "updatedAt": "2019-06-28T23:05:27Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam I marked the second big ticket item resolved.",
          "createdAt": "2019-07-02T16:02:18Z",
          "updatedAt": "2019-07-02T16:02:29Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I sent an email to the VRF folks late last week, but haven't heard back yet. I'm going to prioritize suites list and domain separation since it's not clear that we could get a PR into the VRF draft before the deadline. Does this sound OK @chris-wood ?",
          "createdAt": "2019-07-02T21:07:13Z",
          "updatedAt": "2019-07-02T21:09:28Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "If you're open to it, could I take the suites one and you work on the optimized implementation task? ",
          "createdAt": "2019-07-02T21:45:35Z",
          "updatedAt": "2019-07-02T21:45:35Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I've got some reasonable progress locally on the suites; probably I could push something in the next few hours. But I'm happy to hand it off and switch to the impls if you'd prefer.",
          "createdAt": "2019-07-02T21:52:37Z",
          "updatedAt": "2019-07-02T21:52:37Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam Ah, then never mind! Please proceed as planned.",
          "createdAt": "2019-07-02T21:53:07Z",
          "updatedAt": "2019-07-02T21:53:07Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I recommend you make a push with the first suite you have, then we discuss about format, and once everything was agreed, we can continue adding suites.",
          "createdAt": "2019-07-02T21:56:26Z",
          "updatedAt": "2019-07-02T21:56:26Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Good idea @armfazh. I'll push a preliminary cut soon.",
          "createdAt": "2019-07-02T22:23:23Z",
          "updatedAt": "2019-07-02T22:23:23Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "#138 is ciphersuites WIP. I've got the parameters mostly written down for these suites, so I'll get that info into the document in the next few commits, but you can start taking a look in the meantime.",
          "createdAt": "2019-07-03T00:23:49Z",
          "updatedAt": "2019-07-03T00:24:01Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this issue, because we've either handled the issues pointed to here or we've got other issues that capture them",
          "createdAt": "2019-08-13T16:03:40Z",
          "updatedAt": "2019-08-13T16:03:40Z"
        }
      ]
    },
    {
      "number": 133,
      "id": "MDU6SXNzdWU0NjE2MDQ3NTg=",
      "title": "Investigate Elligator2 implementation speedup",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/133",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From Bj\u00f6rn Haase on the list:\r\n\r\n> Regarding the Elligator 2 map, the algorithm shown in the  github version of the draft is actually slower than necessary. It requires two exponentiations (for one inverse and one square root).\r\n>\r\n> Some time ago Mike Hamburg did point me to a solution on how to implement this with one single exponentiation. The algorithm is found also somewhere hidden within the Ed25519 paper of Bernstein, Duif, Lange, Schwabe and Yang. Still Beno\u00eet and me did consider it helpful to write down the faster algorithm explicitly in our last paper, because we thought that there might be others that missed this optimization opportunity :-).\r\n>\r\n> You'll find the explicit write-down in section 8.2 on page 33 of\r\n>\r\n> https://tches.iacr.org/index.php/TCHES/article/view/7384\r\n",
      "createdAt": "2019-06-27T15:41:59Z",
      "updatedAt": "2019-07-08T23:30:52Z",
      "closedAt": "2019-07-08T23:30:52Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": ":+1: this is an optimization I was planning to use heavily in the curve-specific versions---and not just for curve25519---but it's good to keep this as a reminder.\r\n\r\nA slightly unfortunate issue with this optimization is that it's only a savings if the map outputs a point in projective coordinates. Otherwise, you just trade one division for another: you can skip the division when computing sqrt(g(x)) with this trick, but then you still end up with x expressed as a fraction.\r\n\r\nFor the curve-specific implementations, we discussed making explicit that returning a projective point is cheaper. This at least gives implementors some breadcrumbs for curves that don't have example code.\r\n\r\nThe best would be if we could show optimizations like this for the generic implementations, but unfortunately all of these tricks rely on the form of p, or at least *knowing* whether p is (say) 3 mod 4 or 5 mod 8 or 9 mod 16. So probably it will have to be relegated to the curve-specific implementations.",
          "createdAt": "2019-06-27T19:58:48Z",
          "updatedAt": "2019-06-27T20:00:08Z"
        }
      ]
    },
    {
      "number": 134,
      "id": "MDU6SXNzdWU0NjIyMzMwNTM=",
      "title": "clarify Montgomery forms in {{elligator2}}",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/134",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The classic definition of the Montgomery form is\r\n\r\n    B * y^2 = x^3 + A * x^2 + x\r\n\r\nwhereas the Elligator paper works in the following slightly different form\r\n\r\n    y'^2 = x'^3 + A' * x'^2 + B' * x'\r\n\r\n#132 shows how to convert between these forms in the new appendix via a change of variables.\r\n\r\nIt might make sense to ref this change of variables from the {{elligator2}} section; otherwise, it could end up confusing people who intend to hit one form and accidentally hit the other.\r\n\r\n(Fortunately, both curve25519 and curve448 have B = 1, which means the two forms are equivalent!)",
      "createdAt": "2019-06-28T22:55:08Z",
      "updatedAt": "2019-11-09T00:21:07Z",
      "closedAt": "2019-07-02T16:01:36Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "To avoid confusion, one can call this equation a Weierstrass curve.\r\n```\r\ny'^2 = x'^3 + A' * x'^2 + B' * x'\r\n```\r\n\r\n",
          "createdAt": "2019-06-28T23:27:17Z",
          "updatedAt": "2019-06-28T23:27:17Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "(SAGE) I wrote the birational maps between Montgomery and Twisted Edwards curves.\r\n\r\n```python\r\nRE.<x,y,a,d> = QQ[]\r\nE = a*x**2+y**2 - ( 1 + d*x**2*y**2 )\r\nFE = Frac(RE.quotient_ring(E))\r\n\r\nRM.<u,v,A,B> = QQ[]\r\nM = B*v**2 - (u**3+A*u**2+u )\r\nFM = Frac(RM.quotient_ring(M))\r\n\r\nRW.<s,t,C,D> = QQ[]\r\nW = t**2 - (s**3+C*s**2+D*s )\r\nFW = Frac(RW.quotient_ring(W))\r\n\r\nE_to_M = E.subs(x=(u/v),y=(u-1)/(u+1),a=(A+2)/B,d=(A-2)/B)\r\nM_to_E = M.subs(u=(1+y)/(1-y),v=(1+y)/(x*(1-y)),A=2*(a+d)/(a-d),B=4/(a-d))\r\n\r\nassert FM( E_to_M ) == 0, \"do not match E -> M \" \r\nassert FE( M_to_E ) == 0, \"do not match M -> E \" \r\n\r\nW_to_E = W.subs(s=(1+y)/((4/(a-d))*(1-y)),t=(1+y)/((4/(a-d))*x*(1-y)),C=(a+d)/2,D=(a-d)**2/16)\r\nassert FE( W_to_E ) == 0, \"do not match W -> E \"\r\n\r\n```\r\nThe last one is the map from Weierstrass to Twisted Edwards curve, but I didn't have the map from E -> W. @kwantam do you have the explicit substitutions for the latter map?\r\n\r\n\r\n",
          "createdAt": "2019-06-28T23:31:38Z",
          "updatedAt": "2019-06-28T23:31:52Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> To avoid confusion, one can call this equation a Weierstrass curve.\r\n> \r\n> ```\r\n> y'^2 = x'^3 + A' * x'^2 + B' * x'\r\n> ```\r\n\r\nThis is a good point. Probably that means we have to move the change-of-variables from the appendix to {{montgomery}}, but that's easy enough. I'll look at doing it in another commit on #132.",
          "createdAt": "2019-06-29T01:31:12Z",
          "updatedAt": "2019-06-29T01:31:12Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> The last one is the map from Weierstrass to Twisted Edwards curve, but I didn't have the map from E -> W. @kwantam do you have the explicit substitutions for the latter map?\r\n\r\nSure. I think the missing trick is that `D` has to be square, so we have to specify W in terms of `sqrtD**2` rather than `D`:\r\n\r\n```python\r\nRE.<x,y,a,d> = QQ[]\r\nE = a*x**2+y**2 - ( 1 + d*x**2*y**2 )\r\nFE = Frac(RE.quotient_ring(E))\r\n\r\nRM.<u,v,A,B> = QQ[]\r\nM = B*v**2 - (u**3+A*u**2+u )\r\nFM = Frac(RM.quotient_ring(M))\r\n\r\nRW.<s,t,C,sqrtD> = QQ[]\r\nW = t**2 - (s**3+C*s**2+sqrtD**2*s )\r\nFW = Frac(RW.quotient_ring(W))\r\n\r\nE_to_M = E.subs(x=(u/v),y=(u-1)/(u+1),a=(A+2)/B,d=(A-2)/B)\r\nM_to_E = M.subs(u=(1+y)/(1-y),v=(1+y)/(x*(1-y)),A=2*(a+d)/(a-d),B=4/(a-d))\r\n\r\nassert FM( E_to_M ) == 0, \"do not match E -> M \"\r\nassert FE( M_to_E ) == 0, \"do not match M -> E \"\r\n\r\nW_to_E = W.subs(s=(1+y)/((4/(a-d))*(1-y)),t=(1+y)/((4/(a-d))*x*(1-y)),C=(a+d)/2,sqrtD=(a-d)/4)\r\nE_to_W = E.subs(x=s/t,y=(s/sqrtD-1)/(s/sqrtD+1),a=C+2*sqrtD,d=C-2*sqrtD)\r\n\r\nassert FE( W_to_E ) == 0, \"do not match W -> E \"\r\nassert FW( E_to_W ) == 0, \"do not match E -> W \"\r\n```",
          "createdAt": "2019-06-29T02:10:04Z",
          "updatedAt": "2019-06-29T02:10:33Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Link to the snippet: https://gist.github.com/armfazh/ab759968419e95fb5680b4a0dd046a6d",
          "createdAt": "2019-11-09T00:21:07Z",
          "updatedAt": "2019-11-09T00:21:07Z"
        }
      ]
    },
    {
      "number": 135,
      "id": "MDU6SXNzdWU0NjMxNzkxMzU=",
      "title": "integer power",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/135",
      "state": "CLOSED",
      "author": "vadym-f",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Field calculation \\pmod{p} at steps 15,16 of Icart method (lines 311,312)\r\nused later as a power at step 17\r\nmight be a copy-paste\r\nthat should be calculation over integers instead.",
      "createdAt": "2019-07-02T11:38:38Z",
      "updatedAt": "2019-07-07T06:38:26Z",
      "closedAt": "2019-07-07T06:38:26Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for reporting this.\r\n\r\nI'm not sure that I'm seeing exactly the issue you're referring to. Can you please let me know if #145 addresses this issue?\r\n\r\nIf not, can you please let me know which version of the document you're referring to in your comment?\r\n\r\nThanks again!",
          "createdAt": "2019-07-07T05:36:00Z",
          "updatedAt": "2019-07-07T05:36:00Z"
        },
        {
          "author": "vadym-f",
          "authorAssociation": "NONE",
          "body": "Thank you Riad for your time pushing this into an agreed-on standard text,\r\nfor recent IACR preprint, and proof system.\r\n\r\nYes, #145 fixes formal nuisance with explicit excessive (mod p) in the\r\ntext, including the power.\r\nIt looks very clear for me now.\r\nI was looking into -00 version, which seems somewhat outdated.\r\n\r\nOn Sun, Jul 7, 2019 at 8:36 AM Riad S. Wahby <notifications@github.com>\r\nwrote:\r\n\r\n> Thanks for reporting this.\r\n>\r\n> I'm not sure that I'm seeing exactly the issue you're referring to. Can\r\n> you please let me know if #145\r\n> <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/145>\r\n> addresses this issue?\r\n>\r\n> If not, can you please let me know which version of the document you're\r\n> referring to in your comment?\r\n>\r\n> Thanks again!\r\n>\r\n> \u2014\r\n> You are receiving this because you authored the thread.\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/135?email_source=notifications&email_token=AJ273N2TZVHHWN7FPENLPATP6F6EDA5CNFSM4H423722YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODZLE6PQ#issuecomment-508972862>,\r\n> or mute the thread\r\n> <https://github.com/notifications/unsubscribe-auth/AJ273N6XXUGYUINLHSEQECTP6F6EDANCNFSM4H42372Q>\r\n> .\r\n>\r\n",
          "createdAt": "2019-07-07T06:27:42Z",
          "updatedAt": "2019-07-07T06:36:44Z"
        }
      ]
    },
    {
      "number": 137,
      "id": "MDU6SXNzdWU0NjM0NjEwNDA=",
      "title": "HKDF in place of ad-hoc PRG currently used by hash_to_base?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/137",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Dan Boneh points out that there's little reason to roll our own PRG inside hash_to_base. Instead, he suggests using [HKDF](https://tools.ietf.org/html/rfc5869).\r\n\r\n(I have to admit, I'm slightly annoyed at myself for having failed to consider this option. Sorry, folks.)\r\n\r\nWhile this makes hash_to_base slightly more expensive, the difference in cost is negligible compared to the end-to-end cost of hashing to a curve.\r\n\r\nThe main issues I see with taking this approach are:\r\n\r\n- is there a way to get \"prehash for free\" as in the current approach?\r\n- is there a compatibility story for the BLS signatures standard?\r\n\r\n@hoeteck, thoughts on how this might play out with BLS? I can imagine there isn't a huge appetite for this change. On the other hand, I wonder if we can really justify using a hash_to_base function that lacks rigorous analysis when the (arguably) \"right thing\" is kind of well known?",
      "createdAt": "2019-07-02T22:20:40Z",
      "updatedAt": "2019-07-06T18:21:51Z",
      "closedAt": "2019-07-06T18:21:51Z",
      "comments": [
        {
          "author": "hoeteck",
          "authorAssociation": "NONE",
          "body": "\r\nUsing HKDF is a great idea, indeed! It's also used in TLS 1.3.\r\n\r\nHKDF-Expand also takes as input a context/info, and ciphersuite/domain separation info would fit in naturally over there.\r\n\r\n> thoughts on how this might play out with BLS?\r\n\r\nCome to think about it, we should probably use HKDF for key generation in BLS signatures, since it also takes into account weak randomness used for key generation.\r\n\r\n> I have to admit, I'm slightly annoyed at myself for having failed to consider this option. \r\n\r\nYou're doing great! Don't be so harsh on yourself :)",
          "createdAt": "2019-07-02T22:44:07Z",
          "updatedAt": "2019-07-02T22:44:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Using HKDF is a great idea, indeed! It's also used in TLS 1.3.\r\n\r\n+1!\r\n\r\n> You're doing great! Don't be so harsh on yourself :)\r\n\r\nHeavy +1.",
          "createdAt": "2019-07-03T20:55:43Z",
          "updatedAt": "2019-07-03T20:55:43Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by #141",
          "createdAt": "2019-07-06T18:21:49Z",
          "updatedAt": "2019-07-06T18:21:49Z"
        }
      ]
    },
    {
      "number": 140,
      "id": "MDU6SXNzdWU0NjM3Mjk5NTE=",
      "title": "Future-proofing ciphersuite labels",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/140",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This seems like a low-priority issue, but wanted to get the thoughts down\r\nfor future discussion:\r\n\r\nLooking ahead to where we will realistically fall on ciphersuite definitions,\r\nit is unlikely that aspects such as specific constants (e.g. quadratic non-residues),\r\nand even the scalar used for cofactor clearing (in the case of optimised\r\nimplementations) will be explicit in the ciphersuite **label**, despite\r\nbeing explicit in the definition itself.\r\n\r\nIn the future, there is a chance that different choices will be desired, \r\nfor example, due to new algorithmic improvements. Changing these requires\r\na new ciphersuite tag, else implementations may become incompatible.\r\n\r\nThis leaves open the question of versioning the ciphersuites themselves,\r\nsince we may want a \"v2\" of a ciphersuite.\r\n\r\nHowever, this possibility seems low enough probability that forcing a \"v1\"\r\nsuffix onto all existing ciphersuites seems unnecessary.\r\nOne solution seems to be considering future extensions to the draft to\r\nallow changing \"curvexxx-hashyyy-mapzzz-ro\" to simply \"curvexxx-hashyyy-mapzzz-ro-v2\"\r\nin such an scenario.\r\n",
      "createdAt": "2019-07-03T12:40:53Z",
      "updatedAt": "2019-08-13T15:42:01Z",
      "closedAt": "2019-08-13T15:42:01Z",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "I should add: this specific issue is orthogonal to the issue of maintaining a registry/adding new curves/maps.",
          "createdAt": "2019-07-03T12:41:49Z",
          "updatedAt": "2019-07-03T12:41:49Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> However, this possibility seems low enough probability that forcing a \"v1\"\r\n> suffix onto all existing ciphersuites seems unnecessary.\r\n\r\nAgreed.\r\n\r\n> One solution seems to be considering future extensions to the draft to\r\n> allow changing \"curvexxx-hashyyy-mapzzz-ro\" to simply \"curvexxx-hashyyy-mapzzz-ro-v2\"\r\n> in such an scenario.\r\n\r\nI think the current text in {{suites}} allows this: it doesn't require that the suite *ends* with (say) \"-RO\", just *contains* it. So appending a \"-V2\" to a suite ID yields a valid suite ID.\r\n\r\nOr: am I misunderstanding what you're suggesting? (If so, apologies!)",
          "createdAt": "2019-07-05T00:04:22Z",
          "updatedAt": "2019-07-05T00:04:22Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "No, that's exactly right. Opening this is sort of a sanity check for \"we shouldn't need to do anything about this, and the obvious approach works, right?\". For example, this might become relevant if we were to try and enforce something like all tags are precisely 32 bytes.",
          "createdAt": "2019-07-05T18:34:38Z",
          "updatedAt": "2019-07-05T18:34:38Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "See [this comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/161#issuecomment-517732622) (stashing this here because I'm trying to close #161 now)",
          "createdAt": "2019-08-09T00:28:47Z",
          "updatedAt": "2019-08-09T00:29:04Z"
        }
      ]
    },
    {
      "number": 144,
      "id": "MDU6SXNzdWU0NjQ4ODI4NzI=",
      "title": "possible enhancement: simplify sgn0",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/144",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There's a potential enhancement/improvement to sgn0 that we might want to consider. This option may have been discussed a little before, but it's probably worth revisiting before things get too ossified.\r\n\r\nThe current version of sgn0 says that an element x in GF(p) is negative just when it is greater than (p - 1) / 2. (Things are slightly more complicated for GF(p^m), but let's ignore that for now.)\r\n\r\nSince p is odd, an alternative means of differentiating between x and -x is via the least significant bit: if the least significant bit of x is set, call x negative, otherwise call it positive. (This works because p - x and x have opposite LSBs, except when x = 0.)\r\n\r\nThe major advantage to this approach is that it's much easier to check a single bit in constant time than it is to compare a value to (p-1)/2. On the other hand, I'd guess that in many cases a constant-time comparison function is already available, so maybe this isn't such a decisive advantage after all.\r\n\r\nThe major disadvantage (if it can be called that) is that it leads to slightly nonintuitive definitions of \"negative.\" For example, normally we'd think of 1 as positive, but by the parity definition, sgn0(1) == -1, and sgn0(p - 1) == 1. But maybe that's OK.\r\n\r\nThoughts?\r\n\r\nSince this would be a breaking change, sooner is better than later. Also, it might change the suites definitions, since some suites have a constant Z that is \"smallest in absolute value, breaking ties by choosing the positive one,\" and changing the definition of sign might change that.",
      "createdAt": "2019-07-06T19:16:39Z",
      "updatedAt": "2019-10-30T16:30:13Z",
      "closedAt": "2019-10-30T16:30:13Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "From the implementation side, field arithmetic usually is implemented using redundant representations, in some cases, lazy-reduction (modulo a multiple of a prime) are used too.\r\n\r\nIn both cases, comparison or parity require a conversion from the internal representation to recover its unique representation 0<= x < p, and thus to determine x > p/2 or x mod 2.\r\nIn summary, from the implementation side (when using redundant representations) both operations are annoying. \r\n\r\nEven though checking parity is simpler, I consider that x > (p-1)/2 is well understood and does not present odd semantic cases (as the ones you mentioned above).\r\n",
          "createdAt": "2019-07-30T01:32:47Z",
          "updatedAt": "2019-07-30T01:32:47Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, your point about redundant representations is a good one.\r\n\r\nEven if not using redundant representations, Montgomery arithmetic will require a multiplication before doing either comparison or LSB check---so performance-wise, probably no change, just as you say.",
          "createdAt": "2019-07-30T01:38:49Z",
          "updatedAt": "2019-07-30T01:38:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "From an offline exchange, we might also specify `sgn0` per suite.",
          "createdAt": "2019-08-19T20:32:02Z",
          "updatedAt": "2019-08-19T20:32:02Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood, I spoke with @reyzin about this and I think your suggestion is a good one. I'll put together a PR that defines the two or three standard sgn0 variants and then sets the variant per-suite.\r\n\r\nI'm not fully sold on this since it increases the complexity of the document a bit, but let's take a look.",
          "createdAt": "2019-10-13T05:22:10Z",
          "updatedAt": "2019-10-13T05:22:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good!",
          "createdAt": "2019-10-13T21:11:46Z",
          "updatedAt": "2019-10-13T21:11:46Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I looked at IEEE 1363a-2004 and it looks like we can cover that serialization format, the BLS12-381ish format, and the Ed25519ish format with just two sgn0 variants. I'm working on a [branch](https://github.com/kwantam/draft-irtf-cfrg-hash-to-curve/tree/sqrt_sgn0_variants) that breaks these out. I still need to do some work to figure out who's actually implementing which serialization method for each curve, though.\r\n\r\n@chris-wood do you happen to know where the elliptic curve point serialization format in TLS comes from? That is, is it defined globally or per curve? I'll happily go dig through the RFC and impls, I'm just wondering if you remember off the top of your head.",
          "createdAt": "2019-10-14T04:16:04Z",
          "updatedAt": "2019-10-14T04:16:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> is it defined globally or per curve?\r\n\r\nPer-curve, but there's an [extension that lets endpoints specify the format](https://tools.ietf.org/html/rfc4492#section-5.1.2), too. (Uncompressed is the default for older curves. Curve25519 and newer curves specify the format as part of the group.)",
          "createdAt": "2019-10-14T14:15:38Z",
          "updatedAt": "2019-10-14T14:18:15Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Got it---thanks!\r\n\r\nIt looks like essentially everyone except the pairing-friendly curves is using X9.62 (aka SEC1) point compression. This makes life relatively easy.",
          "createdAt": "2019-10-16T21:27:39Z",
          "updatedAt": "2019-10-16T21:27:39Z"
        }
      ]
    },
    {
      "number": 151,
      "id": "MDU6SXNzdWU0NjU0OTQyMTY=",
      "title": "add README in poc that gives correspondence between code and sections of the document",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/151",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "It should be warned somewhere in the main doc which sage scripts correspond to the version we will submit.\r\n\r\n_Originally posted by @armfazh in https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/146#issuecomment-509419284_",
      "createdAt": "2019-07-08T22:56:43Z",
      "updatedAt": "2019-11-17T03:35:06Z",
      "closedAt": "2019-11-17T03:35:06Z",
      "comments": []
    },
    {
      "number": 153,
      "id": "MDU6SXNzdWU0NjU2NzE0NjA=",
      "title": "Add section on try and increment",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/153",
      "state": "CLOSED",
      "author": "JustinDrake",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The current draft does not mention the \"naive\" try and increment. I feel implementers will undoubtedly want to consider it. If the intent is to discourage the use of try and increment a section explaining why it is discouraged may be warranted. If it is not discouraged then a section standardising it may also be warranted. ",
      "createdAt": "2019-07-09T09:26:09Z",
      "updatedAt": "2019-07-10T21:51:33Z",
      "closedAt": "2019-07-10T21:43:30Z",
      "comments": [
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "I think try and increment is dead based on https://github.com/zkcrypto/pairing/issues/56#issuecomment-501942010 ",
          "createdAt": "2019-07-10T06:46:58Z",
          "updatedAt": "2019-07-10T06:46:58Z"
        },
        {
          "author": "JustinDrake",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Try and increment has the advantage of being trivial to specify (though not implement optimally). It is also likely used in production today. Even if \"dead\", an explanatory death note is probably warranted.",
          "createdAt": "2019-07-10T09:48:35Z",
          "updatedAt": "2019-07-10T09:48:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We decided to omit a complete specification of try-and-increment since we're aiming for constant-time algorithms. ",
          "createdAt": "2019-07-10T21:43:30Z",
          "updatedAt": "2019-07-10T21:43:30Z"
        },
        {
          "author": "JustinDrake",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> We decided to omit a complete specification of try-and-increment\r\n\r\nI'm not asking for a specification of try-and-increment. I'm asking for a rationale for *not* specifying try-and-increment.",
          "createdAt": "2019-07-10T21:51:33Z",
          "updatedAt": "2019-07-10T21:51:33Z"
        }
      ]
    },
    {
      "number": 155,
      "id": "MDU6SXNzdWU0Njg4MTU0MTU=",
      "title": "cover S--vdW at least for j=0 and j=1728 cases",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/155",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In [this post](https://mailarchive.ietf.org/arch/msg/cfrg/gFn3tvf62e1FKx_SkVXk8hsSVig), Dan Harkins points out (in essence) that the draft isn't clear on how to apply S--vdW to the case where j-invariant is 1728.\r\n\r\nIt would be nice to make S--vdW clear on this point, since it's effectively the \"method of last resort\": it will always work, even when some other method won't.",
      "createdAt": "2019-07-16T19:04:38Z",
      "updatedAt": "2019-10-26T19:16:28Z",
      "closedAt": "2019-10-26T19:16:28Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "See [this document](https://github.com/kwantam/draft-irtf-cfrg-hash-to-curve/raw/generalized_svdw/svdw_general.pdf) for proposed parameterization of S--vdW that can be easily (well, in a relative sense) applied to any curve.",
          "createdAt": "2019-08-02T14:51:43Z",
          "updatedAt": "2019-08-02T14:51:43Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I pushed #167 following both Fouque-Tibouchi (FT) and Riad's approaches to derive explicit formulas for S-vdW.  PDF file: ([math/sw.pdf](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/blob/a0c68c9c78e67d5019e7aa3659e5a9f0af2ba29a/math/sw.pdf)) with the derivation. \r\n\r\nThe formulas works for any A,B provided there exist a parameter u that holds certain conditions.\r\n\r\nDeriving formulas as FT has the advantage that the image size was already bounded, and it was also proved that such a mapping is admissible, which helps to get indifferentiability.\r\nExample: when E is a BN curve and u=1, it reduces to FT formulas from Latincrypt'12.\r\n\r\n",
          "createdAt": "2019-09-19T00:42:49Z",
          "updatedAt": "2019-09-19T00:48:30Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Wait, so: does the document cover the FT formula or the alternate derivation that I proposed? Or are you saying it somehow covers both? (if so, that seems unnecessary...)\r\n\r\nTo be clear: SvdW06 gives a lower bound on image size for any instantiation of their map, which is sufficient for admissability, so FT12 doesn't have any advantage in this regard as far as I can tell.\r\n\r\nOn the other hand (as I'm sure you know) the FT12 formula does not work when a = 0 and p != 1 mod 3, which is what motivated the alternate derivation.\r\n\r\nIn any case, my vote is for the simplest possible description of SvdW.\r\n\r\n(I don't have cycles this week, but next week I will have time to take a careful look at #167)",
          "createdAt": "2019-09-19T01:25:17Z",
          "updatedAt": "2019-10-10T04:28:34Z"
        }
      ]
    },
    {
      "number": 156,
      "id": "MDU6SXNzdWU0Njg4OTUwMzU=",
      "title": "IPR issues",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/156",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Bjoern Haase has filed an IPR notice for Icart's algorithm.\r\n\r\nThere is also some concern that Simplified SWU with Z = -1 is covered by a patent. We may wish to sidestep this issue by specifying that Z != -1 for Simplified SWU.\r\n\r\nGiven the patent issues with Icart, we probably want to switch P-384 from Icart's algorithm to Simplified SWU with Z = -2.",
      "createdAt": "2019-07-16T22:17:41Z",
      "updatedAt": "2019-10-23T03:54:16Z",
      "closedAt": "2019-10-23T03:54:16Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "All the concrete actions in this issue are now comprehended.",
          "createdAt": "2019-10-23T03:54:16Z",
          "updatedAt": "2019-10-23T03:54:16Z"
        }
      ]
    },
    {
      "number": 157,
      "id": "MDU6SXNzdWU0NzE1MDE4Nzk=",
      "title": "define sign of sqrt in constants for S-vdW and others",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/157",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Some of the maps use constants whose definitions include sqrts. The document should specify for these that the intended constant value is the one computed for the \"positive\" sqrt branch, i.e., the value `c = sqrt(something)` such that `sgn0(c) == 1` to avoid ambiguity about the value of `c`.",
      "createdAt": "2019-07-23T06:04:56Z",
      "updatedAt": "2019-10-26T19:16:28Z",
      "closedAt": "2019-10-26T19:16:28Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Agree, also each named suite should state explicitly the set of constants used for a given curve.",
          "createdAt": "2019-07-30T01:34:02Z",
          "updatedAt": "2019-07-30T01:34:02Z"
        }
      ]
    },
    {
      "number": 158,
      "id": "MDU6SXNzdWU0NzE1MDMzMjA=",
      "title": "consider using WB19 approach for secp256k1 (and others?)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/158",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "secp256k1 is currently specified using Shallue and van de Woestijne. In general it's much cheaper to use the technique from WB19, i.e., map to an isogenous curve and then evaluate the isogeny map. For secp256k1, there are curves 3-isogenous to secp256k1 with nonzero j-invariant in the base field. It probably makes sense to leverage these for a (3x) faster mapping than S-vdW.",
      "createdAt": "2019-07-23T06:10:12Z",
      "updatedAt": "2019-10-26T19:16:29Z",
      "closedAt": "2019-10-26T19:16:29Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "(BN curves from the pairing-friendly draft probably want to use WB19, too)",
          "createdAt": "2019-07-23T06:11:06Z",
          "updatedAt": "2019-07-23T06:11:06Z"
        }
      ]
    },
    {
      "number": 159,
      "id": "MDU6SXNzdWU0NzE5MDIzMTc=",
      "title": "Z selection pseudocode",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/159",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We may want to include pseudocode that outputs Z for a given map, curve params, etc., to ensure that everyone arrives at the same value!",
      "createdAt": "2019-07-23T19:54:52Z",
      "updatedAt": "2019-10-26T19:16:28Z",
      "closedAt": "2019-10-26T19:16:28Z",
      "comments": []
    },
    {
      "number": 160,
      "id": "MDU6SXNzdWU0NzI5ODk0MDA=",
      "title": "suites specify W for hash_to_base, should be L",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/160",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "see title. Just need to harmonize this in suites. Oops!!!",
      "createdAt": "2019-07-25T17:42:10Z",
      "updatedAt": "2019-08-13T15:42:01Z",
      "closedAt": "2019-08-13T15:42:01Z",
      "comments": []
    },
    {
      "number": 161,
      "id": "MDU6SXNzdWU0NzYyMTc1MDM=",
      "title": "ensure that suite names are prefix-free",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/161",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@hoeteck suggests out-of-band that it will be useful to have prefix-free ciphersuite names in case upper-level protocols want to include those suite names in their domain separation strings.\r\n\r\nOne easy way to do this is to add a trailing hyphen (e.g., \"P256-SHA256-SSWU-RO-\"). Probably reasonable to add as cheap insurance against misuse.",
      "createdAt": "2019-08-02T14:48:02Z",
      "updatedAt": "2019-08-13T15:42:01Z",
      "closedAt": "2019-08-13T15:42:01Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, this may also have bearing on #140: probably we *don't* want to add a `-V2-` suffix, since then one csuite is a prefix of another.\r\n\r\nA couple obvious possibilities:\r\n\r\n1.  We could add a version field now, e.g., \"P256-SHA256-SSWU-RO-V0-\"\r\n2.  We could use a different separator than hyphen if we want to add a version number in the future. In particular, \"P256-SHA256-SSWU-RO_V2-\" avoids the prefix issue. So does \"P256:V2-SHA256-SSWU-RO-\". Lots of options here.\r\n\r\nThe first one is maybe aesthetically nicer, whereas something like the second one doesn't require us to anticipate every possible need right now. To me it seems like there are enough workarounds that we should do something approximating the second, not the first.",
          "createdAt": "2019-08-02T14:58:02Z",
          "updatedAt": "2019-08-02T14:58:02Z"
        }
      ]
    },
    {
      "number": 162,
      "id": "MDU6SXNzdWU0NzYyMjQwNDA=",
      "title": "make sure \"H2C\" is unambiguous in hash_to_base",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/162",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "May want to specify that \"H2C\" is the sequence of bytes 0x48, 0x32, 0x43, i.e., the ASCII/UTF-8 encoding of the string.",
      "createdAt": "2019-08-02T15:00:46Z",
      "updatedAt": "2019-08-13T15:42:01Z",
      "closedAt": "2019-08-13T15:42:01Z",
      "comments": []
    },
    {
      "number": 164,
      "id": "MDU6SXNzdWU0NzkzMTc0NjU=",
      "title": "404 link in readme",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/164",
      "state": "CLOSED",
      "author": "JustinDrake",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "[Compare Editor's Copy to Individual Draft](https://cfrg.github.io/draft-irtf-cfrg-hash-to-curve/draft-irtf-cfrg-hash-to-curve.diff) points to a 404",
      "createdAt": "2019-08-11T00:05:19Z",
      "updatedAt": "2019-10-27T01:23:39Z",
      "closedAt": "2019-10-27T01:23:39Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed!",
          "createdAt": "2019-10-27T01:23:36Z",
          "updatedAt": "2019-10-27T01:23:36Z"
        }
      ]
    },
    {
      "number": 165,
      "id": "MDU6SXNzdWU0ODA5MzU2NTI=",
      "title": "Support for SHA-3 and SHAKE / cSHAKE",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/165",
      "state": "CLOSED",
      "author": "mimoo",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The current draft only seems to standardize the algorithms with SHA-2. I'd like to see support for SHA-3 and SHAKE (and cSHAKE) if possible so that we don't have to write an extension/another RFC later on.\r\n\r\nusing cSHAKE would allow to replace the hash and HKDF with one algorithm.",
      "createdAt": "2019-08-14T23:48:05Z",
      "updatedAt": "2019-10-30T16:29:51Z",
      "closedAt": "2019-10-30T16:29:51Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for bringing this up!\r\n\r\nThe SHA-3 part of this request appears to be easily handled by creating a ciphersuite (but please let me know if this does not seem correct). As such, it shouldn't require an extension or another RFC even if we don't specify SHA-3--based suites.\r\n\r\nRegarding (c)SHAKE:\r\n\r\nI'm sure you're aware of my comments in the other thread, but for the sake of completeness, here's a link: cfrg/draft-irtf-cfrg-bls-signature#10. To rehash and slightly expand my comments there:\r\n\r\nTo me it does not appear that there's a compelling reason to use (c)SHAKE rather than HKDF:\r\n\r\n- HKDF works just fine for SHA-3; in contrast, there's no sensible notion of \"compatibility\" between SHA-2 and (c)SHAKE.\r\n\r\n- (c)SHAKE is slightly cheaper than HKDF-SHA3, but there's categorically no reason to optimize the cost of HKDF invocations in hash-to-curve---that cost is fully in the noise.\r\n\r\n- The hash-to-curve draft is already quite complex. From my perspective, the bar is very high for specifying multiple KDFs given that HKDF already works for everything.\r\n\r\n- I'm aware of and reasonably sympathetic to the argument that some codebases will already have a (c)SHAKE implementation and won't want to add HKDF, but I'm skeptical of the practical benefit given that there are compact and extremely mature implementations of HKDF, whereas (c)SHAKE is new and comparatively obscure.\r\n\r\nBut: let's discuss further! Opinions are made to be changed :)\r\n\r\nCC @chris-wood @armfazh ",
          "createdAt": "2019-08-15T19:19:07Z",
          "updatedAt": "2019-08-15T19:19:07Z"
        },
        {
          "author": "mimoo",
          "authorAssociation": "NONE",
          "body": "Hey @kwantam thanks for the response!\r\n\r\n> The hash-to-curve draft is already quite complex. From my perspective, the bar is very high for specifying multiple KDFs given that HKDF already works for everything.\r\n\r\nI can agree that supporting more algorithms means having a more complex specification. I'm usually against making a specification more complex. So for once, I'm going to support a side I'm not used to support :)\r\n\r\nBut I have good arguments!\r\n\r\nThe reason is that we are investigating using cSHAKE in place of hash functions, KDFs, and so on. and getting rid of dependencies we don't need. If this draft would switch to cSHAKE exclusively, it would actually be much simpler than the current one.\r\n\r\n> HKDF works just fine for SHA-3; in contrast, there's no sensible notion of \"compatibility\" between SHA-2 and (c)SHAKE.\r\n\r\nIt is true that HKDF works fine for SHA-3/SHAKE, but it also makes little sense to implement it on top of something that already provides pretty much the same API as HKDF. Realistically, we are probably going to just use (c)SHAKE instead and risk diverging from the specification. How costly would it be to add HKDF to the name of the ciphersuite?\r\n\r\n> I'm skeptical of the practical benefit given that there are compact and extremely mature implementations of HKDF, whereas (c)SHAKE is new and comparatively obscure.\r\n\r\ncSHAKE is pretty much the same construction as SHA-3. So I wouldn't say obscure. If we talk about support from libraries, then I agree.\r\n\r\n",
          "createdAt": "2019-08-15T19:52:22Z",
          "updatedAt": "2019-08-15T19:54:09Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@mimoo thanks for the clarifications :+1:\r\n\r\n> The reason is that we are investigating using cSHAKE in place of hash functions, KDFs, and so on. and getting rid of dependencies we don't need. If this draft would switch to cSHAKE exclusively, it would actually be much simpler than the current one.\r\n\r\nObviously it's easy to disagree about what qualifies as \"much simpler,\" but count me as strongly skeptical. The maximum possible simplification would be obtained by replacing HKDF-`H` with cSHAKE256. But let's think about how much that actually simplifies the document:\r\n\r\n- It doesn't significantly simplify the hash-to-base-field section. At best, it means that we could get rid of the discussion of `H`'s output length.\r\n\r\n- It doesn't significantly simplify the ciphersuites. At best, it means that we could remove `H`.\r\n\r\nMoreover, note that the above simplifications are not intrinsic to the choice of cSHAKE: we could instead require everyone to use HKDF-SHA2-512, whereupon we'd also get the above simplifications. So the claim about simplification appears to be a generic argument for fixing one hash function, not an argument for using cSHAKE.\r\n\r\nBut beyond that, to first order there does not appear to be *any* interest in using SHA-3 other than yours (please interpret \"yours\" broadly---I surmise that you are speaking on behalf of your employer). So you can certainly understand how from my perspective the suggestion to require everyone to use SHA-3 isn't even remotely plausible. This means that the only option is to specify multiple KDFs, and that is *not* a simplification.\r\n\r\nIn other words, specifying cSHAKE would, under any remotely plausible interpretation, dramatically increase the complexity of the standard.\r\n\r\n> It is true that HKDF works fine for SHA-3/SHAKE, but it also makes little sense to implement it on top of something that already provides pretty much the same API as HKDF.\r\n\r\nAs far as I can tell, the above effectively restates the argument that it's more efficient to use cSHAKE than to use HKDF-SHA3. In a narrow sense, there's no doubt that this is true.\r\n\r\n(EDIT: to be clear: SHA-3 *does not* provide the same API as HKDF. cSHAKE does, but no one is arguing to use cSHAKE inside HKDF.)\r\n\r\nBut in the broader context of the standard, the more important question is: how does the cost/benefit of using HKDF-SHA3 compare to the cost/benefit of specifying multiple KDFs? And there, it seems to me that the cost of HKDF-SHA3 vs cSHAKE is effectively zero (because the cost of the hashing is in the noise), whereas the cost of specifying multiple KDFs is high (because it increases the complexity of the document).\r\n\r\nSo to me, what you say in the quote above is articulating an aesthetic preference, not a technical justification.\r\n\r\n> Realistically, we are probably going to just use (c)SHAKE instead and risk diverging from the specification. How costly would it be to add HKDF to the name of the ciphersuite?\r\n\r\nThis appears to be a statement that you have no intention of following the standard unless the document is modified to reflect what you've already decided to do. (Please correct me if I'm wrong.)\r\n\r\nI want to be clear: that is a totally fine decision, though I hope you do not follow that course.\r\n\r\nIn any case, I'm sure you can see that, from my perspective, this is not a persuasive argument either for or against change: since everyone else who is currently implementing (to my knownedge) prefers to use HKDF-SHA2, either choice means that *someone* will violate the standard.\r\n\r\n> cSHAKE is pretty much the same construction as SHA-3.\r\n\r\nExactly! and I have no hesitation in claiming that compared to HKDF and SHA-2, SHA-3 is obscure.\r\n\r\nBut the point is: even if SHA-3 were *exactly* as popular as SHA-2 (which certainly isn't true now, and indeed may never become true), that would not be enough to justify ruling out the use of SHA-2 in the standard.\r\n\r\nMeanwhile, the current standard explicitly provides for the use of SHA-3 (see #137). Yes, it is very slightly sub-optimal. But please see above regarding aesthetic vs technical justifications.",
          "createdAt": "2019-08-15T21:18:54Z",
          "updatedAt": "2019-08-15T21:23:43Z"
        },
        {
          "author": "mimoo",
          "authorAssociation": "NONE",
          "body": "I think I can agree with most of your points. I still think that if we're writing an RFC today, it doesn't make sense to not include SHA-3 or constructions that will probably grow or even replace the current ones in the future.\r\n\r\n> everyone else who is currently implementing\r\n\r\nhow many people are doing this? It sounds like one request is already a pretty big percentage :D",
          "createdAt": "2019-08-15T21:31:24Z",
          "updatedAt": "2019-08-15T21:31:24Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the quick response :+1:\r\n\r\n> I still think that if we're writing an RFC today, it doesn't make sense to not include SHA-3 or constructions that will probably grow or even replace the current ones in the future.\r\n\r\nWith apologies (I may be misinterpreting), the above appears to be saying that nothing short of fully optimizing for SHA-3 (in this case, by using SHAKE rather than HKDF) counts as \"including\" it in the standard. If indeed that's what the statement means, I think it's reasonable to regard that as a tendentious characterization.\r\n\r\nWe certainly *do* consider SHA-3 important, and the current document is perfectly compatible with its use. If it would be helpful for us to explicitly list ciphersuites and test vectors for SHA-3, that's absolutely something we will consider! (but I'm sure you can understand that I can't promise to do it before consulting with my co-authors).\r\n\r\n> how many people are doing this? It sounds like one request is already a pretty big percentage :D\r\n\r\nAs @JustinDrake [points out](https://github.com/cfrg/draft-irtf-cfrg-bls-signature/issues/10#issuecomment-521440891), everyone who has been participating in the bi-weekly BLS signatures teleconference appears to prefer some variant of SHA-2. Concretely, the [BLS sigs README](https://github.com/cfrg/draft-irtf-cfrg-bls-signature) lists a few reference implementations, and those are all using SHA-2.",
          "createdAt": "2019-08-15T21:49:14Z",
          "updatedAt": "2019-08-16T02:08:38Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> How costly would it be to add HKDF to the name of the ciphersuite?\r\n\r\nBy the way, a small suggestion:\r\n\r\nIf you prefer to specify a ciphersuite that uses cSHAKE instead of HKDF, I'd recommend indicating this in the ciphersuite ID to avoid confusion. For example, you might consider ciphersuite names simliar to the following:\r\n\r\n    BLS12381G1-SHA3256-SSWU-RO:KDF=cSHAKE-\r\n\r\nOr perhaps\r\n\r\n    BLS12381G1-SHA3256:KDF=cSHAKE-SSWU-RO-\r\n\r\nThis will help ensure orthogonality to folks using HKDF-SHA3.",
          "createdAt": "2019-08-15T21:56:50Z",
          "updatedAt": "2019-08-16T02:09:30Z"
        },
        {
          "author": "mimoo",
          "authorAssociation": "NONE",
          "body": "> With apologies (I may be misinterpreting), this appears to be saying that nothing short of fully optimizing for SHA-3 counts as including it. I think it's reasonable to regard this as a tendentious characterization.\r\n\r\nNot sure I understand this paragraph\r\n\r\n> If it would be helpful for us to explicitly list ciphersuites and test vectors for SHA-3, that's absolutely something we will consider\r\n\r\ncool!",
          "createdAt": "2019-08-15T22:54:07Z",
          "updatedAt": "2019-08-15T22:54:07Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "I'd personally suggest specifying only for cloneable XoFs like SHAKE128 and Blake2x but relegate HKDF to some legacy algorithms appendix, but yeah the speed does not matter here.  It's possible memory usage matters for some very small devices, but those can always do something custom.",
          "createdAt": "2019-08-18T10:12:58Z",
          "updatedAt": "2019-08-18T10:12:58Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm leaning towards adding some words in the document (maybe in the hash_to_base section, or in the ciphersuites section) about how one could define new suites that use variants of hash_to_base, e.g., built on different PRGs.\r\n\r\nI'm really not inclined to define multiple hash_to_base variants because of issues with exploding complexity. But on the other hand, doing it now means that we can try and make sure that domain separation is done correctly, etc...",
          "createdAt": "2019-10-13T05:31:04Z",
          "updatedAt": "2019-10-13T05:31:04Z"
        }
      ]
    },
    {
      "number": 166,
      "id": "MDU6SXNzdWU0ODI0NDMyOTQ=",
      "title": "cofactor clearing pseudocode",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/166",
      "state": "OPEN",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "I ran into @mmaker at CRYPTO, who suggested that including pseudocode for fast cofactor clearing for BLS12-381 would be a nice addition to the document and probably wouldn't be all that complicated.\r\n\r\nI tend to agree---certainly if we're going to have optimized pcode in the appendix, there's a good argument for including this...\r\n\r\nThoughts?",
      "createdAt": "2019-08-19T17:46:24Z",
      "updatedAt": "2019-10-24T20:20:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kirk-baird",
          "authorAssociation": "NONE",
          "body": "I agree that it would be good to have the co-factor clearing as it would make it easier for others to implement, hence gain popularity as opposed to multiplication by the co-factor.",
          "createdAt": "2019-08-30T04:29:31Z",
          "updatedAt": "2019-08-30T04:29:31Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "NONE",
          "body": "In an attempt of helping you guys out, here's how I would personally do it:\r\n```sage\r\nq = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\r\nr = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\r\nx = -0xd201000000010000\r\n\r\nZq = GF(q)\r\nZq2.<i> = GF(q^2, modulus=[1, 0, 1])\r\nu = i+1\r\n\r\nE2 = EllipticCurve(Zq2, [0, 4*u])\r\nE1 = EllipticCurve(Zq, [0, 4])\r\n```\r\n\r\nHere I define the map \u03c8:\r\n```sage\r\ndef psi(P):\r\n    x, y = P.xy()\r\n    return E2(x.frobenius()/(u^((q-1)/3)), y.frobenius()/u^((q-1)/2))\r\n\r\ndef psi2(P):\r\n    # return psi(psi(P))\r\n    x, y = P.xy()\r\n    return E2(x.frobenius(2)/Zq(2)^((q-1)/3), -y.frobenius(2))\r\n```\r\nHere is Scott: \r\n```sage\r\ndef mul_cofactor_s(P):\r\n    return (x^3-x^2-x+4)*P + (x^3-x^2-x+1)*psi(P) + (-x^2+2*x-1)*psi2(P)\r\n```\r\n\r\nHere is budroni-pintore:\r\n```sage\r\ndef mul_cofactor_bp(P):\r\n    return (x^2-x-1)*P + (x-1)*psi(P) + 2*psi2(P)\r\n```\r\n\r\nThen I guess most software developers will notice themselves that, if willing, one can precompute all those constants. lmk if there's any way I can help you out integrating this to the draft!",
          "createdAt": "2019-09-02T20:21:02Z",
          "updatedAt": "2019-09-02T23:36:46Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for your contribution @mmaker .",
          "createdAt": "2019-09-03T17:17:19Z",
          "updatedAt": "2019-09-03T17:17:19Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "NONE",
          "body": "Hi @kwantam ! \r\nI tried to sketch a cofactor multiplication section in the appendix, see: https://github.com/mmaker/draft-irtf-cfrg-hash-to-curve/commit/43bd8fc7a4310115e6accc19b2f9f1360a0778b4.\r\nI encountered a couple difficulties you might help me out resolve: \r\n\r\n- inconsistencies: \r\n   - citation sometimes are separated by \\n\\n, sometimes by \\n. Sometimes indentation is different. Which one should I use? Mind if I make them all uniform in separate pull request? Also editorial keys seem inconsistent sometimes. \r\n  -  the code is standard python, while I'm using sage. The example implementation (i.e. `poc/`) uses sage. What should I use? The RFC is not going to be more clear if we add add finite field extensions and Frobenius mapping in pure python.\r\n- there's no place where BLS12-381 constants are defined. Actually, at this stage of the draft curve BLS12-381 is just mentioned. Wouldn't it be more appropriate to move this to the BLS draft where hashing to BLS12-381 is defined, at this point? \r\n- after some thinking, I don't see any reason for adopting Scott's method given there's a much better method. Are you okay with me not reporting it?",
          "createdAt": "2019-09-08T21:45:52Z",
          "updatedAt": "2019-09-08T21:46:10Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "NONE",
          "body": "ping?\r\n(the BLS draft uses hashing into G1, so\u2026 that was a bad idea. But the issue remains.)\r\n",
          "createdAt": "2019-10-02T13:54:17Z",
          "updatedAt": "2019-10-02T13:55:08Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry for the delay. I'm catching up on some straggling work elsewhere and hope to return to this in the next couple days. Thanks for the contribution---and for your patience with me :)",
          "createdAt": "2019-10-02T18:24:59Z",
          "updatedAt": "2019-10-02T18:24:59Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "NONE",
          "body": "ping?\r\n\r\n(No worries :P)",
          "createdAt": "2019-10-14T14:29:29Z",
          "updatedAt": "2019-10-14T14:29:49Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry! I will have time to look in more detail in the next few days.\r\n\r\nBut, some quick answers:\r\n\r\n1. I'm sure there are plenty of inconsistencies. We'd love a PR for bib cleanup, but I understand that's a big and not particularly pleasant undertaking, so don't feel bad if you'd rather spend time on other things :)\r\n    \r\n    As far as code goes, I thought the poc/ code *was* in sage, no? There's some python in there, but I think all of it actually gets executed in Sage. I thought...\r\n\r\n2. Yes, I think probably in the end all of this BLS12-381--specific info wants to be in the pairings draft, not here. That may also go for the isogeny constants that we currently specify in the appendix.\r\n\r\n3. Which method do you mean by Scott's? Do you mean the method of clearing the cofactor on G1 that requires multiplication by a smaller value than h, or do you mean [SBCDK09]?",
          "createdAt": "2019-10-14T18:27:07Z",
          "updatedAt": "2019-10-14T18:27:45Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "NONE",
          "body": "Hi Riad: thanks for the partial answer: \r\n\r\n1. alright\r\n2. I see some python for defining prime field operations. If this chunk of code is executed in sage, there's more appropriate data structures! e.g in my code above I am able to do mod p operations, but I don't have to define them all over again like in here:\r\nhttps://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/blob/master/poc/fouquetibouchi_hacspec.py\r\nhence, I thought this was meant for execution outside sage? (the file extension is also different) \r\n3. Yes, I mean that \"[SBCDK09]\" is not relevant for the spec. I'm proposing we just explain Fuentes et al.'s method as presented in Budroni-Pintore",
          "createdAt": "2019-10-16T14:51:53Z",
          "updatedAt": "2019-10-16T14:53:15Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, right. It's safe to regard the hacpsec stuff as legacy. We might get back to using it eventually, but I'd say just go with sage and we'll deal with porting if/when we decide to use hacspec again.",
          "createdAt": "2019-10-16T14:58:12Z",
          "updatedAt": "2019-10-16T14:58:47Z"
        }
      ]
    },
    {
      "number": 171,
      "id": "MDU6SXNzdWU1MDgwNzc1MjM=",
      "title": "require Z != -1 for s-swu",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/171",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This avoids infringing US patent 8712038.",
      "createdAt": "2019-10-16T20:20:37Z",
      "updatedAt": "2019-10-26T19:16:28Z",
      "closedAt": "2019-10-26T19:16:28Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "See also #156",
          "createdAt": "2019-10-16T21:34:43Z",
          "updatedAt": "2019-10-16T21:34:43Z"
        },
        {
          "author": "JustinDrake",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For patent issues would it make sense to explain the restrictions and explicitly link to the relevant patents? This would serve several purposes:\r\n\r\n1) Provide context behind the standardisation decisions.\r\n2) Help implementers avoid using patented ideas.\r\n2) Help implementers use the patented ideas once the patent has expired. (For example, [US7110538](https://patents.google.com/patent/US7110538) is due to expire soon.)",
          "createdAt": "2019-10-17T04:04:02Z",
          "updatedAt": "2019-10-17T04:04:02Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Great question! I think it would be a nice idea, but the IETF [specifically disallows this](https://tools.ietf.org/html/rfc3668#section-11).\r\n\r\nThe correct way to do this, I believe, is to file a separate IPR disclosure form, and include the rationale in the comments on that form.\r\n\r\nI posted an [updated proposal](https://mailarchive.ietf.org/arch/msg/cfrg/jV4Wr4fbMKkd4vzsbEhKbous16Y) for entirely avoiding the S-SWU patents. I will update the document with the newest procedure, and then update the IPR disclosures with the corresponding rationale.",
          "createdAt": "2019-10-21T00:22:02Z",
          "updatedAt": "2019-10-21T00:22:02Z"
        }
      ]
    },
    {
      "number": 173,
      "id": "MDU6SXNzdWU1MTE1ODcyNjU=",
      "title": "proposal: remove the maps to supersingular curves",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/173",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "question"
      ],
      "body": "At this point we don't have any clear examples of when people would want to do this.\r\n\r\nIt might become the case in the future that someone wants to do it. If so, it would be easy to create a new document that incorporates all of h2c by reference and specifies Boneh-Franklin and/or Ell2-A0.\r\n\r\nThe advantage of getting rid of them here is reducing confusion and reducing document surface area. To me this is a win.\r\n\r\nThoughts?\r\n\r\nCC @grittygrease @armfazh @chris-wood @JustinDrake",
      "createdAt": "2019-10-23T21:41:53Z",
      "updatedAt": "2020-01-23T22:28:59Z",
      "closedAt": "2020-01-23T22:28:58Z",
      "comments": [
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "Among the verifiable delay function designs, the [most powerful candidate](https://eprint.iacr.org/2019/166) involves hashing to a supersingular curve, even a randomly chosen supersingular curve.  Just fyi, the isogenies VDF is the most powerful candidate in the sense that it provides a strictly more functionality than any other VDF design.  VDFs are an extremely niche construction though, so you should probably still remove hashing to supersingular curves. ",
          "createdAt": "2019-10-26T09:03:46Z",
          "updatedAt": "2019-10-26T09:03:46Z"
        },
        {
          "author": "JustinDrake",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> it provides a strictly more functionality than any other VDF design\r\n\r\nCan you elaborate? :)",
          "createdAt": "2019-10-26T10:09:50Z",
          "updatedAt": "2019-10-26T10:09:50Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@burdges great, thanks for pointing this out!\r\n\r\n(I now dimly remember reading this paper...)",
          "createdAt": "2019-10-26T20:42:42Z",
          "updatedAt": "2019-10-26T20:42:42Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "@JustinDrake At least two pairing based protocols are transformed by using a isogeny with known running time T and a bound A on the adversarial advantage: \r\n\r\nFirst, BLS signatures gives you the basic VDF itself from that paper.\r\n\r\nSecond, if you consider that VDF output as the identity-based secret key in an identity-based encryption scheme, with master secret key the VDF isogeny, then anyone can encrypt to the eventual evaluation of the VDF after it starts but before T/A.  \r\n\r\nIt's a true \"encrypt to the near future\" protocol.  All the conventional time-lock puzzles permit encryption into the further future beyond T/A, but because they do not share one evaluation track, they only really work for very high value data, which makes them useless.  In particular time-lock puzzles cost way too much for voting protocols, while an isogenies VDF replaces the trusted parties who open votes.\r\n\r\nIn principle, one could transform other pairing-based protocols similarly.  We must avoid too many isogenies running in parallel though, so not sure how many others really yield anything interesting.  ",
          "createdAt": "2019-10-27T10:29:54Z",
          "updatedAt": "2019-10-27T10:34:55Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@burdges going back and looking again, it's not totally clear to me that the supersingular mappings in the draft are necessary or all that helpful for the VDF application. The reason is, the B-F and Ell2A=0 maps only work for subsets of all supersingular curves, and it's not obvious to me whether one would choose a curve from one of those subsets as the starting point of the VDF. In other words, it's easy to imagine needing a map other than one of the supersingular-specific ones when implementing this VDF.\r\n\r\n(Of course, maybe one would intentionally choose a curve that's easy to hash to... not clear to me.)",
          "createdAt": "2019-10-29T21:37:11Z",
          "updatedAt": "2019-10-29T21:37:11Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "There are larger constraints like the divisors of the group order, so you cannot necessarily choose from any particular family. ",
          "createdAt": "2019-10-29T23:10:25Z",
          "updatedAt": "2019-10-29T23:10:25Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I spoke with Luca De Feo about this VDF at [ECC19](https://eccworkshop.org/2019/), and in the process realized that in fact one cannot use a curve with j=1728 or j=0 because it's crucial that no one know the structure of the endomorphism ring of the starting curve (or they can shortcut the VDF). Missed that the first time or forgot it along the way...\r\n\r\nSo neither of the maps apply to that VDF.\r\n\r\nIn principle they might apply to CSIDH, CSI-FiSh, or related schemes, where the starting curve can indeed have j=1728 or j=0, but as far as I know no such scheme requires hashing to points on curves.\r\n\r\nI also gave a talk on hashing to curves at ECC19 and, in the process, asked the audience if there were any known schemes that needed to hash to such curves. The response generally seemed to be \"no\".\r\n\r\nSo my guess is that these schemes would not be missed if we didn't include them in this standard. But maybe the cost is not so much. If we want to give test vectors, perhaps we can use curves with j=1728 and j=0 over the CSIDH p512 prime, which is defined as \r\n\r\n    p512 = 4 * prod(first 73 odd primes) * 587 - 1",
          "createdAt": "2019-12-06T19:08:40Z",
          "updatedAt": "2019-12-06T19:09:43Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "Yes true, I missed the maps depended upon j=1728 or j=0, at least when thinking about VDFs.  \r\n\r\nAfaik, any interesting protocol based on both isogenies and pairings will need curves that cannot be reached from j=1728 or j=0 because the pairings occur on multiple curves with at least one of the curves behind some secret isogeny.  I doubt hasing-to-the-curve helps much with post quantum protocols too. ",
          "createdAt": "2019-12-07T00:55:32Z",
          "updatedAt": "2019-12-07T00:55:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Chiming in late: given the discussion above, and the fact that this can always be done in a future document, I'd advocate for removing hashing to supersingular curves. @kwantam if you still think this is the right thing to do, I can put together a PR to drop them. (@armfazh, what do you think?)",
          "createdAt": "2020-01-20T22:41:33Z",
          "updatedAt": "2020-01-20T22:41:33Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd still like to do this. I need to double check, but I think #198 is basically ready to go.",
          "createdAt": "2020-01-20T23:30:21Z",
          "updatedAt": "2020-01-20T23:30:21Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing via #198",
          "createdAt": "2020-01-23T22:28:58Z",
          "updatedAt": "2020-01-23T22:28:58Z"
        }
      ]
    },
    {
      "number": 174,
      "id": "MDU6SXNzdWU1MTIxNTczODc=",
      "title": "meta-issue: triage for Singapore IETF meeting",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/174",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The next IETF meeting in Singapore happens soon. The cutoff for submitting a new I-D is [November 4th at 23:59 UTC](https://datatracker.ietf.org/meeting/106/important-dates/). This issue is to help with triage.\r\n\r\n# High priority\r\n\r\n- [x] Z selection (#159, #171, #172) --- PR is merged (#172)\r\n\r\n- [x] SvdW update (#155, #157, #172) --- PR is merged (#172)\r\n\r\n- [x] Ciphersuite updates (#158) --- PR is merged (#172)\r\n\r\n- [x] sgn0 / sqrt definitions (#144) --- ~~I've got a PR in the wings for this. I'll push it to completion and submit it in the next couple days.~~ PIR is merged (#176)\r\n\r\n- [ ] Coordinate with Ristretto --- can happen before or after. Main goal is to figure out what the right API is, both for Ristretto and for whichever pieces of h2c the Ristretto draft uses.\r\n\r\n- [x] Coordinate with VRF --- I've opened a pull request (fcelda/nsec5-draft#35) against VRF for this. Probably safe to assume we'll coordinate there for this.\r\n\r\n# Nice to have\r\n\r\n- [ ] Handle some out-of-band comments from emails (some of these haven't been translated to issues)\r\n\r\n- [x] Discussion of alternative hash_to_base algorithms (#165) --- probably just want a paragraph in Suites talking about how to indicate that a suite uses an alternative hash_to_base (e.g., SHAKE). PR is merged (#175)\r\n\r\n- [x] Style nits (#105) --- might be nice to do a sweep for these, if there's time.\r\n\r\n- [ ] Variable naming nits (#110) --- same as above.\r\n\r\n# Not now\r\n\r\n- [ ] cofactor clearing pseudocode (#166) --- I think this probably goes in the pairings draft, not ours, right?\r\n\r\n- [x] #164 --- only pertains to the repo, not the draft\r\n\r\n- [ ] Decide on removing supersingular maps (#173) - I'd like to talk to some more folks before we make a decision on this. I'm going to be at the ECC Workshop in December---maybe some people there have an opinion.\r\n\r\n- [ ] Flow-chart (#63, #118) - nice to have, but probably doesn't go inside the draft, so we can push this to later.\r\n\r\n- [ ] Code clean-up (#98, #112, #151) --- hate to keep kicking this can down the road, but we've got enough on our plates and I doubt there's time. (This also includes test vectors...)\r\n\r\n# Issues that can be closed right now\r\n\r\nI think all of the following can be closed without further action. Please reply if you disagree.\r\n\r\n- [x] #43 - Ristretto will handle this\r\n- [x] #95 - Suites now handle this\r\n- [x] #96 - BLS sigs draft now handles this\r\n- [x] #107 - we now discuss the relevant conversions\r\n- [x] #109 - we decided to do projective in the appendices and affine in the body\r\n- [x] #111 - we decided to do generic straight-line in body text, specific appendix\r\n- [x] #124 - we've decided on a plan here, and it's in the text\r\n- [x] #126 - I think we've got a plan here, too",
      "createdAt": "2019-10-24T20:13:43Z",
      "updatedAt": "2019-11-05T07:18:53Z",
      "closedAt": "2019-11-05T07:18:53Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "CC @chris-wood @armfazh please let me know whether you think any of the \"issues that can be closed\" above should stay open.\r\n\r\nI'm going to have new PRs to handle most of the \"high priority\" issues in the next few days. My plan was mostly to rely on y'all for reviewing, if that's OK.",
          "createdAt": "2019-10-24T20:15:51Z",
          "updatedAt": "2019-10-24T20:15:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam I'm fine with closing those ones, and I'm happy to review the high priority issues as they come in. I'll fix #164 and work on code quality and test vectors from our Sage implementations. I'll also claim #105 and #110.",
          "createdAt": "2019-10-24T20:19:32Z",
          "updatedAt": "2019-10-24T20:19:32Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I spoke with @reyzin about incorporating hash-to-curve by reference in the next version of the VRF document. The plan is to push ahead with edits to VRF after we've pushed draft-05. I'll plan to put together a PR against VRF at that time.",
          "createdAt": "2019-10-29T18:30:02Z",
          "updatedAt": "2019-10-29T18:30:02Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "We've pushed -05, so this issue is done. We'll bring remaining issues forward on the next push.",
          "createdAt": "2019-11-05T07:18:52Z",
          "updatedAt": "2019-11-05T07:18:52Z"
        }
      ]
    },
    {
      "number": 181,
      "id": "MDU6SXNzdWU1MTI5MjYwNTY=",
      "title": "suites: optimized impls in appendix",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/181",
      "state": "OPEN",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Right now we have only the P-256, curve/edwards25519, and curve/edwards448.\r\n\r\nTODO: add others\r\n\r\n- [x] P-384\r\n- [x] P-521\r\n- [x] SECP256k1\r\n- [x] BLS12-381 G1\r\n- [ ] BLS12-381 G2\r\n- [ ] SSWU for p = 5 mod 8 --- for P-224 and some other curves\r\n\r\nThe potential optimizations for Shallue-van de Woestijne are pretty minimal, so I am assuming that for all of the above we would give straight-line impls only of Simplified SWU. Glad to consider doing otherwise, though.",
      "createdAt": "2019-10-27T06:13:12Z",
      "updatedAt": "2020-03-01T16:20:02Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "#183 handles P-384 and P-521 for S-SWU. ~~(Actually, maybe it should also be used for secp256k1...)~~\r\n\r\nUpdated to handle secp256k1, too.\r\n\r\n~~(Hmm, and it should also handle BLS12-381 G1...)~~\r\n\r\nUpdated to handle BLS12-381 G1, too.",
          "createdAt": "2019-10-28T00:07:35Z",
          "updatedAt": "2019-10-28T06:10:43Z"
        },
        {
          "author": "dot-asm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Assuming that this is about appendix D, on vaguely related note, there is typo in commentary to step 23 in map_to_curve_simple_swu_3mod4. It currently reads `... -10 * u^2 * x1n ...` when it should read `... Z * u^2 * x1n ...`.",
          "createdAt": "2020-03-01T16:20:02Z",
          "updatedAt": "2020-03-01T16:20:02Z"
        }
      ]
    },
    {
      "number": 190,
      "id": "MDU6SXNzdWU1MTgxMTU3MzI=",
      "title": "is_square for field extensions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/190",
      "state": "OPEN",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement"
      ],
      "body": "Michael Scott points out (citing El Mrabet and Joye's book, which cites [Adj and Rodriguez-Henriquez](https://eprint.iacr.org/2012/685)) that is_square can be computed more cheaply than an exponentiation in extension fields.\r\n\r\nThe idea is that, for (a0, a1) = a in F(p^2), is_square(a) = is_square(|a|) over F(p), where |a| = a0^2 + a1^2. For an extension tower at least, one assumes this can be done recursively.\r\n\r\nAt the very least we should cite the AR-H12 paper when discussing is_square().",
      "createdAt": "2019-11-05T23:15:36Z",
      "updatedAt": "2019-11-05T23:15:43Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 194,
      "id": "MDU6SXNzdWU1MjE2ODA3Mjk=",
      "title": "Consider mentioning Lemire's \"multiply-then-shift\" strategy as alternative to modulo reduction in hash_to_base",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/194",
      "state": "CLOSED",
      "author": "peteroupc",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Consider whether the strategy mentioned in \"[A fast alternative to the modulo reduction](https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/)\", by @Lemire , is useful to mention as an alternative to the \"mod p\" in the hash_to_base function in the draft, and possibly elsewhere a mod operation appears in that draft.  This alternative is especially worth mentioning if the alternative&mdash;\r\n\r\n- can be implemented in constant time, similarly to modulo reduction, and\r\n- has similar or better performance to modulo reduction.",
      "createdAt": "2019-11-12T17:06:50Z",
      "updatedAt": "2020-01-28T18:49:51Z",
      "closedAt": "2019-11-16T21:18:45Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the suggestion!\r\n\r\nThis document will not be a resource for fast arithmetic strategies, so probably the above trick is out of scope.\r\n\r\nMoreover, unless I'm badly misunderstanding something, in this document's context the above trick is not likely to be helpful. The reason is that p is essentially always going to be at least a couple hundred bits, whereas this trick is fast precisely because it's taking advantage of the fact that word-sized multiplication is cheap (From the article: \"Computing (x * N) div 2^32 is very fast on a 64-bit processor.\")\r\n\r\nIf people tended to use elliptic curves over extension fields p^k for p a 32-bit integer, this might be something to consider. But to my knowledge there are no such curves in widespread use today---and curves over those fields are believed to be less secure, so this isn't likely to change in the future.\r\n\r\nI'm closing this issue; please feel free to reopen and provide some more background if I've misunderstood something.",
          "createdAt": "2019-11-16T21:18:45Z",
          "updatedAt": "2019-11-16T21:20:13Z"
        },
        {
          "author": "peteroupc",
          "authorAssociation": "NONE",
          "body": "Letting D. Lemire know about this.\r\n\r\n@Lemire : You were the one that suggested this strategy; please weigh in.\r\n",
          "createdAt": "2019-11-16T21:30:58Z",
          "updatedAt": "2019-11-16T21:30:58Z"
        },
        {
          "author": "peteroupc",
          "authorAssociation": "NONE",
          "body": "There is one aspect that's important to note here: The \"constant-time\" aspect.\r\n\r\n@lemire said the following in briansmith/ring#942 :\r\n\r\n> Division instructions often reveal something about their inputs in that their running times vary based on the input. (Of course, this depends on the hardware.)\r\n\r\nThe \"main\" hash-to-base method uses a mod operation, which has to be implemented in constant time like the rest of the method.  Especially since this document is not meant to give guidance on how to implement operations in constant time, it is likely that an implementor of these methods will use the simple \"%\" operator (or its equivalent) without realizing that the operator's implementation (under the hood) might not be \"constant-time\" in all relevant hardware. (Note that generally, the \"%\" operator includes division.)\r\n\r\nAlthough I am aware that mod can be implemented using a multiplication by a multiplicative inverse together with other operations, this seems to me to have no big advantage over the \"multiply-then-shift\" strategy I suggest here, especially since the hash_to_base method is the only method in the draft where the \"mod\" operation appears -- for example, the line:\r\n\r\n     6.   e_i = OS2IP(tv) mod p\r\n\r\n...could be replaced with:\r\n\r\n    6.   e_i = (OS2IP(tv) * p) >> bits\r\n",
          "createdAt": "2020-01-28T16:55:01Z",
          "updatedAt": "2020-01-28T16:55:01Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks again for the comment. A few responses (apologies for the bulleted list; it's for clarity, not to be brusque):\r\n\r\n1. This document does not deal with low-level details of field arithmetic. These details are useful! but this is not the place to do it. Other documents exist for this purpose, and I have no doubt that their authors spent considerable time writing them.\r\n\r\n2. The document linked from the first comment does not deal with multi-precision arithmetic---it's an optimization for doing modular reduction for word-sized integers, which is not relevant in this context. (Generalizing this trick to multi-precision arithmetic reconstructs something vaguely similar to Montgomery modular reduction. So it's a cool observation, but it is already well known by practitioners.)\r\n\r\n3. You are right that `%` is generally not constant time. In most programming languages, however, the `%` operator is defined for native integer types, not for multi-precision types---so it's *not possible* to use `%` in hash-to-base.\r\n\r\n    There are some languages---like Python---where integers are natively multi-precision. But *no* native integer operations are (guaranteed to be) constant-time in Python! so the suggested multiply-and-shift approach also does not yield a constant-time implementation. This is generally true, to my knowledge, for mainstream programming languages that have native multi-precision types.\r\n\r\n4. This document is intended for use in a context where one already has working elliptic curve operations, which underneath *require* field operations (and thus, reduction mod p). Requiring the use of a different, incompatible strategy for selecting a random element mod p doesn't make sense when the intended audience of this document *must* already have suitable code available.\r\n\r\n5. Related to the prior point, the following is false:\r\n\r\n    > the hash_to_base method is the only method in the draft where the \"mod\" operation appears\r\n\r\n     The reason it's false is that every elliptic curve operation implicitly requires many reductions mod p.\r\n\r\nI understand and appreciate the desire to make this document useful to the broadest possible audience, and to the extent this is possible we're happy to do it. But what's suggested here does not do that: for novice implementors the suggested level of detail is insufficient, while for experienced ones it's unnecessary.",
          "createdAt": "2020-01-28T18:49:50Z",
          "updatedAt": "2020-01-28T18:49:50Z"
        }
      ]
    },
    {
      "number": 195,
      "id": "MDU6SXNzdWU1MjU0NjczNTQ=",
      "title": "Montgomery / Weierstrass inconsistency in Twisted Edwards section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/195",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@armfazh points out that there's an inconsistency that we probably want to address in the \"Rational maps from Montgomery to twisted Edwards curves\" section: it talks about Montgomery and Long Weierstrass curves interchangeably, which could be confusing.\r\n\r\n[link to @armfazh's comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/189#discussion_r348238478) and [my follow-up](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/189#discussion_r348284336).\r\n\r\nOne way to address this is to split the \"Long Weierstrass to Edwards\" map into its own section, and make explicit everywhere that the Edwards mapping works for either one. I like this approach because it lets us keep talking about equivalent *Montgomery* curves when such curves are standardized (as I mentioned in my post linked above, I think this makes more explicit the kind of reusability we're aiming for).\r\n\r\nIt might be more consistent to always talk about Montgomery or always talk about Weierstrass. We should think about this to try and understand whether this can be made clean and clear; it's not obvious to me right now.",
      "createdAt": "2019-11-20T04:27:50Z",
      "updatedAt": "2020-03-03T18:57:29Z",
      "closedAt": "2020-03-03T18:57:29Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Another approach would be to take @armfazh's suggestion from #189: remove all use of Long Weierstrass from the document, build the Weierstrass-to-Montgomery conversion into the Elligator 2 description, and then *only* deal with Montgomery and Twisted Edwards curves in this section.\r\n\r\nCome to think of it, that probably works quite nicely. Happy to take a crack at this if y'all like this approach.",
          "createdAt": "2019-11-20T04:41:28Z",
          "updatedAt": "2019-11-20T04:41:28Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "(cc @armfazh @chris-wood )",
          "createdAt": "2019-11-20T04:41:43Z",
          "updatedAt": "2019-11-20T04:41:43Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, one more thought: ell2C0 might require a bit more care if we do elligator purely in terms of Montgomery curves. But we can have the \"change of variables\" live only at that spot in the document, which is anyway not going to be particularly popular I'd guess.",
          "createdAt": "2019-11-20T04:58:32Z",
          "updatedAt": "2019-11-20T04:58:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> build the Weierstrass-to-Montgomery conversion into the Elligator 2 description\r\n\r\nI'm not sure I follow this suggestion -- @kwantam, could you elaborate?",
          "createdAt": "2019-11-20T10:23:05Z",
          "updatedAt": "2019-11-20T10:23:05Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Right now, the Elligator2 description is written for Weierstrass curves\r\n\r\n~~~\r\n    Y^3 = X^3 + C * X^2 + D * X            (1)\r\n~~~\r\n\r\nThen, for Montgomery curves, i.e.,\r\n\r\n~~~\r\n    K * t^2 = s^3 + J * s^2 + s            (2)\r\n~~~\r\n\r\nwe give a change of variables that converts from form (2) to form (1).\r\n\r\nWe could rewrite the Elligator2 map to deal directly with form (2), basically by modifying the map so that the change of variables is just built into its description. Mechanically, this would involve changing a couple of the constants and adding two extra multiplications at the end of the mapping function.\r\n\r\nI think probably this *would* be a clarity improvement overall---fewer moving parts for the reader to keep track of.\r\n\r\n(EDIT: I think I'd prefer to land #189 and then do this in a separate PR, though.)",
          "createdAt": "2019-11-20T17:28:22Z",
          "updatedAt": "2019-11-20T17:29:45Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> Another approach would be to take @armfazh's suggestion from #189: remove all use of Long Weierstrass from the document,\r\n\r\nI consider the document must focus more on mappings for curves Montgomery and TEdwards curves. So we provide descriptions of mappings that solve this problem.\r\nSo here is a possible way to do it.\r\n\r\nFor Montgomery curves M: \r\n\r\n> We could rewrite the Elligator2 map to deal directly with form (2), basically by modifying the map so that the change of variables is just built into its description. Mechanically, this would involve changing a couple of the constants and adding two extra multiplications at the end of the mapping function.\r\n\r\nI would add a comment saying that some multiplications can be saved since K=1 (the coefficient of y^2 in a Montgomery curve).\r\n\r\nFor TEdwards curves E:\r\n\r\n```vb\r\nif `E` in {edwards25519,edwards448}\r\n    `map` is set to M -> E from RFC7748.\r\n    (X,Y) = elligator2(u)\r\n    (v,w) = map(X,Y)\r\nelse    \r\n    `map` is set to W -> E ( where W is the long Weiestrass curve required by elligator2)\r\n    `map2` is the composition of elligator2 and `map`. \r\n    // In the document, we only describe map2 as a general solution for TEdwards.\r\n    (v, w) = map2(u)\r\nend if\r\nreturn  (v, w)\r\n```\r\n\r\n",
          "createdAt": "2019-11-20T21:07:09Z",
          "updatedAt": "2019-11-20T21:07:09Z"
        }
      ]
    },
    {
      "number": 199,
      "id": "MDU6SXNzdWU1NTA5MDgzNTU=",
      "title": "Update to Python 3",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/199",
      "state": "CLOSED",
      "author": "mratsim",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Python 2 has been end-of-life'd on January 1st 2020 and is not supported anymore.\r\n\r\nCurrently the codebase relies on Python 2: https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/blob/6cf7fa9742e2f85f5ee6454861afd462e38d4230/poc/hash_to_base.py#L11-L12\r\n\r\nBesides this line there are issue with `xrange` and byte strings being detected as Unicode objects.\r\n\r\nI'm not familiar with Sagemath but according to this ticket all internal Sagemath tests are passing since 2 weeks ago: https://trac.sagemath.org/ticket/26212.\r\nThe other meta-issues have not been updated for more than a year and are probably stale (https://trac.sagemath.org/ticket/15980 / https://trac.sagemath.org/ticket/16052)\r\n",
      "createdAt": "2020-01-16T16:12:45Z",
      "updatedAt": "2020-01-22T02:17:32Z",
      "closedAt": "2020-01-22T02:17:32Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @mratsim! We'll update the code ASAP. (PRs are also welcome and appreciated, if you feel so inclined. :))",
          "createdAt": "2020-01-20T22:42:42Z",
          "updatedAt": "2020-01-20T22:42:42Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I have a TODO to fix this. I will try to get to it this week.\r\n\r\nUnfortunately, we cannot deprecate Python2 in this code, because many people will continue to use Sage 8.x, which is built on Python2, for the forseeable future---it's in Ubuntu LTS, for example. This may make the fixes slightly more annoying, but I'm hopeful it won't be too bad.",
          "createdAt": "2020-01-20T23:28:51Z",
          "updatedAt": "2020-01-20T23:28:51Z"
        }
      ]
    },
    {
      "number": 200,
      "id": "MDU6SXNzdWU1NTEzNjkxMzc=",
      "title": "Null-terminated (octet) strings for message and Domain-Separation Tag",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/200",
      "state": "CLOSED",
      "author": "mratsim",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Linked to https://github.com/ethereum/eth2.0-specs/issues/1576\r\n\r\nThe current spec uses the terms `strings`, `bit string`, `octet string` however their representation is not explained.\r\nIn particular the ``hash_to_curve`` section does not mention that the message should be terminated by a null byte but the reference implementation does append a null byte:\r\n\r\nImplementation\r\n\r\nhttps://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/blob/6cf7fa9742e2f85f5ee6454861afd462e38d4230/poc/hash_to_base.py#L59-L67\r\n\r\nSpec\r\n\r\n```\r\nhash_to_base(msg, ctr)\r\n\r\nParameters:\r\n- DST, a domain separation tag (see discussion above).\r\n- H, a cryptographic hash function.\r\n- F, a finite field of characteristic p and order q = p^m.\r\n- p, the characteristic of F (see immediately above).\r\n- m, the extension degree of F, m >= 1 (see immediately above).\r\n- L = ceil((ceil(log2(p)) + k) / 8), where k is the security\r\n  parameter of the cryptosystem (e.g., k = 128).\r\n- HKDF-Extract and HKDF-Expand are as defined in RFC5869,\r\n  instantiated with the hash function H.\r\n\r\nInputs:\r\n- msg is the message to hash.\r\n- ctr is 0, 1, or 2.\r\n  This is used to efficiently create independent\r\n  instances of hash_to_base (see discussion above).\r\n\r\nOutput:\r\n- u, an element in F.\r\n\r\nSteps:\r\n1. msg_prime = HKDF-Extract(DST, msg || I2OSP(0, 1))\r\n2. info_pfx = \"H2C\" || I2OSP(ctr, 1)   # \"H2C\" is a 3-byte ASCII string\r\n3. for i in (1, ..., m):\r\n4.   info = info_pfx || I2OSP(i, 1)\r\n5.   tv = HKDF-Expand(msg_prime, info, L)\r\n6.   e_i = OS2IP(tv) mod p\r\n7. u = (e_1, ..., e_m)\r\n8. return u\r\n```\r\n\r\nAssuming a message MUST be terminated by a null-byte. Does that also apply to the Domain Separation Tag?",
      "createdAt": "2020-01-17T11:44:23Z",
      "updatedAt": "2020-02-24T02:41:47Z",
      "closedAt": "2020-02-24T02:41:47Z",
      "comments": [
        {
          "author": "mratsim",
          "authorAssociation": "NONE",
          "body": "Thanks to the attentive eye of @benjaminion in https://github.com/ethereum/eth2.0-specs/issues/1576, this has been clarified from [Section 5.1 Security consideration](https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-05#section-5.1)\r\n\r\n> Finally, hash_to_base appends one zero byte to msg in the invocation\r\n> of HKDF-Extract.  This ensures that the use of HKDF in hash_to_base\r\n> is indifferentiable from a random oracle (see [LBB19], Lemma 8 and\r\n> [DRST12], Theorems 4.3 and 4.4).  (In particular, this approach works\r\n> because it ensures that the final byte of each HMAC invocation in\r\n> HKDF-Extract and HKDF-Expand is distinct.)\r\n\r\nThis security null-byte is missing in the implementation steps.\r\nSome clarification about string/bit-string/octet-string representation (i.e. not needing a null byte in the general case) could be helpful as well.",
          "createdAt": "2020-01-17T13:17:56Z",
          "updatedAt": "2020-01-17T13:17:56Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> This security null-byte is missing in the implementation steps.\r\n\r\nIs this true? The code below appends a single byte (0x00) to `msg`:\r\n\r\n```\r\nmsg_prime = hkdf_extract(dst, msg + '\\x00', hash_fn) \r\n```",
          "createdAt": "2020-01-20T22:45:28Z",
          "updatedAt": "2020-01-20T22:45:28Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> In particular the `hash_to_curve` section does not mention that the message should be terminated by a null byte but the reference implementation does append a null byte:\r\n\r\nSorry, that does not appear to be true:\r\n\r\n> Spec\r\n> \r\n> ```\r\n> 1. msg_prime = HKDF-Extract(DST, msg || I2OSP(0, 1))\r\n> ```\r\n\r\nNotice that the second argument to HKDF-Extract is `msg || I2OSP(0, 1)`. This is consistent with the text you quoted from Section 5.1.",
          "createdAt": "2020-01-20T23:20:59Z",
          "updatedAt": "2020-01-20T23:25:53Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "But: thank you for pointing out that we're not precise enough when we call `msg` a \"string.\" We should say octet-string.",
          "createdAt": "2020-01-20T23:26:13Z",
          "updatedAt": "2020-01-20T23:26:13Z"
        },
        {
          "author": "mratsim",
          "authorAssociation": "NONE",
          "body": "Ah I see I didn't associate ``I2OSP(0, 1)`` with the nul-byte",
          "createdAt": "2020-01-21T08:01:48Z",
          "updatedAt": "2020-01-21T08:01:48Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I propose to change the 0x00 (zero-byte marker) for any other non-zero byte constant. Because it can be confused with null terminating strings (like in C, or in this issue), and also because the value of the marker does not play role in security, other than ->\r\n\r\n> (In particular, this approach works because it ensures that the final byte of each HMAC invocation in HKDF-Extract and HKDF-Expand is distinct.",
          "createdAt": "2020-01-24T21:59:08Z",
          "updatedAt": "2020-01-24T21:59:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I propose to change the 0x00 (zero-byte marker) for any other non-zero byte constant.\r\n\r\nDo we have any other 0x00 markers outside of the one in `hash_to_base`?\r\n",
          "createdAt": "2020-01-25T13:52:47Z",
          "updatedAt": "2020-01-25T13:52:47Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "0x00 is not an arbitrary choice, it's the only value that makes the\nindifferentiability proof go through. Changing it to another value is\ntherefore not a good idea.\n\nBut this discussion is moot, because we should just replace this\nhash-to-base design with the strictly better one in #202.\n",
          "createdAt": "2020-01-25T14:47:10Z",
          "updatedAt": "2020-01-25T14:47:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> 0x00 is not an arbitrary choice,\r\n\r\nI don't think @armfazh meant to imply otherwise -- he pointed towards its role in differentiating HMAC invocations.  ",
          "createdAt": "2020-01-25T15:01:28Z",
          "updatedAt": "2020-01-25T15:01:28Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "You're right---apologies for being unclear!\n\nI was responding to the claim that it doesn't play a role in security; this\nis false.\n\n(Sorry for clipped responses. I'm writing from my phone.)\n",
          "createdAt": "2020-01-25T15:05:56Z",
          "updatedAt": "2020-01-25T15:05:56Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh are you good to close this?",
          "createdAt": "2020-02-16T01:22:05Z",
          "updatedAt": "2020-02-16T01:22:05Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood @armfazh closing since #202 should obsolete this issue. Please feel free to reopen if we need to discuss this further.",
          "createdAt": "2020-02-24T02:41:47Z",
          "updatedAt": "2020-02-24T02:41:47Z"
        }
      ]
    },
    {
      "number": 202,
      "id": "MDU6SXNzdWU1NTM2Mzk1MjI=",
      "title": "hash-to-base issues",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/202",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "EDIT: Please see [this comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/202#issuecomment-577864753) for a summary of the proposed changes.\r\n\r\n---\r\n\r\nSorry to reopen this can of worms, but I think there are a couple reasons to worry about the current version of hash-to-base.\r\n\r\n1. @BjoernMHaase points out that, for embedded systems, hashing can be much more expensive than field or curve operations. The reason is, hashing is done on the main (sometimes 8-bit!) processor, whereas field and curve operations use a specialized co-processor. The result is that, in his CPace implementation, he doesn't want to use our version of hash-to-base.\r\n\r\n    It seems reasonable to expect this to be an issue for several classes of hash-to-curve applications. I think we should be responsive to it, and come up with a simplified version of hash-to-base that's safe in this context.\r\n\r\n2. @reyzin points out that in the VRF draft they were very careful to make sure that all invocations of SHA-2 are domain separated, but our use of H in hash-to-base is incompatible with this. In fact, we sat down and talked through it yesterday, and there does not appear to be a safe and cheap way of domain separating uses of H outside of hash-to-base from its uses inside. The only way to do it appears to be to select a random, 32-byte string (e.g., by hashing a domain separation tag) and prepending that value to every use of H outside of hash-to-base.\r\n\r\n    This is really unsatisfying: first, it adds an extra invocation of the compression function, which is bad in resource-constrained contexts (per (1), above). Second, it means that domain separation requirements \"escape\" the hash-to-curve draft, in the sense that implementors need to understand how hash-to-curve uses H in order to safely reuse H in upper-layer protocols---an abstraction violation.\r\n\r\n3. We've heard from several people that they want to use SHA3, and our version of hash-to-base is overdesigned for this purpose. I don't care so much about overdesign in itself---it would be great if we could have a one size fits all version of hash-to-base---but given issues 1 and 2, we have an opportunity to revisit.\r\n\r\nI'm working on a couple proposals to fix this, one based on KMAC (or perhaps SHAKE) and one that's designed to be safe (including in the sense of (2) above) and efficient for Merkle-Damgaard functions (but should also be safe and efficient for SHA-3). For now I'm not proposing a specific course of action, just giving early warning that this is an issue we should think carefully about.",
      "createdAt": "2020-01-22T16:05:32Z",
      "updatedAt": "2020-02-28T22:45:16Z",
      "closedAt": "2020-02-28T22:45:16Z",
      "comments": [
        {
          "author": "BjoernMHaase",
          "authorAssociation": "NONE",
          "body": "Hi to all,\n\nI see a larger class of PAKE protocols to be the natural \"users\" of the\nresults of your work. As pointed out also in RFC8125, one aspect to\nconsider is also side-channel resistance beyond constant-time execution,\nspecifically, if smart-card based implementations are to be recommended\nin hostile environment.\n\nLast week during the breaks of the brainpool meeting, I had some\ndiscussion with people with more expertise on secure elements than I am\nhaving, specifically people from NXP and Infineon and BSI people.\n\nWhat I took with me from the discussions is,\n\n1) the major concern with the hash function use might be, that\nsmart-card based protected/masked implementations of hash functions are\nnot commonly available in hardware and their use is to be avoided in\nprotocols that require side-channel protections.\n\n2) Their recommendation was to give preference to constructions based on\nSPN-based block ciphers, where possible. They mentioned, e.g., the PRF\noperation required for expanding secrets.\n\n3) SHA3 might be easier to protect, but today also this algorithm, which\nis better prepared for SPA protections than Merkle-Damgard\nconstructions, but also there platforms with a protected implementation\nare not commonly available today.\n\n4) Expanding the inputs to twice the base field size might be a good\nidea. Some secure-element implementations seem to use randomization the\nbase field representations (by adding multiples of the prime). This\npossibly could provide one component for protecting the Map2Point base\nfield arithmetics against SPA.\n\nI have asked several smart card expert people to post an assessment or\nrecommendation on the CFRG list, but I fear that their company policies\nwon't allow for such contribution.\n\nA second aspect that I noticed in the current hash2curve draft is the\nmandatory co-factor blinding already on the hash2curve level.\n\nWhile Elligator2 returns the point in affine coordinates. (See e.g. the\npost from Mike Hamburg from 2017\nhttps://moderncrypto.org/mail-archive/curves/2017/000939.html)\n\nAfter co-factor blinding, the point will be represented in some\nprojective coordinate system. The cost of this corresponds to an\nadditional base field inversion. Citing again Mike Hamburg from his 2017\npost,\n\n\"The projective ladder requires one more register (Z0) and is slower if you have a dedicated\nsquaring algorithm.  It\u2019s faster [than a variant with inversion and an affine ladder]\nif you\u2019re using multiply as square.\"\n\nYours,\n\nBj\u00f6rn\n\nAm 22.01.2020 um 17:05 schrieb Riad S. Wahby:\n>\n> Sorry to reopen this can of worms, but I think there are a couple\n> reasons to worry about the current version of hash-to-base.\n>\n> 1.\n>\n>     @BjoernMHaase <https://github.com/BjoernMHaase> points out that,\n>     for embedded systems, hashing can be much more expensive than\n>     field or curve operations. The reason is, hashing is done on the\n>     main (sometimes 8-bit!) processor, whereas field and curve\n>     operations use a specialized co-processor. The result is that, in\n>     his CPace implementation, he doesn't want to use our version of\n>     hash-to-base.\n>\n>     It seems reasonable to expect this to be an issue for several\n>     classes of hash-to-curve applications. I think we should be\n>     responsive to it, and come up with a simplified version of\n>     hash-to-base that's safe in this context.\n>\n> 2.\n>\n>     @reyzin <https://github.com/reyzin> points out that in the VRF\n>     draft they were very careful to make sure that all invocations of\n>     SHA-2 are domain separated, but our use of H in hash-to-base is\n>     incompatible with this. In fact, we sat down and talked through it\n>     yesterday, and there does not appear to be a safe and cheap way of\n>     domain separating uses of H outside of hash-to-base from its uses\n>     inside. The only way to do it appears to be to select a random,\n>     32-byte string (e.g., by hashing a domain separation tag) and\n>     prepending that value to every use of H outside of hash-to-base.\n>\n>     This is really unsatisfying: first, it adds an extra invocation of\n>     the compression function, which is bad in embedded contexts.\n>     Second, it means that domain separation requirements \"escape\" the\n>     hash-to-curve draft, in the sense that implementors need to\n>     understand how hash-to-curve uses H in order to safely reuse H in\n>     upper-layer protocols---an abstraction violation.\n>\n> 3.\n>\n>     We've heard from several people that they want to use SHA3, and\n>     our version of hash-to-base is overdesigned for this purpose. I\n>     don't care so much about overdesign in itself---it would be great\n>     if we could have a one size fits all version of hash-to-base---but\n>     given issues 1 and 2, we have an opportunity to revisit.\n>\n> I'm working on a couple proposals to fix this, one based on KMAC (or\n> perhaps SHAKE) and one that's designed to be safe for Merkle-Damgaard\n> functions (but should also be safe and efficient for SHA-3). For now\n> I'm not proposing a specific course of action, just giving early\n> warning that this is an issue we should think carefully about.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/202?email_source=notifications&email_token=ADMGYAHTPLA7HYE2KUA6UI3Q7BVE3A5CNFSM4KKIKOM2YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4IH73ZRA>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/ADMGYAB4IJIAXE2PNLERVADQ7BVE3ANCNFSM4KKIKOMQ>.\n>\n",
          "createdAt": "2020-01-22T17:14:17Z",
          "updatedAt": "2020-01-22T17:14:17Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the comments, Bj\u00f6rn! A few quick responses below.\r\n\r\n- The suggestions you make for protecting against side channels are excellent, but probably are out of scope for this draft. Of course, anyone is welcome to implement randomized projective coordinates, randomized field element representations, etc.! But probably a separate draft giving guidance on these strategies would be more useful than trying to put them into this draft---especially since these countermeasures are mostly generic, not hash-to-curve--specific.\r\n\r\n- Extracting with a hash function and then expanding with a PRF is a perfectly reasonable strategy in general. It seems worthwhile for us to suggest this as an alternative to the approach or approaches that the document specifies, but I can't promise that we will give a detailed specification of such an approach.\r\n\r\nI will keep thinking about this.",
          "createdAt": "2020-01-22T21:51:45Z",
          "updatedAt": "2020-01-22T21:51:45Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's a skeletal proposal for a simplified approach to hash-to-field.\r\n\r\nAt a high level, this proposal splits hash-to-field into two steps:\r\n\r\n1. Generate a pseudorandom byte string based on the message and domain separation tag.\r\n\r\n2. Interpret this byte string as one or more elements of F = GF(p^m).\r\n\r\nNote that this is a departure from the current approach: in the above, hash-to-field can return *multiple* field elements in one call. This means that both hash-to-curve and encode-to-curve will call hash-to-field *exactly once*, but will request either one (encode-) or two (hash-) field elements.\r\n\r\nThere are three reasons for this change: first, it minimizes the number of hash function invocations, which is one of the explicit goals of this redesign. Second, it simplifies drop-in use of any hash function in the SHA-2 or SHA-3 family, meaning that we do not have to specify a different hash-to-field function to use, say, SHAKE128. Third, it makes drop-in use of block cipher--based expansion easy (though, per my prior comment, I do not necessarily advocate specifying here).\r\n\r\nHere's the new proposed hash-to-field function:\r\n\r\n~~~\r\nhash_to_field(msg, count)\r\n\r\nParameters:\r\n- DST, a domain separation tag.\r\n- F, a finite field of characteristic p and order q = p^m.\r\n- p, the characteristic of F.\r\n- m, the extension degree of F, m >= 1.\r\n- L = ceil((ceil(log2(p)) + k) / 8), where k is the security parameter.\r\n- expand_message, a function that takes a message, DST, and number of\r\n  bytes and outputs that number of pseudorandom bytes.\r\n\r\nInput:\r\n- msg is the message to hash.\r\n- count is the number of elements of F to output.\r\n\r\nOutputs:\r\n- (u_0, ..., u_(count - 1)), count field elements.\r\n\r\nSteps:\r\n1. prb_length = count * m * L\r\n2. pseudo_random_bytes = expand_message(msg, DST, count * m * L)\r\n3. for i in (0, ..., count - 1):\r\n4.   for j in (0, ..., m - 1):\r\n5.     elm_offset = L * (j + i * m)\r\n6.     tv = pseudo_random_bytes[elm_offset : elm_offset + L]\r\n7.     e_i = OS2IP(tv) mod p\r\n8.   u_i = (e_0, ..., e_(m - 1))\r\n9. return (u_0, ..., u_(count - 1))\r\n~~~\r\n\r\nIn subsequent comments I'll discuss options for the `expand_message` function.",
          "createdAt": "2020-01-22T22:24:17Z",
          "updatedAt": "2020-01-22T22:24:17Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Now we just have to specify an `expand_message` function.\r\n\r\nWe can easily build one based on SHAKE128:\r\n\r\n~~~\r\nexpand_message_shake128(msg, DST, len_in_bytes)\r\n\r\nInput:\r\n- msg, an octet string\r\n- DST, an octet string\r\n- len_in_bytes, length of requested output in octets\r\n\r\nOutput:\r\n- pseudo_random_bytes, an octet string\r\n\r\nSteps:\r\n1. msg_prime = DST || I2OSP(len_in_bytes, 2) || msg\r\n2. return SHAKE128(msg_prime, 8 * len_in_bytes)\r\n~~~\r\n\r\n(Note that the length argument to SHAKE128, per FIPS 202, is in *bits*.)\r\n\r\nSHAKE256 is analogous, of course.",
          "createdAt": "2020-01-22T22:30:05Z",
          "updatedAt": "2020-01-22T22:30:34Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "How about SHA-2? Here we have to be careful, since SHA-2 is a Merkle-Damgaard construction and is thus *not* itself indifferentiable from a random oracle, even if we assume that the underlying compression function is a random oracle. (This relates to well-known length extension attacks, multi-collision attacks, etc., on M-D constructions.)\r\n\r\nNote, however, that the value `expand_message` returns to `hash_to_field` isn't exposed to `hash_to_field`'s caller. Instead, it's cut into (log(p)+k)-bit chunks, which are reduced mod p. We can use this fact to our advantage!\r\n\r\nIn particular, while I haven't yet written down a full proof, it looks very likely that we can build on existing analyses of chop-MD ([1](https://cs.nyu.edu/~dodis/ps/merkle.pdf), [2](https://link.springer.com/chapter/10.1007/978-3-540-71039-4_27), [3](http://www.di.ens.fr/~fouque/pub/csf12.pdf), i.e., constructions like SHA512/256) to show that reducing a (log(p)+k)-bit integer mod p suffices for indifferentiability. Intuitively, the reason is that the same k extra bits we're using to get a near-uniform element of GF(p) also suffice to prevent length extensions, etc.\r\n\r\n~Here's the proposed function:~\r\n\r\nEDIT: removing this version, because it's not quite strong enough. I'll post a new one below.",
          "createdAt": "2020-01-22T22:59:08Z",
          "updatedAt": "2020-01-23T17:28:26Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "EDIT: I vote **not** to specify this function in the hash-to-curve draft. Please regard this comment as spitballing only.\r\n\r\n---\r\n\r\nIf we really wanted to specify something based on a ctr-mode cipher, we could do something like this:\r\n\r\n~~~\r\nexpand_message_ctr(msg, DST, len_in_bytes)\r\n\r\nParameters:\r\n- E, a block cipher encryption function taking kE-bit keys and bE-bit blocks.\r\n- bE, the block size of E.\r\n- kE, the key length of E.\r\n- H, a hash function that outputs at least kE + bE + k bits, for security parameter k.\r\n\r\nInput and output: same as above\r\n\r\nSteps:\r\n1.  ell = (len_in_bytes * 8) / bE\r\n2.  ABORT if ell > 255\r\n3.  msg_prime = H(DST || I2OSP(ell, 1) || msg)\r\n4.  eKey = first kE bits of msg_prime\r\n5.  eCtr = next kB bits of msg_prime\r\n6.  ctr = OS2IP(eCtr)\r\n7.  for i in (0, ..., ell - 1):\r\n8.    ctr = ctr + 1\r\n9.    b_i = E(eKey, I2OSP(ctr, kB / 8))\r\n10. pseudo_random_bytes = b_0 || ... || b_(ell - 1)\r\n11. return pseudo_random_bytes[0 : len_in_bytes]\r\n~~~\r\n\r\nOf course, it would be totally reasonable to replace the block cipher with a good stream cipher...\r\n\r\nSince we're throwing away k bits of H's output, it's safe to use a Merkle-Damgaard hash function. When using SHA-3, we can relax the requirement on H's output size to just kE + bE.\r\n\r\nFor collision resistance, we require that kE + bE > 2 * k. Note that by this definition AES-256 is only appropriate for k = 192, not for k = 256 (because the AES block size is small). There are ways to handle this (e.g., XOR the output of two independently-seeded AES-CTR PRGs).",
          "createdAt": "2020-01-22T23:10:29Z",
          "updatedAt": "2020-02-15T10:37:32Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, here's an improved version of `expand_message_md` along with a very brief sketch of the security argument.\r\n\r\nFor this construction, we require a hash function H whose output size in bits is at least 2 * k, for k the security parameter.\r\n\r\n~~~\r\nexpand_message_md(msg, DST, len_in_bytes)\r\n\r\nParameters:\r\n- H, a Merkle-Damgaard or Sponge-based hash function.\r\n- obs, the output block size of H in bytes.\r\n- k_in_bytes, ceil(k / 8) for k the security parameter, e.g,\r\n  for k = 128, k_in_bytes = 16.\r\n\r\nInput:\r\n- msg, an octet string.\r\n- DST, an octet string.\r\n- len_in_bytes, the length of the requested output in octets.\r\n\r\nOutput:\r\n- pseudo_random_bytes, an octet string.\r\n\r\nSteps:\r\n1. ell = ceil((len_in_bytes + k_in_bytes) / obs)\r\n2. ABORT if ell > 255\r\n3. b_0 = H(DST || I2OSP(0, 1) || I2OSP(ell, 1) || msg)\r\n4. for i in (1, ..., ell - 1):\r\n5.   b_i = H(DST || I2OSP(i, 1) || b_(i - 1))\r\n6. b_0_chopped = first (obs - k_in_bytes) bytes of b_0\r\n7. pseudo_random_bytes = b_0_chopped || b_1 || ... || b_(ell - 1)\r\n8. return pseudo_random_bytes[0 : len_in_bytes]\r\n~~~\r\n\r\n**In principle** one can skip chopping b_0 for functions in the SHA-3 family (or, more generally, for H with a reasonable indifferentiability proof). In practice, it's not clear to me whether the extra complexity is worthwhile. Thoughts?\r\n\r\n---\r\n\r\n### Security argument (sketch)\r\n\r\nWe argue security by composing existing security arguments for chop-MD and NMAC.\r\n\r\nIn particular, chop-MD that cuts off k bits of a hash whose output is at least 2 * k bits is indifferentiable from a random oracle with distinguishing advantage roughly Q / 2^-k, for an adversary making Q queries, paraphrasing [DFL12](http://www.di.ens.fr/~fouque/pub/csf12.pdf). Thus, the output `b_0_chopped` is indifferentiable from a RO with the same advantage.\r\n\r\nWe can view outputs `b_1` through `b_(ell - 1)` in two ways. Either we can regard them as a variant of the NMAC / HMAC^f instantiation due to Coron et al. [[CDMP05](https://cs.nyu.edu/~dodis/ps/merkle.pdf), Theorem 3.5], or we can simply notice that the length of inputs to H for all of these outputs is fixed and all calls to H are prefix-free (since they start `DST || 0`, `DST || 1`, ...). In either case, since the output size of H is at least 2 * k, we have from CDMP05 that the distinguishing advantage is roughly Q^2 / 2^(2 * k).\r\n\r\nNext, we can leverage the composability of indifferentiability to show that the concatenation of independent random oracle outputs is indifferentiable from a random oracle. The simulator is the trivial one.\r\n\r\nFinally, we need one more indifferentiability argument, namely, that chopping the \"big\" RO output into (log p + k)-bit chunks and reducing each one mod p is indifferentiable. Once again the simulator here is quite simple: for each field element, there is an equivalence class of roughly 2^k bit strings; the simulator simply picks one of these. This is indifferentiable for essentially the same reason that reducing a (log p + k)-bit value mod p gives a field element with statistical difference at most 2^-k from uniform.",
          "createdAt": "2020-01-23T20:12:16Z",
          "updatedAt": "2020-02-15T10:45:48Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, having worked through the above and thought carefully about this, I propose the following:\r\n\r\n1. Replace `hash_to_base` in the current spec with `hash_to_field` as defined [above](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/202#issuecomment-577414575).\r\n2. Specify [`expand_message_shake128` / `256`](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/202#issuecomment-577416556) and [`expand_message_md`](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/202#issuecomment-577855327), but *not* `expand_message_ctr`. The reason is that we don't want to encourage people to use another primitive, and we don't want to take on the burden of proving security for the `_ctr` construction.\r\n3. Update the suite naming scheme to include a field that specifies the expand_message variant and underlying hash function.\r\n\r\n~There's one dangling question for the `_md` construction: do we chop for SHA-3, or only for SHA-2? This is a question of slightly simpler spec vs. slightly more efficient implementation. My inclination is towards the simpler spec, but reasonable people can obviously disagree...~  **EDIT**: My vote is simplicity of specification. Always chop b0, even for SHA-3.\r\n\r\ncc @chris-wood @armfazh @grittygrease @samscott89",
          "createdAt": "2020-01-23T20:35:39Z",
          "updatedAt": "2020-02-15T10:43:31Z"
        },
        {
          "author": "BjoernMHaase",
          "authorAssociation": "NONE",
          "body": "Hello Riad,\n\nthank you for your effort and consideration. In think that the\ncomputational complexity and RAM requirement is reduced quite a bit with\nyour suggestion. Moreover, by using the SHAKE primitives there will be\n(IMO) a good path for providing future SPA secured implementations.\nMaybe not on all platforms available today, but maybe in the future (the\nSHA3 permutation is much more easily masked and protected than\nMerkle-Damgaard, as much as I understand).\n\nAlso one advantage side-channel wise of your construction is that the\nmessage input (of possibly low entropy in the PAKE context) is fed only\n*once* into the construction. For the presumably important P-256 case,\nyour expand operation would also boil down to only two SHA-256 hash\nfunction invocations (if I counted correctly), if only one single field\nelement is needed, e.g. for encode_to_curve().\n\nNote also that with this approach attempts for side-channel mitigations\n(as I have suggested, e.g. in the CPace draft with the 0-Padding after\nthe low-entropy secret input) could be implemented by just modifying the\nformat of the message field.\n\nWhat I will be doing is, I'll try to motivate some other people to\nreview your suggestion.\n\nAs final remark, I'd like to come up with one question. In case that the\nhash function output block length alone is sufficiently large for\ngenerating the required len_in_bytes amount of PRF bytes: Would you\nconsider it acceptable to just drop the \"chopping\" operation for b0 and\nuse all of the bytes of the b0 output? One might be sparing one\nadditional invocation of the hash. Heuristically, I think that one then\nmight want to add the len_in_bytes field to the initial hashing\noperation yielding b0, e.g. before the message. This way \"length\nextension type\" attacks are not manageble and using the message with\ndifferent lengths results always in different expanded messages, even if\nthe length is changed only by a small amount that does not modify the\nnumber of required blocks.\n\n(My question relates to the case of X25519, which is often used in\nconjunction with Ed25519 and SHA512, even if the security parameters are\nnot matching. An encode2curve operation for X25519 could possibly share\nall of field arithmetics and hash function implementation with Ed25519.\nIn this case only one single hash invocation of SHA512 would be required.)\n\nYours,\n\nBj\u00f6rn\n\n",
          "createdAt": "2020-01-23T21:31:20Z",
          "updatedAt": "2020-01-23T21:31:20Z"
        },
        {
          "author": "BjoernMHaase",
          "authorAssociation": "NONE",
          "body": "I did forget to add the note regarding the \"should one consider to drop\nthe chop operation if used in conjunction with SHA-3?\" topic.\n\nI'd advocate that people really focusing on efficiency would likely be\nusing a SHAKE128 or SHAKE256 construction instead? So maybe there is no\nreal justification for making the specification for sponges different\nfrom Merkle-Damgaard constructions.\n\n",
          "createdAt": "2020-01-23T21:37:04Z",
          "updatedAt": "2020-01-23T21:37:04Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> In case that the hash function output block length alone is sufficiently large for generating the required len_in_bytes amount of PRF bytes: Would you consider it acceptable to just drop the \"chopping\" operation for b0 and use all of the bytes of the b0 output? One might be sparing one additional invocation of the hash. Heuristically, I think that one then might want to add the len_in_bytes field to the initial hashing operation yielding b0, e.g. before the message. This way \"length extension type\" attacks are not manageble and using the message with different lengths results always in different expanded messages, even if the length is changed only by a small amount that does not modify the number of required blocks.\r\n\r\nUnfortunately, it is not safe to drop the chop operation for b0.\r\n\r\nIt *might* be safe to do this if we prepended `msg` with its length, e.g.:\r\n\r\n    b_0 = H(DST || I2OSP(0, 1) || I2OSP(ell, 1) || I2OSP(len(msg), 8) || msg)\r\n\r\n(But note I am only saying it *might*---I have not thought about it carefully enough to be sure.)\r\n\r\nThere are two reasons I didn't want to go this way: first, it's never obvious how long a field to make this. Surely 8 bytes is enough! But probably 4 isn't, since we could imagine hashing a couple gigabytes in some weird corner case. So now we need a pretty long field.\r\n\r\nSecond, the issue with needing to prepend `len(msg)` to `msg` is that it means we have to know the length of the message before we start hashing it! This is probably true in most usages, but it's not obviously true all the time.\r\n\r\n> (My question relates to the case of X25519, which is often used in conjunction with Ed25519 and SHA512, even if the security parameters are not matching. An encode2curve operation for X25519 could possibly share all of field arithmetics and hash function implementation with Ed25519. In this case only one single hash invocation of SHA512 would be required.)\r\n\r\nRight! But for X25519 or Ed25519, we have log2(p) = 255, k = 128, so this scheme would use 384 bits to generate one element of GF(p), and 512 - 128 = 384, so in fact even without modification you can use a single SHA512 invocation. And in the hash-to-curve (rather than encode-to-curve) case, you would need 2 SHA-512 invocations even if you didn't chop b_0.\r\n\r\n(Note that this isn't strictly true in the case of X25519, since we can get very close to uniform field elements by reducing 256 bits mod p since p is so close to 2^255. But I don't think we should add special cases for p of special forms, because it will complicate things considerably.)",
          "createdAt": "2020-01-23T22:04:24Z",
          "updatedAt": "2020-01-23T22:06:16Z"
        },
        {
          "author": "BjoernMHaase",
          "authorAssociation": "NONE",
          "body": "OK, I understand. It's the same topic as the notorious CBC-MAC issue. In\nfact, the approach that you have sketched would not at all generate\noverhead in comparison with\u00a0 \"dropping the chop\".\n\nIf your suggestion becomes consensus in the Hash2Curve team, I'd be\nmodifying the CPace and AuCPace drafts to use the hash2curve default\nconstructions. (e.g. maybe with the tweak of using SHA512 together with\nCurve25519).\n\n\nAm 23.01.2020 um 23:04 schrieb Riad S. Wahby:\n>\n>     In case that the hash function output block length alone is\n>     sufficiently large for generating the required len_in_bytes amount\n>     of PRF bytes: Would you consider it acceptable to just drop the\n>     \"chopping\" operation for b0 and use all of the bytes of the b0\n>     output? One might be sparing one additional invocation of the\n>     hash. Heuristically, I think that one then might want to add the\n>     len_in_bytes field to the initial hashing operation yielding b0,\n>     e.g. before the message. This way \"length extension type\" attacks\n>     are not manageble and using the message with different lengths\n>     results always in different expanded messages, even if the length\n>     is changed only by a small amount that does not modify the number\n>     of required blocks.\n>\n> Unfortunately, it is not safe to drop the chop operation for b0.\n>\n> It might be safe to do this if we prepended |msg| with its length, e.g.:\n>\n> |b_0 = H(DST || I2OSP(0, 1) || I2OSP(ell, 1) || I2OSP(len(msg), 8) ||\n> msg) |\n>\n> There are two reasons I didn't want to go this way: first, it's never\n> obvious how long a field to make this. Surely 8 bytes is enough! But\n> probably 4 isn't, since we could imagine hashing a couple gigabytes in\n> some weird corner case. So now we need a pretty long field.\n>\n> Second, the issue with needing to prepend |len(msg)| to |msg| is that\n> it means we have to know the length of the message before we start\n> hashing it! This is probably true in most usages, but it's not\n> obviously true all the time.\n>\n>     (My question relates to the case of X25519, which is often used in\n>     conjunction with Ed25519 and SHA512, even if the security\n>     parameters are not matching. An encode2curve operation for X25519\n>     could possibly share all of field arithmetics and hash function\n>     implementation with Ed25519. In this case only one single hash\n>     invocation of SHA512 would be required.)\n>\n> Right! But for X25519 or Ed25519, we have log2(p) = 255, k = 128, so\n> this scheme would use 384 bits to generate one element of GF(p), and\n> 512 - 128 = 384, so in fact even without modification you can use a\n> single SHA512 invocation. And in the hash-to-curve (rather than\n> encode-to-curve) case, you would need 2 SHA-512 invocations in any case.\n>\n> (Note that this isn't strictly true in the case of X25519, since we\n> can get very close to uniform field elements by reducing 256 bits mod\n> p since p is so close to 2^255. But I don't think we should add\n> special cases for p of special forms, because it will complicate\n> things considerably.)\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/202?email_source=notifications&email_token=ADMGYAB6MNAG4II6UCQSZR3Q7IH6TA5CNFSM4KKIKOM2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEJZAUFA#issuecomment-577899028>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/ADMGYAEOXOSZ7ABY3GDCZG3Q7IH6TANCNFSM4KKIKOMQ>.\n>\n",
          "createdAt": "2020-01-23T22:13:23Z",
          "updatedAt": "2020-01-23T22:13:23Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": ">  If your suggestion becomes consensus in the Hash2Curve team, I'd be modifying the CPace and AuCPace drafts to use the hash2curve default constructions. (e.g. maybe with the tweak of using SHA512 together with Curve25519).\r\n\r\nCool!\r\n\r\nBy the way, the VRF draft also wants to use Curve25519 with SHA-512 (for the same reason as you, I think---because Ed25519 uses this combination), so I plan to propose defining a suite for this use-case.",
          "createdAt": "2020-01-23T22:15:18Z",
          "updatedAt": "2020-01-23T22:15:18Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "Did you guys ever assess https://eprint.iacr.org/2019/1294.pdf by Koshelev Dmitrii? ",
          "createdAt": "2020-01-27T22:45:02Z",
          "updatedAt": "2020-01-27T22:45:02Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Did you guys ever assess https://eprint.iacr.org/2019/1294.pdf by Koshelev Dmitrii?\r\n\r\nUnless I'm misunderstanding, the above pertains to a new mapping, not to hash-to-base. So probably it would be better to discuss in its own issue.\r\n\r\nFirst impression: I doubt we'd include this map given that we've just removed other \"special-purpose\" maps (see #198), and this is another map that's restricted to a family of curves whose practical interest seems limited. But if this doesn't seem right---that is, if there are interesting reasons to have a map specifically for the j=1728 case---then please open a new issue about it and I'd be glad to chat more.",
          "createdAt": "2020-01-27T23:02:40Z",
          "updatedAt": "2020-01-27T23:02:40Z"
        },
        {
          "author": "peteroupc",
          "authorAssociation": "NONE",
          "body": "Has the following discussion been considered?  I believe some of the discussion there may be relevant to the hash_to_base function. sipa/bips#195",
          "createdAt": "2020-02-03T21:40:13Z",
          "updatedAt": "2020-02-03T21:40:13Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Has the following discussion been considered? I believe some of the discussion there may be relevant to the hash_to_base function. [sipa/bips#195](https://github.com/sipa/bips/issues/195)\r\n\r\nThanks for the pointer.\r\n\r\nIn the context of hash-to-curve, the answer is that there's no public or private inputs---that depends on the invoking protocol. Because of this, it looks to me like there's no way to handle this generically in hash-to-curve: this is a question for the higher-level protocols that invoke h2c.\r\n\r\nThat seem to imply, however, that it might be worthwhile to add some words in the Security Considerations section discussing this, so that invoking protocols are suitably cautious.\r\n\r\n---\r\n\r\nAs a second way of answering: h2c currently tries to help readers avoid *timing* leaks. Power side channels are not really in scope---and, related to what I've said above, it's not clear to me that they could ever be in scope in a generic way that defends all invoking protocols against attack. This also seems to imply the need for a pointer in Security Considerations, I think.",
          "createdAt": "2020-02-03T22:14:31Z",
          "updatedAt": "2020-02-03T22:18:19Z"
        },
        {
          "author": "BjoernMHaase",
          "authorAssociation": "NONE",
          "body": "\u00a0\n\n\nHello to all,\n\n\u00a0\n\n\nactually it was exactly the analysis of Niels Samwel that drove me to the suggestion for proposing the hash-to-base variant in https://tools.ietf.org/html/draft-haase-cpace-00.\n\n\u00a0\n\nYours,\n\n\u00a0\n\nBj\u00f6rn\n\n\nGesendet:\u00a0Montag, 03. Februar 2020 um 23:14 Uhr\nVon:\u00a0\"Riad S. Wahby\" <notifications@github.com>\nAn:\u00a0cfrg/draft-irtf-cfrg-hash-to-curve <draft-irtf-cfrg-hash-to-curve@noreply.github.com>\nCc:\u00a0BjoernMHaase <bjoern.m.haase@web.de>, Mention <mention@noreply.github.com>\nBetreff:\u00a0Re: [cfrg/draft-irtf-cfrg-hash-to-curve] hash-to-base issues (#202)\n\n\n\nHas the following discussion been considered? I believe some of the discussion there may be relevant to the hash_to_base function. sipa/bips#195\n\n\nThanks for the pointer.\n\nIn the context of hash-to-curve, the answer is that there's no public or private inputs---that depends on the invoking protocol. Because of this, it looks to me like there's no way to handle this generically in hash-to-curve: this is a question for the higher-level protocols.\n\nIt may, however, be worthwhile to add some words in the Security Considerations section discussing this.\n\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or unsubscribe.",
          "createdAt": "2020-02-03T22:43:23Z",
          "updatedAt": "2020-02-03T22:43:23Z"
        },
        {
          "author": "secunets",
          "authorAssociation": "NONE",
          "body": "Great discussion. Following closely to learn as much as possible and contribute at the right time. ",
          "createdAt": "2020-02-15T11:49:51Z",
          "updatedAt": "2020-02-15T11:49:51Z"
        }
      ]
    },
    {
      "number": 203,
      "id": "MDU6SXNzdWU1NTQ0MzcwMDQ=",
      "title": "add a suite for hashing to P-224?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/203",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the past we decided that we wouldn't add suites for curves under 128-bit security, because we didn't want to encourage people to use them. But it looks like we might want to add a suite for P-224, even though this violates that decision.\r\n\r\nThe reason I think we should at least discuss it is that, per a couple talks at Real World Crypto, both Google and Apple are using P-224, and in at least one of the talks someone specifically mentioned hashing to P-224.\r\n\r\nI realize this won't be so common going forward and also that adding a suite now doesn't help either Google's or Apple's usage, so I can see the argument against. Still, thought it was worth revisiting the decision in light of more-widespread-than-expected usage...\r\n\r\nThoughts? @chris-wood @armfazh @grittygrease",
      "createdAt": "2020-01-23T22:11:54Z",
      "updatedAt": "2020-01-27T03:24:13Z",
      "closedAt": "2020-01-27T03:24:13Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I consider we must add or give some guidance to anyone be able to create a suite. Otherwise, we must add any combination of {curve} x {hash} suite.\r\n",
          "createdAt": "2020-01-24T21:54:40Z",
          "updatedAt": "2020-01-24T21:54:40Z"
        },
        {
          "author": "randombit",
          "authorAssociation": "NONE",
          "body": "Having some guidance on adding additional curves would be useful IMO since there will inevitably be demand for supporting at least Brainpool and likely also ANSSI and SM2 curves in PAKEs.",
          "createdAt": "2020-01-24T22:07:09Z",
          "updatedAt": "2020-01-24T22:07:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "\ud83d\udc4d I think guidance would help. We probably don't need to fully specify something for P-224.",
          "createdAt": "2020-01-25T14:03:00Z",
          "updatedAt": "2020-01-25T14:03:00Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Cool! I'm convinced. Closing.",
          "createdAt": "2020-01-27T03:24:13Z",
          "updatedAt": "2020-01-27T03:24:13Z"
        }
      ]
    },
    {
      "number": 206,
      "id": "MDU6SXNzdWU1NjE1MDc5NjI=",
      "title": "Inconsistency with RFC7748/RFC8032",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/206",
      "state": "CLOSED",
      "author": "chjj",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "From what I understand, the isomorphism factor between a Twisted Edwards and Montgomery curve can be derived as `sqrt((A + 2) / (B * a))`, leaving two possible roots (the sign of which ultimately determines the sign of the point's x/v coordinates). In the case of Curve25519/Ed25519, the computation becomes `sqrt(-486664)`. For Elligator 2, the [draft][draft1] [currently says][draft2] to use a root such that `sgn0(sqrt(-486664)) == 1`. This seems to be inconsistent with the Curve25519/EdDSA RFCs as it does not preserve the base point's sign properly.\r\n\r\n[RFC7748] defines the Montgomery form of Curve25519 to have a base point of:\r\n\r\n```\r\nu = 9\r\nv = 14781619447589544791020593568409986887264606134616475288964881837755586237401\r\n```\r\n\r\nBoth [RFC7748] and [RFC8032] define the Twisted Edwards form of Curve25519 to have a base point of:\r\n\r\n```\r\nx = 15112221349535400772501151409588531511454012693041857206046113283949847762202\r\ny = 46316835694926478169428394003475163141307993866256225615783033603165251855960\r\n```\r\n\r\nThe two square roots of `-486664` are:\r\n\r\n```\r\n+sqrt(-486664) = 6853475219497561581579357271197624642482790079785650197046958215289687604742\r\n-sqrt(-486664) = 51042569399160536130206135233146329284152202253034631822681833788666877215207\r\n```\r\n\r\nInterestingly, neither of the above RFCs explicitly specify which root to use, but when I extract the isomorphism factor by comparing the above base points, I get the negative square root:\r\n\r\n```\r\nv * x / u = 51042569399160536130206135233146329284152202253034631822681833788666877215207\r\n```\r\n\r\nI think the specification should require the sign of `sqrt(-486664)` to be `-1`, not `1`.\r\n\r\nIn Sage:\r\n\r\n``` sage\r\nF = GF(2^255 - 19)\r\nu = F(9)\r\nv = F(14781619447589544791020593568409986887264606134616475288964881837755586237401)\r\nx = F(15112221349535400772501151409588531511454012693041857206046113283949847762202)\r\ny = F(46316835694926478169428394003475163141307993866256225615783033603165251855960)\r\nc = sqrt(F(-486664))\r\n\r\nprint(c)\r\nprint(-c)\r\nprint(c != v * x / u)\r\nprint(-c == v * x / u)\r\nprint(c * u / v != x)\r\nprint(-c * u / v == x)\r\n```\r\n\r\nOutputs:\r\n\r\n```\r\n6853475219497561581579357271197624642482790079785650197046958215289687604742\r\n51042569399160536130206135233146329284152202253034631822681833788666877215207\r\nTrue\r\nTrue\r\nTrue\r\nTrue\r\n```\r\n\r\n[draft1]: https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/blob/master/draft-irtf-cfrg-hash-to-curve.md#rational-maps-from-montgomery-to-twisted-edwards-curves-rational-map\r\n[draft2]: https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/blob/master/draft-irtf-cfrg-hash-to-curve.md#edwards25519-elligator-2-map-to-edwards25519\r\n[RFC7748]: https://tools.ietf.org/html/rfc7748#section-4.1\r\n[RFC8032]: https://tools.ietf.org/html/rfc8032#section-5.1",
      "createdAt": "2020-02-07T09:06:38Z",
      "updatedAt": "2020-02-24T02:39:23Z",
      "closedAt": "2020-02-24T02:39:23Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> [RFC7748](https://tools.ietf.org/html/rfc7748#section-4.1) defines the Montgomery form of Curve25519 to have a base point of:\r\n> \r\n> ```\r\n> u = 9\r\n> v = 14781619447589544791020593568409986887264606134616475288964881837755586237401\r\n> ```\r\n\r\nAre you aware of this change in the errata section?\r\nhttps://www.rfc-editor.org/errata/eid4730",
          "createdAt": "2020-02-07T18:26:00Z",
          "updatedAt": "2020-02-07T18:26:00Z"
        },
        {
          "author": "chjj",
          "authorAssociation": "NONE",
          "body": "> Are you aware of this change in the errata section?\r\n\r\nOh, I didn't catch that. Interesting. I guess this is not an issue after all. Feel free to close.",
          "createdAt": "2020-02-07T22:48:57Z",
          "updatedAt": "2020-02-07T22:48:57Z"
        }
      ]
    },
    {
      "number": 207,
      "id": "MDU6SXNzdWU1NjU1MDUyNTM=",
      "title": "Appendix D.1. bug",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/207",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "(xn, xd, yn, nd) = map_to_curve(u) should be (xn, xd, yn, yd) = map_to_curve(u)",
      "createdAt": "2020-02-14T19:09:08Z",
      "updatedAt": "2020-02-23T21:40:06Z",
      "closedAt": "2020-02-23T21:40:06Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #209.",
          "createdAt": "2020-02-23T21:40:06Z",
          "updatedAt": "2020-02-23T21:40:06Z"
        }
      ]
    },
    {
      "number": 210,
      "id": "MDU6SXNzdWU1NjU5Njc4MzU=",
      "title": "CMOV: inconsistency with Verifiable Random Functions draft",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/210",
      "state": "OPEN",
      "author": "mratsim",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The definition of CMOV in the draft is:\r\n\r\nhttps://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-05#section-4\r\n\r\n> CMOV(a, b, c): If c is False, CMOV returns a, otherwise it returns\r\n      b.  To prevent against timing attacks, this operation must run in\r\n      constant time, without revealing the value of c.  Commonly,\r\n      implementations assume that the selector c is 1 for True or 0 for\r\n      False.  In this case, given a bit string C, the desired selector c\r\n      can be computed by OR-ing all bits of C together.  The resulting\r\n      selector will be either 0 if all bits of C are zero, or 1 if at\r\n      least one bit of C is 1.\r\n\r\nThe definition in the VRF spec is:\r\n\r\nhttps://tools.ietf.org/html/draft-irtf-cfrg-vrf-06#section-5.4.1.2 (at the bottom of ECVRF_hash_to_curve_elligator2_25519)\r\n\r\n> Alternatively, let CMOV(result_if_1, result_if_0, selector) be the\r\n   function that returns result_if_1 when selector is 1 and result_if_0\r\n   when selector is 0.\r\n>\r\n> [...]\r\n>\r\n> CMOV can\r\n   be implemented in constant time a variety of ways; for example, by\r\n   expanding b from a single bit to an all-0 or all-1 string\r\n   (accomplished by negating b in standard two's-complement arithmetic)\r\n   and then applying bitwise XOR and AND operations as follows: other_x\r\n   XOR ((x XOR other_x) AND b)\r\n\r\n=> The definitions are opposite in both specs\r\n\r\nI didn't find a Github repo for the VRF specs but given:\r\n- the overlap in intended audience of both specs (for example Algorand are implementing both hash to curve and VRF)\r\n- that the VRF spec also has a hash_to_curve section \r\nI think it would be best to have the same definition.",
      "createdAt": "2020-02-16T20:52:43Z",
      "updatedAt": "2020-03-04T09:24:42Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the report :+1:\r\n\r\nWe'll discuss with the VRF folks and push towards consistency.",
          "createdAt": "2020-02-24T02:40:08Z",
          "updatedAt": "2020-02-24T02:40:08Z"
        },
        {
          "author": "mratsim",
          "authorAssociation": "NONE",
          "body": "Here are a few remarks that might help decide one way or another:\r\n\r\n## At the word level\r\n\r\nAt the word level, `cmov` is often alternatively called `select`, `choose` or `mux` or the ternary C operator.\r\nIn all cases I came across, the order was always \r\n```python\r\ndef cmov(condition: ConstantTimeBool, result_if_1: Word, result_if_0: Word) -> Word\r\n  ## Return ``result_if_1`` if condition\r\n  ## else return ``result_if_0``\r\n```\r\n- C ternary operator\r\n- `cmov` instruction on x86 CPU.\r\n- LLVM `select`: https://llvm.org/docs/LangRef.html#select-instruction\r\n- BearSSL `mux` by @pornin: https://www.bearssl.org/gitweb/?p=BearSSL;a=blob;f=src/inner.h;h=07e1d0a478e801a91580658918130fb8b595e407;hb=HEAD#l767\r\n- Cryptocoding guidelines `select` by @veorq: https://github.com/veorq/cryptocoding#solution-1\r\n- `ct_choose` by @lmrs2: https://www.cl.cam.ac.uk/~rja14/Papers/whatyouc.pdf (https://github.com/lmrs2/ct_choose)\r\n\r\n## At the big int / field element level\r\n\r\nHowever at the big int level, `cmov`, `cmove` or `ccopy` is in the other order in the libraries I use\r\n```python\r\ndef cmov(a: mut Fp, b: Fp, condition: ConstantTimeBool) -> None\r\n  ## Copy ``b`` into ``a`` if ``condition``\r\n  ## else leave ``a`` as-is.\r\n```\r\n- BearSSL `ccopy` by @pornin: https://www.bearssl.org/gitweb/?p=BearSSL;a=blob;f=src/inner.h;h=07e1d0a478e801a91580658918130fb8b595e407;hb=HEAD#l903\r\n- Milagro `cmove` by @mcarrickscott: https://github.com/miracl/core/blob/9fa4af0ed170c0fb6a992b7d9cda2d0c2daebbab/c/fp.h#L137-L144\r\n- the current hash-to-curve draft\r\n\r\n## Analysis\r\n\r\n2 \"intuitive\" readings are conflicting:\r\n1. return first parameter if true, else return second (word-level)\r\n2. copy if true, else do nothing (bigint-level)\r\n\r\n## Proposal\r\n\r\nMaybe `ccopy` in both the hash-to-curve and the VRF specs would be a better name for conditional copying of field element to avoid potential confusion with the word-level `cmov`.",
          "createdAt": "2020-02-24T12:56:58Z",
          "updatedAt": "2020-02-24T13:00:44Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "This might end up being solved without any change by H2C, because we're working with the VRF authors to get them to refer to H2C suites rather than defining their own hashing functions. If/when that happens, the offending portions of the VRF draft will no longer exist...",
          "createdAt": "2020-02-25T01:08:36Z",
          "updatedAt": "2020-02-25T01:08:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam do you think this conflict will be resolved by the 9th (draft deadline)? It would be good to close this out by then.",
          "createdAt": "2020-03-03T18:59:58Z",
          "updatedAt": "2020-03-03T18:59:58Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I'll try! I need to talk to the VRF folks about this asap. Once we land the outstanding PRs and get our suite names finalized, I can refresh the [VRF PR](https://github.com/fcelda/nsec5-draft/pull/35) and hopefully get it integrated.",
          "createdAt": "2020-03-04T09:24:30Z",
          "updatedAt": "2020-03-04T09:24:42Z"
        }
      ]
    },
    {
      "number": 213,
      "id": "MDU6SXNzdWU1NzI0Nzk0MDM=",
      "title": "suite ID questions: field separator, user data",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/213",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@armfazh [suggests](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/212#discussion_r385295475) that we change the field separator in Suite ID from `-` to something else, so that we can use `-` in hash names.\r\n\r\nThoughts on other options?\r\n\r\nThe reason that both `-` and `_` are currently excluded in the document is that this lets upper-layer protocols use `_` for field separators while including the hash-to-curve suite name verbatim in their suite name (that's what BLS signatures does now, for example). So I'd rather not use `_`.\r\n\r\n`:` or `|` could work. Other thoughts?",
      "createdAt": "2020-02-28T02:23:34Z",
      "updatedAt": "2020-03-05T18:46:06Z",
      "closedAt": "2020-03-05T18:46:06Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "In [a chain of comments](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/212#discussion_r385298672) on #212, we also discussed whether it would be better to allocate an extra field in the Suite-ID for \"user defined\" data.\r\n\r\nRight now, the text recommends adding user-defined data as an optional subfield of the the ENC_VAR field, separated by a colon:\r\n\r\n    ... || ENC_VAR [ ':' USER_DATA ] || '-'\r\n\r\nThe alternative we were discussing is to add a new field, separated by the field separator (currently hyphen, but see above):\r\n\r\n    ... || ENC_VAR || '-' || USER_DATA || '-'\r\n\r\nThe upside of the alternative is that it's nice and uniform. The downside is that it requires that we add an extra field separator to *all* Suite-IDs to ensure that Suite-IDs are prefix-free.",
          "createdAt": "2020-02-28T17:21:03Z",
          "updatedAt": "2020-02-28T17:21:29Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Please recall me why Suite-IDs must be prefix-free? ",
          "createdAt": "2020-02-28T20:07:48Z",
          "updatedAt": "2020-02-28T20:07:48Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding the separator, what if we use parenthesis, e.g. (curve)(SHA-256)(SSWU)(RO)(UDATA).\r\nWhat is the purpose of SuiteIDs (besides being a unique identifier)? -- It will be parsed? -- I think answer is No. \r\n \r\n",
          "createdAt": "2020-02-28T20:13:29Z",
          "updatedAt": "2020-02-28T20:13:29Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "One more thing to potentially discuss: do we want to get rid of EXP_TAG for the default expand_message variants? @armfazh [suggested this](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/212#discussion_r385294732). I think @chris-wood and I are in favor of keeping EXP_TAG, but happy to discuss more in this issue, too.",
          "createdAt": "2020-02-28T21:28:30Z",
          "updatedAt": "2020-02-28T21:28:30Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Please recall me why Suite-IDs must be prefix-free?\r\n\r\nIt's not strictly necessary, and certainly it doesn't help the security of hash-to-curve itself.\r\n\r\nBut it's slightly nice to have, because it means that upper-level protocols can rely on Suite IDs being prefix-free, e.g., when using the Suite-ID as part of a domain separation tag that is required to be prefix-free.\r\n\r\nSo basically it's just a hedge against misuse.\r\n\r\nIf we decide it's annoying or too costly, we can forget about it.",
          "createdAt": "2020-02-28T21:34:08Z",
          "updatedAt": "2020-02-28T21:34:08Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "After thinking more on this, I see the need for an EXT_TAG. \r\nHowever, I am not entirely agree on replacing algorithm names, e.g. `SHA-256` by `SHA.256`. \r\nI think using parenthesis or other separator will solve this issue too.",
          "createdAt": "2020-02-28T21:36:51Z",
          "updatedAt": "2020-02-28T21:36:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "It's fairly common to use `_` to separate fields in suites. Can we do that? (I recognize that upper-layers use `_`, but that doesn't seem like it should preclude use here.)\r\n\r\n```\r\nCURVE_ID || \"_\" || HASH_ID || \"_\" || MAP_ID || \"_\" || ENC_VAR || \"_\"\r\n```\r\n\r\nThat would let us keep `SHA-256`, for example, right? If we really don't want this, let's just go with `|`.  ",
          "createdAt": "2020-03-03T19:03:39Z",
          "updatedAt": "2020-03-03T19:07:33Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm OK with `_` or `|`.\r\n\r\nIn the case of `_`, I suppose since we have a fixed number of underscores in our suite-id we don't interfere with prefix-freeness in upper-layer suite IDs that use underscores for separation and include our suite ID verbatim.",
          "createdAt": "2020-03-04T05:44:13Z",
          "updatedAt": "2020-03-04T05:44:13Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "So, where do we stand on USER_DATA? I'm still liking the optional, colon-delimited subfield of ENC_VAR better than a whole new field since it probably won't get used that often (ever?)",
          "createdAt": "2020-03-04T09:38:28Z",
          "updatedAt": "2020-03-04T09:38:28Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "If USER_DATA is likely not to be used, I will vote for removing it. Also this extra info don't play role on the internals of the Suite. As opposed to the other fields.",
          "createdAt": "2020-03-05T01:04:00Z",
          "updatedAt": "2020-03-05T01:04:00Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "We can go forward with '_' as a separator, it matches well with valid variable identifiers in many programming languages.",
          "createdAt": "2020-03-05T01:05:27Z",
          "updatedAt": "2020-03-05T01:05:27Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Great! Let's go with `_` and remove `USER_DATA` (in favor of colon-deliminated subfield of `ENC_VAR`). @kwantam, sound good?",
          "createdAt": "2020-03-05T01:06:31Z",
          "updatedAt": "2020-03-05T01:06:31Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Great! I'll roll these changes into #214.",
          "createdAt": "2020-03-05T01:08:37Z",
          "updatedAt": "2020-03-05T01:08:37Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> remove `USER_DATA` (in favor of colon-deliminated subfield of `ENC_VAR`).\r\n\r\nI was also considering removing the subfield from ENC_VAR.  \r\n",
          "createdAt": "2020-03-05T01:12:55Z",
          "updatedAt": "2020-03-05T01:12:55Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> I was also considering removing the subfield from ENC_VAR.\r\n\r\nRight now it's only a recommendation. If we leave it this way, then at least we're helping people to channel their ~~creativity~~user data somewhere harmless...",
          "createdAt": "2020-03-05T01:22:19Z",
          "updatedAt": "2020-03-05T01:22:19Z"
        }
      ]
    },
    {
      "number": 216,
      "id": "MDU6SXNzdWU1NzM1ODUzNjk=",
      "title": "Test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/216",
      "state": "OPEN",
      "author": "dot-asm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "kwantam"
      ],
      "labels": [],
      "body": "I'd like to argue that it wouldn't be inappropriate to have test vectors exercise conditions in algorithms, or more specifically both outcomes of CMOVs/if conditions. As opposite to just a limited number of specific strings fed to all algorithms,the set that is obviously too small to trigger all conditions in any chosen algorithm. Given current state [when test input is passed to hash_to_field] it naturally ~causes~ poses a challenge, as one would have to search for inputs that trigger specific conditions, but it shouldn't be a heavy computational problem.\r\n\r\nOn related note one can also wonder if it would be beneficial to ensure that [sufficient amount of] inputs to sgn0 are \"endian-unambiguous\". By \"endian ambiguity\" I mean that a specific input can yield same sign for both little- and big-endian variants of sgn0, in which case implementation invoking wrong sgn0 would pass the corresponding test.\r\n\r\nAlso, it might be useful to provide intermediate results from inputs to corresponding map_to_curves, as opposite for complete stack, so that map_to_curves can be tested by themselves. Does it make sense?\r\n",
      "createdAt": "2020-03-01T17:40:48Z",
      "updatedAt": "2020-03-10T21:32:18Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mratsim",
          "authorAssociation": "NONE",
          "body": "It's currently quite hard to read your proposals. Can you reformat them?",
          "createdAt": "2020-03-01T22:32:48Z",
          "updatedAt": "2020-03-01T22:32:48Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@dot-asm thanks for the suggestion.\r\n\r\nI agree that it's useful to have test vectors that exercise the conditionals, to the extent possible. For example, it should be relatively easy to pick a set of vectors that exercise different signs, pick either x0 or x1, etc.\r\n\r\nI should note, however, that it is not feasible to create end-to-end test vectors that exercise all of the exceptional conditions in the mappings (because we'd have to, e.g., find an input string that hashes to 0). For these cases, it make sense to test just the mapping functions (without hash_to_field); this is straightforward because we know exactly what the exceptional inputs are for every mapping. The code in `poc` does this already.\r\n\r\nMy guess is that the document will include a relatively small number of tests for each suite, but as you suggest, we should certainly choose these tests to find as many bugs as possible. For extensive testing, my guess is that folks will still need to cross-validate against the `poc/` implementations.",
          "createdAt": "2020-03-01T22:56:04Z",
          "updatedAt": "2020-03-01T22:56:04Z"
        },
        {
          "author": "dot-asm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> it is not feasible to create end-to-end test vectors that exercise all of the exceptional conditions in the mappings (because we'd have to, e.g., find an input string that hashes to 0).\r\n\r\nAh! Correct! There are conditions that are indeed infeasible.\r\n\r\n> the document will include a relatively small number of tests for each suite\r\n\r\nOr why not a reference to this repository and explicit instructions where to find the most up-to-date set. Or reference to a dedicated page if deemed more appropriate.\r\n\r\n> For extensive testing, my guess is that folks will still need to cross-validate against the poc/ implementations.\r\n\r\nFormally speaking it's a little bit more subtle than this. Because there is component that is customarily beyond implementer's control, compiler. In sense that irregardless how close implementation complies with reference, it doesn't necessarily prevent compiler from generating bad code. [I had a problem just another day.]\r\n\r\nSo as initial and enabling step, would it be appropriate to extend `vectors` with intermediate value from input to map_to_curve? And then make \"msg\" field optional to facilitate infeasible cases? Should I pursue this, or would maintainers prefer to do it themselves?",
          "createdAt": "2020-03-02T09:57:59Z",
          "updatedAt": "2020-03-02T09:57:59Z"
        },
        {
          "author": "dot-asm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It's currently quite hard to read your proposals. Can you reformat them?\r\n\r\nI've broken initial post to three paragraphs. Does it look better? Basically it revolves around the same issue [in my head], which is why it was a single blob.",
          "createdAt": "2020-03-02T10:03:14Z",
          "updatedAt": "2020-03-02T10:03:14Z"
        },
        {
          "author": "mratsim",
          "authorAssociation": "NONE",
          "body": "Intermediate tests are valuable, it allows to pinpoint issues more easily. This is what I did when implementing the previous draft, I have internal sanity checks on hash_to_base and map_to_curve against another implementation (https://github.com/status-im/nim-blscurve/blob/f01705182204fc0df33857bb417c76115d83a2cc/blscurve/hash_to_curve.nim#L483-L604).\r\n\r\n> > For extensive testing, my guess is that folks will still need to cross-validate against the poc/ implementations.\r\n> \r\n> Formally speaking it's a little bit more subtle than this. Because there is component that is customarily beyond implementer's control, compiler. In sense that irregardless how close implementation complies with reference, it doesn't necessarily prevent compiler from generating bad code. [I had a problem just another day.]\r\n\r\nIn addition to manually crafted vectors, auto-generated vectors from the reference implementation would be helpful, people would just need to download them as a sanity check. This also avoids package versioning issues (like Python 2~3). In terms of volume, a couple MB would be reasonable (compressed though hashes shouldn't compress well).\r\n\r\nAn alternative would be to provide a Python virtualenv (or Docker) but that seems quite involved.\r\n\r\nThe vectors can even be autogenerated by Github Actions or any CI (Azure pipelines, Travis or Appveyor) but that's probably overkill as well since when the spec is finalized the vectors should change.\r\n",
          "createdAt": "2020-03-02T11:24:52Z",
          "updatedAt": "2020-03-02T11:24:52Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Or why not a reference to this repository and explicit instructions where to find the most up-to-date set. Or reference to a dedicated page if deemed more appropriate.\r\n\r\nI believe there is already a reference to the code in the document. I'll double check that it's in an obvious place.\r\n\r\n> Formally speaking it's a little bit more subtle than this. Because there is component that is customarily beyond implementer's control, compiler. In sense that irregardless how close implementation complies with reference, it doesn't necessarily prevent compiler from generating bad code. [I had a problem just another day.]\r\n\r\nSorry, I don't understand this comment. If the compiler generates incorrect code, the test vectors will presumably mismatch. So what is the proposed action here? I don't think that any number of test vectors will suffice to prove that an arbitrary implementation complies with the spec. More to the point: the test vectors *are not intended* for this purpose! They're a basic sanity check. Implementors are expected to do their own testing beyond the vectors provided in the document.\r\n\r\nOn the other hand, since the reference implementation will be linked from the document, implementors can very easily cross-validate their implementation against the reference. That still doesn't prove anything in a formal sense (the reference implementations aren't formally verified, after all), but it's much more of a debugging aid than a static set of vectors.\r\n\r\n> So as initial and enabling step, would it be appropriate to extend `vectors` with intermediate value from input to map_to_curve?\r\n\r\nYes, this is a good idea.\r\n\r\n> And then make \"msg\" field optional to facilitate infeasible cases?\r\n\r\nProbably this is beyond the scope of test vectors in the document, which are intended as end-to-end sanity checks. And the infeasible cases are already covered by the document: the definition of every map describes all exceptional cases and the expected outputs. (But it might make sense to add a note reminding implementors of this fact.)\r\n\r\nI'm happy to look at a PR, but I'm also happy to take care of it once the current PRs settle out.",
          "createdAt": "2020-03-02T17:30:10Z",
          "updatedAt": "2020-03-02T17:30:10Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Intermediate tests are valuable, it allows to pinpoint issues more easily. This is what I did when implementing the previous draft, I have internal sanity checks on hash_to_base and map_to_curve against another implementation (https://github.com/status-im/nim-blscurve/blob/f01705182204fc0df33857bb417c76115d83a2cc/blscurve/hash_to_curve.nim#L483-L604).\r\n\r\nVery cool. As another example, the [bls sigs ref code](/algorand/bls_sigs_ref) also uses intermediate test vectors.\r\n\r\n> In addition to manually crafted vectors, auto-generated vectors from the reference implementation would be helpful, people would just need to download them as a sanity check.\r\n\r\nWait, what's the distinction here? The vectors that we include in the document will be automatically generated. Is this just saying that we should make a whole bunch of them available out-of-line?\r\n\r\nI assume we'd just check them into the repo. No need to compress, git already does that transparently when sending things over the network. Users can supply `--depth 1` if they really don't want the whole repo history (and I assume that github makes something like grabbing a tarball of master easy, though I don't think I've ever done it).\r\n\r\n> This also avoids package versioning issues (like Python 2~3). In terms of volume, a couple MB would be reasonable (compressed though hashes shouldn't compress well).\r\n> \r\n> An alternative would be to provide a Python virtualenv (or Docker) but that seems quite involved.\r\n\r\nHmm. The poc code is all written in Sage, it uses no packages outside the base Sage installation, and we test it against both modern versions. So I think the packaging issues you're alluding to don't really exist in a meaningful way (beyond \"cannot get Sage running,\" which seems out of scope and/or easily handled by spinning up a VM). In particular, virtualenv doesn't seem to help because this is not a Python codebase as such.",
          "createdAt": "2020-03-02T17:39:43Z",
          "updatedAt": "2020-03-02T17:40:14Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Action items so far from this thread:\r\n\r\n- [x] make sure that poc code is linked in an obvious place in the doc (say, in the test vectors appendix)\r\n- [x] add intermediate values (output of hash-to-field, output of map-to-curve before cofactor clearing) to test vectors\r\n- [ ] choose test vectors that give reasonable branch coverage (e.g., different signs, x1 vs x2, etc)\r\n- [ ] choose test vectors such that sgn0 result is distinct for sgn0_le vs sgn0_be\r\n\r\nPlease let me know if I'm missing any.",
          "createdAt": "2020-03-02T17:44:05Z",
          "updatedAt": "2020-03-09T06:11:43Z"
        },
        {
          "author": "mratsim",
          "authorAssociation": "NONE",
          "body": "> > In addition to manually crafted vectors, auto-generated vectors from the reference implementation would be helpful, people would just need to download them as a sanity check.\r\n> \r\n> Wait, what's the distinction here? The vectors that we include in the document will be automatically generated. Is this just saying that we should make a whole bunch of them available out-of-line?\r\n\r\nI was under the impression that there were manually crafted vectors that triggered edge cases.\r\n\r\n> I agree that it's useful to have test vectors that exercise the conditionals, to the extent possible. For example, it should be relatively easy to pick a set of vectors that exercise different signs, pick either x0 or x1, etc.\r\n\r\nI suppose crafting them is more involved and so we would have fewer. I suggested to also add random vectors to the mix. Now if triggering special cases can be automated you can disregard that part of my comment.",
          "createdAt": "2020-03-03T10:58:33Z",
          "updatedAt": "2020-03-03T10:58:33Z"
        },
        {
          "author": "dot-asm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I believe there is already a reference to the code in the document.\r\n\r\nThe keyword was rather \"explicit instructions where to find the most up-to-date set.\" As alternative to providing test vectors in the document.\r\n\r\n> Sorry, I don't understand this comment. If the compiler generates incorrect code, the test vectors will presumably mismatch.\r\n\r\nImagine a set of test vectors that don't hit some condition. If compiler generates bad code for **that** condition, then test vectors will pass, and you wouldn't know that there is a problem. And this is provided that high-level language implementation is actually correct, so you would be kind of entitled to not expect problems.\r\n",
          "createdAt": "2020-03-03T11:59:34Z",
          "updatedAt": "2020-03-03T11:59:34Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Imagine a set of test vectors that don't hit some condition. If compiler generates bad code for **that** condition, then test vectors will pass, and you wouldn't know that there is a problem.\r\n\r\nAh, now I understand. Thanks for the clarification.\r\n\r\nJust so that we're on the same page (and at the risk of repeating myself---sorry!): detecting that kind of thing is **not** the point of the test vectors. If we're assuming the compiler is allowed to do arbitrarily incorrect things, no reasonably-sized set of test vectors can possibly rule out miscompilation of this kind (because, for example, the incorrect code might give incorrect output only for one particular input).",
          "createdAt": "2020-03-03T17:05:21Z",
          "updatedAt": "2020-03-03T17:05:21Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> The keyword was rather \"explicit instructions where to find the most up-to-date set.\" As alternative to providing test vectors in the document.\r\n\r\nA quick note: test vectors for sanity checking must go into the document, because the document is likely to outlive GitHub or wherever the source code is stored.",
          "createdAt": "2020-03-03T17:09:01Z",
          "updatedAt": "2020-03-03T17:09:01Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> I suppose crafting them is more involved and so we would have fewer. I suggested to also add random vectors to the mix. Now if triggering special cases can be automated you can disregard that part of my comment.\r\n\r\nFortunately, almost every conditional that's feasible to hit (i.e., ones not requiring a hash preimage) happens with some reasonable probability, so it's easy to generate random inputs and check which code paths they exercise. Should be reasonably easy to automate given that every suite only has a small number of conditionals.",
          "createdAt": "2020-03-03T17:12:13Z",
          "updatedAt": "2020-03-03T17:12:13Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "#217 adds test vectors to the document. For now we're just generating vectors from the same three inputs for each suite, but we can change this in a later revision.",
          "createdAt": "2020-03-09T06:12:36Z",
          "updatedAt": "2020-03-09T06:12:36Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood @armfazh : are we at all worried about the sheer number of test vectors in the document? According to `wc`, the test vectors take up about 1/2 of the document.\r\n\r\n(I'm not saying this definitely *is* a problem, but I wonder if it makes the document unwieldy or something?)",
          "createdAt": "2020-03-09T19:27:13Z",
          "updatedAt": "2020-03-09T19:27:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> are we at all worried about the sheer number of test vectors in the document? According to wc, the test vectors take up about 1/2 of the document.\r\n\r\nI'm not. I'd rather the document be verbose, and absent a better place to archive test vectors, putting them in the document seems fine.",
          "createdAt": "2020-03-09T19:28:22Z",
          "updatedAt": "2020-03-09T19:28:22Z"
        },
        {
          "author": "dot-asm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On vaguely related note reference to `{#suites}` is mistyped in new \"Test vectors\" appendix. It should be `{{suites}}`.",
          "createdAt": "2020-03-10T21:32:18Z",
          "updatedAt": "2020-03-10T21:32:18Z"
        }
      ]
    },
    {
      "number": 218,
      "id": "MDU6SXNzdWU1NzcyMzYwNzk=",
      "title": "BP18 reference",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/218",
      "state": "CLOSED",
      "author": "dot-asm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "BP18 appears to be a poster summary of real thing. Wouldn't it be more appropriate to point at \"Efficient hash maps to G2 on BLS curves\" instead?\r\n",
      "createdAt": "2020-03-07T00:02:40Z",
      "updatedAt": "2020-03-07T00:15:02Z",
      "closedAt": "2020-03-07T00:14:38Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! Got it.",
          "createdAt": "2020-03-07T00:15:02Z",
          "updatedAt": "2020-03-07T00:15:02Z"
        }
      ]
    },
    {
      "number": 220,
      "id": "MDU6SXNzdWU1NzgzNzE5NDM=",
      "title": "Q: What is the output size of H for long DST strings?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/220",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "What is the size of the output of  `H`, when a suite defines expand_message_xof,\r\n`DST = H(\"H2C-OVERSIZE-DST-\" || a_very_long_DST)`",
      "createdAt": "2020-03-10T06:49:56Z",
      "updatedAt": "2020-03-13T19:59:40Z",
      "closedAt": "2020-03-13T19:59:40Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Great question. You're absolutely right, this is not written clearly. I'll edit and open a PR.",
          "createdAt": "2020-03-10T17:08:15Z",
          "updatedAt": "2020-03-10T17:08:15Z"
        }
      ]
    },
    {
      "number": 222,
      "id": "MDU6SXNzdWU1ODA3OTEyMzM=",
      "title": "Security parameter on ciphersuites",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/222",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I was curious about setting the security level (`k`) for curves.\r\n\r\nFor example, before [ia.cr/2015/1027](ia.cr/2015/1027), BN-256 was believed to provide k=128. However, due to the advances on NFS, parameters of curves must be updated.\r\n\r\nSo, setting `k` in some ciphersuites means that we must \r\na) choose the recommended parameter in the spec, or \r\nb) use the latest `k` known to date?\r\n\r\nIt is unclear when the next advance on NFS will happen, but what will be the k parameter used when this happens?\r\n\r\n",
      "createdAt": "2020-03-13T19:12:35Z",
      "updatedAt": "2020-03-18T19:17:53Z",
      "closedAt": "2020-03-18T19:17:53Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a great point.\r\n\r\nReally, the reason we specify k is so that everyone arrives at the same value for hash_to_field. So we should probably point out that the `k` values specified in the ciphersuite are *upper bounds* on the security level of the curves (which we use to ensure that hash_to_field is designed conservatively), and should not be regarded as an endorsement or guarantee that a curve gives a specific security level.",
          "createdAt": "2020-03-13T20:04:20Z",
          "updatedAt": "2020-03-13T20:04:20Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> So we should probably point out that the k values specified in the ciphersuite are upper bounds on the security level of the curves (which we use to ensure that hash_to_field is designed conservatively), and should not be regarded as an endorsement or guarantee that a curve gives a specific security level.\r\n\r\nThis is a great suggestion! I can prepare a PR to this effect, unless you've already started @kwantam?",
          "createdAt": "2020-03-13T22:19:39Z",
          "updatedAt": "2020-03-13T22:19:39Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I haven't started one, but I'm happy to do it if you don't get to it first :)",
          "createdAt": "2020-03-13T23:39:23Z",
          "updatedAt": "2020-03-13T23:39:23Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I found in [SP-800-90A](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf) methods similar to ours for generating random bits and from them generate random numbers. See Section A.5, we are actually using Method in A.5.3, where `s` is our `k` security parameter.\r\n\r\nAdditionally, there are recommended methods for generating random bits using hash functions. The content of this document could be useful for describing hash_to_field.\r\n\r\n",
          "createdAt": "2020-03-18T01:06:45Z",
          "updatedAt": "2020-03-18T01:06:45Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I seem to recall that the hash_drbg in SP-800-90A has some minor issues. One is its complexity!\r\n\r\nI think this is the paper I'm remembering: https://eprint.iacr.org/2018/349\r\n\r\nI don't think any of the additional complexity buys us anything, but I could be missing something.\r\n\r\nI'm going to put together a PR for #223 in the next couple days. We don't have to make any change, but I want to be clear what the changes would be if we do.",
          "createdAt": "2020-03-18T03:24:24Z",
          "updatedAt": "2020-03-18T03:24:24Z"
        }
      ]
    },
    {
      "number": 223,
      "id": "MDU6SXNzdWU1ODE0MjU4MDg=",
      "title": "expand_message_xmd : a potential optimization",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/223",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Hi folks,\r\n\r\nIt occurs to me that there's one possible modification to expand_message_xmd that would make it slightly nicer for some users. It's not a clear and unqualified win, but it's worth at least discussing.\r\n\r\nRight now, expand_message_xmd computes the following:\r\n\r\n    Z_pad = I2OSP(0, <block length of H>)\r\n    b_0 = H(Z_pad || msg || I2OSP(len_in_bytes, 2) || I2OSP(0, 1) || DST_prime)\r\n    b_1 = H(b_0 || I2OSP(1, 1) || DST_prime)\r\n    b_i = H(strxor(b_0, b_(i-1)) || I2OSP(i, 1) || DST_prime)\r\n\r\nThis is to ensure that `b_0` and `b_i` (i >= 1) are hashed with different initialization vectors. The downside of this approach is that some protocols will already have computed `H(msg || ...)`, and the above means that they have to pass over `msg` again to compute `b_0`.\r\n\r\nWe could instead consider doing this:\r\n\r\n    b_0 = H(msg || I2OSP(len_in_bytes, 2) || I2OSP(0, 1) || DST_prime)\r\n    b_1 = H(Z_pad || b_0 || I2OSP(1, 1) || DST_prime)\r\n    b_i = H(Z_pad || strxor(b_0, b_(i-1)) || I2OSP(i, 1) || DST_prime)\r\n\r\nThis also ensures that `b_0` and `b_i` (i >= 1) are hashed starting from different initialization vectors, but now implementors can reuse the work computing `H(msg || ...)` in `b_0`.\r\n\r\nThis looks like strictly more hashing work, since all the `b_i` need to be prefixed with a block of 0s. But as we know, most of the time implementations allow you to preload the state of the hash function, so in practice it's possible to optimize this away. On the other hand, anyone who *doesn't* want to implement this optimization *will* pay extra for hashing.\r\n\r\nSo the question is, do we enable a potentially nice optimization at the cost of making un-optimized implementations slower?\r\n\r\n(This assumes, of course, that we're willing to make any change at all. But now's the time for a change, since to my knowledge no one except me has actually implemented the new hash_to_field functions yet.)",
      "createdAt": "2020-03-14T23:56:19Z",
      "updatedAt": "2020-03-25T23:32:24Z",
      "closedAt": "2020-03-25T23:32:24Z",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "(cc @armfazh @chris-wood )",
          "createdAt": "2020-03-14T23:56:31Z",
          "updatedAt": "2020-03-14T23:56:31Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "My take is that most un-optimized implementations won't see much increase in cost, whereas optimized implementations *would* enjoy significant savings for long `msg` values. So on balance I'd lean towards making this change. Otherwise, we're kind of stuck in a middle ground: un-optimized implementations are almost imperceptibly faster, but optimized ones are 2x slower in the huge-`msg` asymptote.\r\n\r\n---\r\n\r\nOne additional advantage is that changing the design as described above might *discourage* people from defining prehash modes, which is probably a good thing security-wise.",
          "createdAt": "2020-03-14T23:59:38Z",
          "updatedAt": "2020-03-15T00:00:45Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, thinking about this more, the suggestion doesn't quite work: if `msg` starts with a full block of `0`s, then indifferentiability is broken.\r\n\r\nWe might instead consider:\r\n\r\n    b_0 = H(msg || I2OSP(len_in_bytes, 2) || I2OSP(0, 1) || DST_prime)\r\n\r\n    Z_pad = I2OSP(0, r_in_bytes - b_in_bytes)\r\n    b_i = H(b_0 || Z_pad || b_(i-1) || I2OSP(i, 1) || DST_prime)\r\n\r\nNow every b_i hash starts with a block comprising `b_0 || 000...000`, which is distinct from the first block of `msg` unless an attacker can find `msg` starting with the block `X || 000...000` where X == H(msg). I have to think more about the difficulty of this problem.\r\n\r\nThe advantage of this construction over the current one is that this lets us reuse work for computing `H(msg || ...)`. The cost is that an optimal implementation costs one extra compression function evaluation (to compute `h(IV, b_0 || 000...000)`). In other words, we make it slightly friendlier for reusing work, at the cost of exactly one more compression function invocation.\r\n\r\nThoughts?",
          "createdAt": "2020-03-19T04:55:58Z",
          "updatedAt": "2020-03-19T05:05:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam ACKing this issue! I'll implement the different variants and get some benchmarks. ",
          "createdAt": "2020-03-19T17:45:18Z",
          "updatedAt": "2020-03-19T17:45:18Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thinking more about this, I think the proposal in my [prior message](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/223#issuecomment-600988563) ends up assuming a lot more about the security of the compression function than the current version of xmd does (and, in particular, seems to assume a property that isn't really standard). So I think we'd be better off with the current version, just for the sake of being conservative with security.\r\n\r\n---\r\n\r\nDetails:\r\n\r\nRecall that the current version of xmd ensures that the \"inner\" invocation of H (to compute `b_0`) starts with a different initialization vector than the \"outer\" invocations (to compute `b_i`) by fixing the first block of the inner H's input to the all-zeros block (this suffices to guarantee that the outer and inner IVs are always different, thanks to the way we use the counter). And this is precisely the reason that the work computing the inner H invocation can't be reused by other pieces of an invoking protocol---we need to prepend a fixed block to `msg` to change the IV of the inner hash invocation.\r\n\r\n(Of course, the invoking protocol is welcome to use `H(Z_pad || msg || ...)` rather than `H(msg || ...)` if they want!)\r\n\r\nThe version I proposed in the prior message tries to ensure that the inner and outer invocations use different IVs by fixing the first block of the outer invocation (rather than the inner one). But for this to work, it has to be the case that the adversary can't craft an input to the inner invocation that causes the outer and inner IVs to match---and to rule this out, we need to rely on some property of the hash function that doesn't seem like a standard one.\r\n\r\nWhat property do we need? Well, contrary to what I initially posted above, it's certainly not enough for H to have preimage resistance, because this isn't quite a preimage attack:\r\n\r\n1. Preimage resistance: given some target X, come up with a message m such that X = H(m)\r\n2. What we would need: come up with any X and m such that X = H(X || 000...000 || m)\r\n\r\n(The attacker has strictly more power in the second case than in the first, so we should expect hash functions to be weaker against the second kind of attack than against a preimage attack.)\r\n\r\nIt's also not any of the standard prefix-resistance properties, since those fix a prefix for the attacker to target. We might call what we're looking for prefix-fixpoint-resistance. But since this doesn't appear to be anything like a standard notion of security, it seems at best dubious to base the security of the construction on it.\r\n\r\nAs more evidence that this isn't a great idea, we know that it's relatively easy to find a fixpoint for a Davies-Meyer--style compression function like the one used in SHA-2. I have no idea whether this can be extended to make the attack work, but it seems to be a crack in the armor...",
          "createdAt": "2020-03-19T19:59:01Z",
          "updatedAt": "2020-03-19T20:00:14Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I consider that we must be act with caution, since it is easy to make wrong decisions that could lead to attacks.\r\nIt would be ideal to have a security proof of the extraction of pseudo random bytes. However, even the authors of eprint.iacr.org/2018/349 had a difficulties on analyzing the algorithms in SP-800-90A.\r\n\r\nAs a matter of sanity, we could take some time to revisit the simplest and secure approach, and from it, departing to make some improvements.",
          "createdAt": "2020-03-19T22:35:34Z",
          "updatedAt": "2020-03-19T22:35:34Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, since it seems like there's no way to make this work-savings proposal happen unless we're willing to make some weird assumption about a hash function, how about we table this for now and revisit if any of us comes up with a better idea?\r\n\r\n---\r\n\r\nMeanwhile, I think @armfazh is right that we want to write down a detailed analysis of the current expand_message_xmd function.\r\n\r\nJust for the sake of completeness, here's a variant of our current function that gets rid of the XOR operation, at the cost of one more compression function invocation. (The security analysis of this one is somewhat easier because it doesn't use XOR chaining.)\r\n\r\n    b_0 = H(Z_pad || msg || I2OSP(len_in_bytes, 2) || I2OSP(0, 1) || DST_prime)\r\n    b_0_pad = b_0 || I2OSP(0, r_in_bytes - b_in_bytes)    # pad b_0 to 1 block\r\n    for i in (1, ..., ell):\r\n        b_i = H(b_0_pad || b_(i - 1) || I2OSP(i, 1) || DST_prime)\r\n\r\nHere, unless `b_0_pad = Z_pad` (which requires finding a first preimage), the inner and outer H functions have independent IVs. Meanwhile, because of the counter, all of the messages are distinct.\r\n\r\nThe extra compression function invocation is to compute `h(IV, b_0_pad)` once; this can be reused for all `b_i` computations, which thereafter require as little as one compression function invocation (depending on the length of DST). This is cheaper than what we considered in #214,\r\n\r\n    b_i = H(b_0 || b_(i-1) || I2OSP(i, 1) || DST_prime)\r\n\r\nwhich would require at least two compression function invocations for every `b_i`.",
          "createdAt": "2020-03-20T17:39:42Z",
          "updatedAt": "2020-03-20T17:39:42Z"
        }
      ]
    },
    {
      "number": 225,
      "id": "MDU6SXNzdWU1ODQwNTA2MDk=",
      "title": "feedback about sgn0",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/225",
      "state": "OPEN",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Mike Scott sent me an email with several pieces of feedback on sgn0. Let's discuss if/how to handle these in this issue, and then I'll put together a PR.\r\n\r\nThe high-level message is that the sgn0 definitions are too complex, and may lead to implementation errors. Specific suggestions:\r\n\r\n1. Get rid of `sgn0_be` and only use `sgn0_le`.\r\n\r\n    - Pros: only one sgn0 variant would be great.\r\n    - Cons: this would mean that existing curves that use `sgn0_be` for point compression wouldn't be able to reuse that implementation for hashing. Also, it looks like the BLS12-381 community is pretty firmly entrenched at this point, which would make life hard for the BLS signatures draft.\r\n\r\n2. If sgn0 returns 0 for positive or zero, and 1 for negative, then it (at least, `sgn0_le`) could be much simpler, especially for the `m=1` case:\r\n\r\n        def sgn0_le(x):\r\n            return x mod 2\r\n\r\n    This could also be made quite simple for quadratic extensions:\r\n\r\n        def sgn0_le(x):   # x = (x_1, x_2)\r\n            p0 = x_1 == 0\r\n            p1 = x_1 mod 2\r\n            p2 = x_2 mod 2\r\n            return p1 | (p0 & p2)\r\n\r\n    - Pros: simplifies specifying `sgn0_le`. Not clear whether it simplifies `sgn0_be`, but it might.\r\n    - Cons: is (0, 1) less intuitive than (1, -1) for (positive, negative) respectively?\r\n\r\n3. Rather than specifying field extension sgn0 in terms of vector representations, specify it in terms of towering. That is, express sgn0 for Fp2 in terms of two calls to sgn0 for Fp; sgn0 for Fp4 in terms of two calls to sgn0 for Fp2; etc.\r\n\r\n    - Pros: may result in simpler constant-time implementations.\r\n    - Cons: requires us to define towering at sufficient detail in the document to actually specify this approach. Is not compatible with any existing point compression technique that I'm aware of.",
      "createdAt": "2020-03-18T22:54:42Z",
      "updatedAt": "2020-03-25T23:26:37Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's my take.\r\n\r\nFirst, to address the complexity of the current spec, we could give simplified versions of `sgn0_le` and `sgn0_be` for the m=1 case, and maybe also for the m=2 case for `sgn0_be`.\r\n\r\nPoint-by-point for each of the above suggestions:\r\n\r\n1. It would be nice to get rid of `sgn0_be`, but it will make some implementations more complex, and it will definitely make the BLS signatures standard slightly more controversial (since the only suites right now are BLS12-381, and everyone there seems to prefer to use big-endian signedness).\r\n\r\n    So I'm not in favor of removing `sgn0_be`.\r\n\r\n2. I'm fine with (0,1) instead f (1,-1). It will make the specifications simpler (because we can use logical operators rather than CMOV). It will also require a careful consistency pass through the document, but that's not so hard.\r\n\r\n    So I'm slightly in favor of (0, 1), but could go either way.\r\n\r\n3. The towering suggestion is clever, but I think adding all the towering notation to this document will make it strictly harder to understand, and it would require us to totally give up on the idea of matching point compression for extension fields. (I suppose if we decide to get rid of `sgn0_be` then we're already breaking point compression compatibility, in which case the second argument doesn't apply.)\r\n\r\n    Also, it will probably require a whole bunch of different \"towering combinators\" that describe what to do for different degrees at each level of the tower (certainly we'll need degree 2 and 3, possibly others).\r\n\r\n    So: I'm against making the towering change.",
          "createdAt": "2020-03-18T22:55:38Z",
          "updatedAt": "2020-03-18T22:55:38Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh @chris-wood thoughts?",
          "createdAt": "2020-03-18T22:56:19Z",
          "updatedAt": "2020-03-18T22:56:19Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> it will definitely make the BLS signatures standard slightly more controversial (since the only suites right now are BLS12-381, and everyone there seems to prefer to use big-endian signedness).\r\n\r\nThe choice of sgn0 is particular to hash to curve, isn't it?. BLS signatures still can use big-endian sign for other purposes. As noted, verifying parity is easier to implement.\r\n\r\nMoving from (1,-1) to (0,1) is equivalent to move from `sgn` to `parity`. So, sgn can be defined in terms of parity.\r\n\r\nThe proposed sgn function is too specific to the tower used. However, how it is actually computed the sgn function in the current setting?\r\n\r\nFor example, if we have an element in Fp6, \r\nLet A \\in Fp6,  A = A1 x + A0. (as a quadratic extension over Fp3)\r\nA1 \\in Fp3,  A1 = a2 y^2 + a1 y + a0 ( a cubic extension over Fp)\r\n\r\n",
          "createdAt": "2020-03-19T22:24:10Z",
          "updatedAt": "2020-03-19T22:24:10Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> The choice of sgn0 is particular to hash to curve, isn't it?. BLS signatures still can use big-endian sign for other purposes. As noted, verifying parity is easier to implement.\r\n\r\nYou're totally right, they could keep using the existing method for compression and only change sgn0 for hashing. This gives up on the hope that everyone could use the same sign method for both compression and hashing, but maybe that's OK.\r\n\r\n> Moving from (1,-1) to (0,1) is equivalent to move from `sgn` to `parity`. So, sgn can be defined in terms of parity.\r\n\r\nTrue.\r\n \r\n> The proposed sgn function is too specific to the tower used. However, how it is actually computed the sgn function in the current setting?\r\n> \r\n> For example, if we have an element in Fp6,\r\n> Let A \\in Fp6, A = A1 x + A0. (as a quadratic extension over Fp3)\r\n> A1 \\in Fp3, A1 = a2 y^2 + a1 y + a0 ( a cubic extension over Fp)\r\n\r\nIn the current version, I think we'd expect people to write down the element of Fp6 as a 6-vector over, say, the basis given by the Cartesian product {y^2, y, 1} x {x, 1} and then compute the sign using the existing method. Right?",
          "createdAt": "2020-03-19T23:10:07Z",
          "updatedAt": "2020-03-19T23:10:07Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> In the current version, I think we'd expect people to write down the element of Fp6 as a 6-vector over, say, the basis given by the Cartesian product {y^2, y, 1} x {x, 1} and then compute the sign using the existing method. Right?\r\n\r\nhence, it is equivalent to what is proposed by going trough the tower, or not?\r\nbecause, at the end, the sgn will be a function coefficients in the ground field.",
          "createdAt": "2020-03-20T00:09:39Z",
          "updatedAt": "2020-03-20T00:09:39Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, got it! (Sorry for being slow :smile:)\r\n\r\nI think you're right: it's possible, as long as the ground field elements have the \"right\" ordering, that the two methods would agree. This is a really good point :+1:",
          "createdAt": "2020-03-20T02:26:06Z",
          "updatedAt": "2020-03-20T02:26:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "My $0.02:\r\n\r\n1. I'm OK removing the BE variant, given that it primarily benefits one use case.\r\n2. I don't think (0,1) would cause much confusion. As a plus, specifying sgn0 in terms of parity does seem to simplify things. \r\n3. I'm less comfortable with this proposal. @kwantam, does it depend on a particular basis representation for field elements? ",
          "createdAt": "2020-03-23T01:53:31Z",
          "updatedAt": "2020-03-23T01:53:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "ping @kwantam @armfazh!",
          "createdAt": "2020-03-25T20:08:20Z",
          "updatedAt": "2020-03-25T20:08:20Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "it seems we are all agree on  points 1 and 2.\r\nFor the point 3, we might need to specify the order in which the elements and sub-elements are evaluated. So, a sgn function that does not depend on the order of element will be ideal.\r\n",
          "createdAt": "2020-03-25T20:34:55Z",
          "updatedAt": "2020-03-25T20:34:55Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "It's not obvious to me how to make sgn independent of the evaluation order (or that it's even possible), but it's a very cool idea...\r\n\r\nI'm still not super jazzed about killing sgn0_be, but I'll go along with it if both of you prefer it.\r\n\r\n(0,1) seems fine.\r\n\r\nI should have some time in the next couple days to put together edits for points 1 and 2, and then I guess we can re-evaluate whether we definitely want to remove sgn0_be.",
          "createdAt": "2020-03-25T23:26:37Z",
          "updatedAt": "2020-03-25T23:26:37Z"
        }
      ]
    },
    {
      "number": 227,
      "id": "MDU6SXNzdWU1ODQ3NzUyODY=",
      "title": "a different way around the k issue",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/227",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I'm helping to implement hash-to-curve in RELIC, and as I'm doing this I'm realizing that the way we've specified `k` inherently requires a judgement call, which is annoying. This is related to @armfazh's issue with calling `k` the security parameter---that's subjective and will change over time, and even now people will disagree on how to define it.\r\n\r\nSo how could we do this in an objective way? One way would be to say\r\n\r\n    L = ceil(1.5 * ceil(log2(p)) / 8)\r\n\r\nin other words, we replace `k` with `ceil(log2(p)) / 2`. But this is too conservative for curves with large cofactors (like pairing-friendly curves).\r\n\r\nHow about this:\r\n\r\n    p_bits = ceil(log2(p))\r\n    r_bits = ceil(log2(r))  # the bit-length of the prime subgroup order\r\n    L = ceil((p_bits + ceil(r_bits / 2)) / 8)\r\n\r\nThis is essentially how we have been picking `k` already---in particular, I think this will not change any of the hash-to-field parameters in the Suites at all---but it's a totally objective measure, which is nice...\r\n\r\nI can put together a PR if this seems reasonable.",
      "createdAt": "2020-03-20T00:27:39Z",
      "updatedAt": "2020-03-20T23:33:14Z",
      "closedAt": "2020-03-20T23:33:14Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Rather than replace `k` entirely, perhaps we can note that `k` could be computed as you suggest? I think having a target security level will be important for folks looking to adopt one of these in their applications or protocols.",
          "createdAt": "2020-03-20T00:32:58Z",
          "updatedAt": "2020-03-20T00:32:58Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Great point! We can add this in the \"defining new suites\" section, maybe.",
          "createdAt": "2020-03-20T00:34:31Z",
          "updatedAt": "2020-03-20T00:34:31Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgxMzE0MjIx",
      "title": "Expand introduction and add background material.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/18",
      "state": "MERGED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": " - Expand out the introduction to include discussion of encoding\r\n   functions and their application to creating random oracles\r\n   on curves.\r\n - Add some background information on elliptic curve encoding\r\n   methods, with some theoretical background.\r\n\r\n----\r\n\r\nI appreciate a lot of this might be a little off-tone for the document. But I thought it was important to get it down. I would be happy to push the theoretical parts to later/the appendix.\r\n\r\nWith this in place, Chapter 3 could be even more informative. For example:\r\n\r\nUse case: Encoding bitstring to curve point (for use as group generator):\r\n`m -> H(m) * G`\r\n\r\nUse case: Hashing to curve point (for use in CDH/DDH-like protocol):\r\n`m -> F(H(m))`, given additional proof and for F in {Icart, SWU, etc} by parameters.\r\n (This is the existing table, maybe add some info for supersingular and x-only scalar mult).\r\n\r\nUse case: Hashing to curve point (default, all, gives random oracle):\r\n`m -> F(H1(m)) + F(H2(m))` for F in {...} \r\n\r\nand so on. So then this becomes a useful lookup from application to function.\r\n\r\nI'll keep writing some stuff for review, but happy to take any comments in the meantime.\r\n",
      "createdAt": "2018-04-12T20:17:36Z",
      "updatedAt": "2018-04-12T22:14:13Z",
      "closedAt": "2018-04-12T22:11:15Z",
      "mergedAt": "2018-04-12T22:11:15Z",
      "mergedBy": "samscott89",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 Agreed that this is definitely useful text. Thanks for writing it down!",
          "createdAt": "2018-04-12T20:55:19Z",
          "updatedAt": "2018-04-12T20:55:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 Feel free to merge, since I added you as a contributor. I wonder if we should further split this document into two parts: one describing encoding/serialization functions, and the other describing hashing functions. What do you think?",
          "createdAt": "2018-04-12T20:56:45Z",
          "updatedAt": "2018-04-12T20:56:45Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "> I wonder if we should further split this document into two parts: one describing encoding/serialization functions, and the other describing hashing functions. What do you think?\r\n\r\nI think that might be the clearest way to go about it. I was trying to keep to the original structure in an attempt to make my changes purely additive, but it might be worth breaking in up a bit more.\r\n\r\nOk, I'll merge this for now, and look at playing with the structure a little.",
          "createdAt": "2018-04-12T22:07:39Z",
          "updatedAt": "2018-04-12T22:07:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 Sounds great, thanks!",
          "createdAt": "2018-04-12T22:14:13Z",
          "updatedAt": "2018-04-12T22:14:13Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNzg4MTcy",
          "commit": {
            "abbreviatedOid": "a7b3047"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-12T20:49:33Z",
          "updatedAt": "2018-04-12T20:49:33Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "\ud83d\udc4d ",
              "createdAt": "2018-04-12T20:49:33Z",
              "updatedAt": "2018-04-12T22:10:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNzg4Njc1",
          "commit": {
            "abbreviatedOid": "a7b3047"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-12T20:50:53Z",
          "updatedAt": "2018-04-12T20:50:53Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "s/outputting/which outputs",
              "createdAt": "2018-04-12T20:50:53Z",
              "updatedAt": "2018-04-12T22:10:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNzg5MzI1",
          "commit": {
            "abbreviatedOid": "a7b3047"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-12T20:52:41Z",
          "updatedAt": "2018-04-12T20:52:41Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "Should we mention and reference Hasse's Theorem?",
              "createdAt": "2018-04-12T20:52:41Z",
              "updatedAt": "2018-04-12T22:10:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNzg5NzQ4",
          "commit": {
            "abbreviatedOid": "a7b3047"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-12T20:53:50Z",
          "updatedAt": "2018-04-12T20:53:50Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "s/an EC/a curve",
              "createdAt": "2018-04-12T20:53:50Z",
              "updatedAt": "2018-04-12T22:10:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 19,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgyNjE2NjIx",
      "title": "Re-structuring effort.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/19",
      "state": "MERGED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Proposed new structure changes the emphasis to \"mapping-to-curve\" algorithms. Has a very brief background chapter introducing encoding/serialization/hash-to-curve(aka random oracles).\r\nTechnical details/related work pushed to appendix for relevant info.",
      "createdAt": "2018-04-18T22:10:25Z",
      "updatedAt": "2018-04-29T21:25:11Z",
      "closedAt": "2018-04-29T21:25:11Z",
      "mergedAt": "2018-04-29T21:25:11Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Thought I'd get this proposed structure down early so we can iterate on the content quicker. Language needs improvements, and I think it's worth clarifying that generally you need an encoding mapping to elements `mod #E(GF(p))`, which is often prime q, with  `p = rq + 1`.",
          "createdAt": "2018-04-18T22:13:21Z",
          "updatedAt": "2018-04-18T22:13:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 Feel free to merge. Or, if you prefer, we can add the table first. I'd be happy to add that text to lessen your load. Let me know your preference.",
          "createdAt": "2018-04-23T23:49:12Z",
          "updatedAt": "2018-04-23T23:49:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzNzk0NjEx",
          "commit": {
            "abbreviatedOid": "fa25329"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-19T22:09:35Z",
          "updatedAt": "2018-04-19T22:09:36Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Isn't the interface: {0,1}^* \\to E, rather than GF(p) \\to E?",
              "createdAt": "2018-04-19T22:09:36Z",
              "updatedAt": "2018-04-19T22:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzNzk1ODEy",
          "commit": {
            "abbreviatedOid": "fa25329"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-19T22:14:47Z",
          "updatedAt": "2018-04-19T22:14:47Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Typo in \"performance\"",
              "createdAt": "2018-04-19T22:14:47Z",
              "updatedAt": "2018-04-19T22:14:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzNzk2NjY0",
          "commit": {
            "abbreviatedOid": "fa25329"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-19T22:18:38Z",
          "updatedAt": "2018-04-19T22:18:38Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "It's not clear to me whether or not we will have separate sections on encoding and hashing algorithms, or if we will have one section for all algorithms, with each variant annotated with its properties. Is it the latter? If so, we should consider adding a properties column to our recommendation table. Or, perhaps we should make two tables: one for encoding, and one for hashing. Our recommendations may vary based on the application. @samscott89, what do you think?",
              "createdAt": "2018-04-19T22:18:38Z",
              "updatedAt": "2018-04-19T22:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzNzk2OTU5",
          "commit": {
            "abbreviatedOid": "fa25329"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-19T22:19:49Z",
          "updatedAt": "2018-04-19T22:19:49Z",
          "comments": [
            {
              "originalPosition": 222,
              "body": "Can (or should?) we merge this with the try-and-increment section below? The content overlap is substantial.",
              "createdAt": "2018-04-19T22:19:49Z",
              "updatedAt": "2018-04-19T22:19:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE0MTgwNjMz",
          "commit": {
            "abbreviatedOid": "fa25329"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-21T18:59:53Z",
          "updatedAt": "2018-04-21T18:59:53Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "I was thinking of adding tables to the recommendations along these lines:\r\n\r\nThe following table lists algorithms recommended by use-case:\r\n\r\n| Application       | Requirement   | Additional Details\r\n|-------------------|---------------|---------|\r\n| SPEKE {{Jablon96}}| Naive         | y = H(x)*G |\r\n| PAKE  {{BMP00}}   | Random Oracle |   -    | \r\n| BLS {{BLS01}}     | RO            |    -   |\r\n| IBE {{BF01}}      | RO | Supersingular, pairing-friendly curve |\r\n\r\nTo find the suitable algorithm, lookup the requirement from above, with \r\nthe chosen curve in the below:\r\n\r\n\r\n| Curve  | Inj. Encoding | RO |\r\n|--------|---------------|------|\r\n| P-256 | SWU {{simple-swu}} | FFSTV(SWU)\r\n| P-384 | Icart {{icart}} | FFSTV(Icart)\r\n| Curve25519 | Elligator2 {{elligator2}} | ...\r\n| Curve448 | Elligator2 {{elligator2}} | ...\r\n\r\n----",
              "createdAt": "2018-04-21T18:59:53Z",
              "updatedAt": "2018-04-21T19:05:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE0MTgwNzIy",
          "commit": {
            "abbreviatedOid": "fa25329"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-21T19:04:28Z",
          "updatedAt": "2018-04-21T19:04:28Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Which will hopefully be more obviously useful when expanding the list of applications to tease out the subtle requirements (functional and security). For example, I think we can show that the x-only Montgomery mechanism (which gives you an injective encoding) is useful for many applications where you need a PRF-like thing (potentially relevant to @grittygrease in fact).",
              "createdAt": "2018-04-21T19:04:28Z",
              "updatedAt": "2018-04-21T19:04:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE0MTgwODMw",
          "commit": {
            "abbreviatedOid": "fa25329"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-21T19:09:00Z",
          "updatedAt": "2018-04-21T19:09:00Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "As for the structure of encoding & hashing vs all algorithms. I don't think there will be a huge difference, since AFAICT all mechanism to do RO properly are generic methods using some existing injective encoding. So I would present all encoding mechanism and mention their specific properties, and then list the methods to achieve random oracles by combining them.",
              "createdAt": "2018-04-21T19:09:00Z",
              "updatedAt": "2018-04-21T19:09:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE0NTkzNDM2",
          "commit": {
            "abbreviatedOid": "fa25329"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-23T23:48:35Z",
          "updatedAt": "2018-04-23T23:48:35Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "+1 to all of the above. :-)\r\n",
              "createdAt": "2018-04-23T23:48:35Z",
              "updatedAt": "2018-04-23T23:48:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 20,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NDQ5NTEy",
      "title": "Hashing to pairing-friendly curves",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/20",
      "state": "CLOSED",
      "author": "Ela-BLee",
      "authorAssociation": "NONE",
      "assignees": [
        "samscott89"
      ],
      "labels": [],
      "body": "Added a section on hashing onto BN curves, which are pairing-friendly.\r\nIncludes a brief introduction to BN curves, the FT-encoding function, and steps for the overall hash function.",
      "createdAt": "2018-05-11T12:25:10Z",
      "updatedAt": "2019-03-01T16:18:04Z",
      "closedAt": "2019-03-01T16:18:04Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "wrt the Legendre symbol stuff. Might be simpler to just always replace it by the exponentiation computation? ",
          "createdAt": "2018-05-25T19:42:11Z",
          "updatedAt": "2018-05-25T19:42:11Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 that works for me. @Ela-BLee, can you please try to replace the Legendre symbol with the explicit formula?",
          "createdAt": "2018-05-25T20:13:52Z",
          "updatedAt": "2018-05-25T20:13:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@Ela-BLee will you be able to update this PR by the end of next week?",
          "createdAt": "2018-06-13T23:13:27Z",
          "updatedAt": "2018-06-13T23:13:27Z"
        },
        {
          "author": "Ela-BLee",
          "authorAssociation": "NONE",
          "body": "Updated - apologies for the delay",
          "createdAt": "2018-06-21T20:30:34Z",
          "updatedAt": "2018-06-21T20:30:34Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "body": "Do you mind also adding a ciphersuite in the ciphersuites section for a common curve, say bn256?",
          "createdAt": "2018-10-22T21:22:03Z",
          "updatedAt": "2018-10-22T21:22:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@Ela-BLee this extended and updated in #86. Thank you for your changes!",
          "createdAt": "2019-03-01T16:18:04Z",
          "updatedAt": "2019-03-01T16:18:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NDMwODQw",
          "commit": {
            "abbreviatedOid": "5c755fe"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-11T13:22:59Z",
          "updatedAt": "2018-05-11T13:22:59Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "At the moment we've pushed a lot of the more technical background to the end. [This](https://github.com/chris-wood/draft-sullivan-cfrg-hash-to-curve/blob/master/draft-irtf-cfrg-hash-to-curve.md#supersingular-curves) would probably be the appropriate section for that.\r\n\r\nThat section might get pushed up later, but for now it seems like a good place to keep it all together.",
              "createdAt": "2018-05-11T13:22:59Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NDY0NDky",
          "commit": {
            "abbreviatedOid": "5c755fe"
          },
          "author": "Ela-BLee",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-11T14:53:37Z",
          "updatedAt": "2018-05-11T14:53:37Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Thanks Sam - missed the section move when resolving the merge conflict.\r\nFixing now.",
              "createdAt": "2018-05-11T14:53:37Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NTM3Mzg4",
          "commit": {
            "abbreviatedOid": "90bcf5c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-11T18:33:39Z",
          "updatedAt": "2018-05-11T18:33:39Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "If we're using Xp() for the Legendre symbol, which is fine by me, we should re-write the other algorithms to make use of this notation.",
              "createdAt": "2018-05-11T18:33:39Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NTM3ODkw",
          "commit": {
            "abbreviatedOid": "90bcf5c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-11T18:35:13Z",
          "updatedAt": "2018-05-11T18:35:13Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "We should re-write this conditional selection to make it constant time, too, right?",
              "createdAt": "2018-05-11T18:35:13Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIxMTg5MjM5",
          "commit": {
            "abbreviatedOid": "a203fa3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "The latest changes look good to me. @samscott89 what do you think about unifying the Legendre symbol notation?",
          "createdAt": "2018-05-17T19:46:06Z",
          "updatedAt": "2018-05-17T19:46:58Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "Missing comma between \"1 + b\" and \"b nonzero\"",
              "createdAt": "2018-05-17T19:46:06Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxMDU3OTYy",
          "commit": {
            "abbreviatedOid": "961e1a1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "The new encoding scheme is great. We should make sure to implement it in hacspec. Is that something you could do? The actual hashing routine is not new, and we have text for it in the draft. Can you simply cite that section?",
          "createdAt": "2018-06-22T03:36:26Z",
          "updatedAt": "2018-06-22T03:47:38Z",
          "comments": [
            {
              "originalPosition": 189,
              "body": "This should be rewritten as map2curve_BN(t), as this is a generic encoding mechanism for BN curves.",
              "createdAt": "2018-06-22T03:36:26Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            },
            {
              "originalPosition": 212,
              "body": "Please align this with the text above.",
              "createdAt": "2018-06-22T03:36:39Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            },
            {
              "originalPosition": 207,
              "body": "Please add a space after \"-\":\r\n```\r\ns1 = (f(x1) ^ ((p - 1) / 2)) \r\n```\r\nAnd please do the same for the following lines.\r\n",
              "createdAt": "2018-06-22T03:37:04Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            },
            {
              "originalPosition": 228,
              "body": "This RO construction is not specific to BN curves, and in fact is already described in the Random Oracles section. I think we should remove it and keep only the BN encoding function.",
              "createdAt": "2018-06-22T03:37:56Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            },
            {
              "originalPosition": 141,
              "body": "\ud83d\udc4d ",
              "createdAt": "2018-06-22T03:44:12Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxMzY5NTY4",
          "commit": {
            "abbreviatedOid": "eb50b45"
          },
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you for these changes!",
          "createdAt": "2018-06-22T23:08:03Z",
          "updatedAt": "2018-06-22T23:11:19Z",
          "comments": [
            {
              "originalPosition": 185,
              "body": "Extra space between where and H1",
              "createdAt": "2018-06-22T23:08:03Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3MTA2MjQx",
          "commit": {
            "abbreviatedOid": "46872d1"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-22T20:57:28Z",
          "updatedAt": "2018-10-22T21:05:23Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think this is a latent conflict from when the names were re-ordered to be alphabetic.",
              "createdAt": "2018-10-22T20:57:28Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            },
            {
              "originalPosition": 118,
              "body": "This should ideally be addressed, something like:\r\n```\r\n8.  x = x3\r\n9.  x = CMOV(x2 ,x, 2)\r\n10. x = CMOV(x1, x, s1)\r\n```",
              "createdAt": "2018-10-22T21:00:34Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            },
            {
              "originalPosition": 205,
              "body": "```suggestion\r\nF(H2(m)) as explained in {{#ffstv}}, which will be indifferentiable from a random oracle.\r\n```",
              "createdAt": "2018-10-22T21:05:11Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3MTQzMjc4",
          "commit": {
            "abbreviatedOid": "43143b4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-10-22T22:55:06Z",
          "updatedAt": "2018-10-22T22:58:40Z",
          "comments": [
            {
              "originalPosition": 219,
              "body": "I think this section was written already -- can you please check and remove if so?",
              "createdAt": "2018-10-22T22:55:06Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            },
            {
              "originalPosition": 195,
              "body": "In #68, we removed (mod p) from each step. Should we do the same here?",
              "createdAt": "2018-10-22T22:55:37Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            },
            {
              "originalPosition": 185,
              "body": "Can we use alpha for consistency? And also include HashToBase to map it to `t`?",
              "createdAt": "2018-10-22T22:58:14Z",
              "updatedAt": "2018-10-22T23:31:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 21,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NDcwMTMw",
      "title": "Start adding recommendations table.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/21",
      "state": "MERGED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "WIP on new recommendations table.\r\n\r\nCan use this to start filling out with any applications we want to cover?",
      "createdAt": "2018-05-11T13:51:35Z",
      "updatedAt": "2019-01-25T17:03:18Z",
      "closedAt": "2018-05-14T22:46:21Z",
      "mergedAt": "2018-05-14T22:46:21Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe to add:\r\nCONIKS [(PDF)](https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-melara.pdf).\r\n\r\nUses H(m)^k as VRF with H modelled as random oracle. But probably okay as inj encoding.",
          "createdAt": "2018-05-11T14:11:43Z",
          "updatedAt": "2018-05-11T14:11:43Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Multipurpose identity-based signcryption [(PDF)](https://iacr.org/archive/crypto2003/27290382/27290382.pdf) by Xavier Boyen.\r\nMuch like all the identity-based stuff, random oracle onto pairing-friendly curve.",
          "createdAt": "2018-05-11T14:17:41Z",
          "updatedAt": "2018-05-11T14:17:41Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Both recommendations are good. The more, the merrier. ",
          "createdAt": "2018-05-11T18:31:15Z",
          "updatedAt": "2018-05-11T18:31:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NTM2NDM2",
          "commit": {
            "abbreviatedOid": "8f82b21"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-11T18:30:39Z",
          "updatedAt": "2018-05-11T18:30:39Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Is Naive supposed to be the same as injective encoding?",
              "createdAt": "2018-05-11T18:30:39Z",
              "updatedAt": "2018-05-11T18:30:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIwMDE5ODg4",
          "commit": {
            "abbreviatedOid": "8f82b21"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-14T21:38:31Z",
          "updatedAt": "2018-05-14T21:38:31Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "@samscott89 Looks good pending this comment. Feel free to merge when ACK'd!",
              "createdAt": "2018-05-14T21:38:31Z",
              "updatedAt": "2018-05-14T21:38:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIwMDM1NTgw",
          "commit": {
            "abbreviatedOid": "8f82b21"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-14T22:43:05Z",
          "updatedAt": "2018-05-14T22:43:05Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Not quite. `H(x)*G` is the naive method of hashing to the curve (technically a surjective encoding), with the significant downside that the discrete logarithm of the point (with base G) is known. Which breaks many protocols but is okay for SPEKE.",
              "createdAt": "2018-05-14T22:43:05Z",
              "updatedAt": "2018-05-14T22:44:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIwMDM1ODM3",
          "commit": {
            "abbreviatedOid": "8f82b21"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-14T22:44:25Z",
          "updatedAt": "2018-05-14T22:44:25Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Although my assumption was that this would be the most performant, which may not even be true, in which case it doesn't need to be included at all. Need to investigate when doing an overview of the approximate runtimes.",
              "createdAt": "2018-05-14T22:44:25Z",
              "updatedAt": "2018-05-14T22:44:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIwMDM2MTcy",
          "commit": {
            "abbreviatedOid": "8f82b21"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-14T22:46:10Z",
          "updatedAt": "2018-05-14T22:46:10Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Oops. I failed to see the Injective Encoding application at the bottom of this table, and forgot about the entire section at the end of the document. I presumed this was a typo. Thanks for clearing it up! ",
              "createdAt": "2018-05-14T22:46:10Z",
              "updatedAt": "2018-05-14T22:46:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIwMDM2MTk3",
          "commit": {
            "abbreviatedOid": "8f82b21"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-14T22:46:15Z",
          "updatedAt": "2018-05-14T22:46:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 24,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg5ODQ2MDQ5",
      "title": "Add first draft of generic RO construction, and separate encoding and hashing functions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/24",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a first cut at #23. It doesn't go into details regarding what is a suitable encoding for the construction, although all those considered (except Elligator2) were shown to work. (@samscott89, we should do the math and figure out if Elligator2 works.)",
      "createdAt": "2018-05-23T03:17:37Z",
      "updatedAt": "2018-05-25T23:32:43Z",
      "closedAt": "2018-05-25T23:32:43Z",
      "mergedAt": "2018-05-25T23:32:43Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89, what do you think?",
          "createdAt": "2018-05-25T18:20:16Z",
          "updatedAt": "2018-05-25T18:20:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNDg3Nzcw",
          "commit": {
            "abbreviatedOid": "b2a1e72"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I like how this is all coming together. Looking good.\r\n\r\nMy only comments are more for follow on things to do, as opposed to PR-specific changes:\r\n\r\n - Section 9 (security recommendations) is a bit redundant now, since the whole piece is shaped around that comment.\r\n - We should probably cite Brier et al. https://link.springer.com/chapter/10.1007/978-3-642-14623-7_13 as the primary reference for the general construction (they proved it for Icart function only though). And also can use the other generalized construction H(m) = f(h1(m)) + h2(m)G which you can show holds for Elligator \r\n - Should double check the algorithm recommendations against table 1 in FFSTV13.",
          "createdAt": "2018-05-25T19:22:01Z",
          "updatedAt": "2018-05-25T19:38:30Z",
          "comments": [
            {
              "originalPosition": 216,
              "body": "H0 and H1",
              "createdAt": "2018-05-25T19:22:01Z",
              "updatedAt": "2018-05-25T23:32:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNTMxMzQy",
          "commit": {
            "abbreviatedOid": "b2a1e72"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-25T22:51:13Z",
          "updatedAt": "2018-05-25T22:51:13Z",
          "comments": [
            {
              "originalPosition": 216,
              "body": ">Section 9 (security recommendations) is a bit redundant now, since the whole piece is shaped around that comment.\r\n\r\nIndeed. We can clean it up in a future PR.\r\n\r\n> We should probably cite Brier et al. https://link.springer.com/chapter/10.1007/978-3-642-14623-7_13 as the primary reference for the general construction (they proved it for Icart function only though). And also can use the other generalized construction H(m) = f(h1(m)) + h2(m)G which you can show holds for Elligator\r\n\r\nDo we really want to specify two generic mechanisms when one would suffice?\r\n\r\n> Should double check the algorithm recommendations against table 1 in FFSTV13.\r\n\r\nYep, will do post-merge.",
              "createdAt": "2018-05-25T22:51:13Z",
              "updatedAt": "2018-05-25T23:32:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 25,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkwODAzODUy",
      "title": "POC implementation and description of SWU",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/25",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-27T19:45:12Z",
      "updatedAt": "2018-05-31T19:45:54Z",
      "closedAt": "2018-05-31T19:45:54Z",
      "mergedAt": "2018-05-31T19:45:54Z",
      "mergedBy": "samscott89",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, the code is (partially?) from [2009/340](https://eprint.iacr.org/2009/340.pdf) I take it?",
          "createdAt": "2018-05-28T03:04:55Z",
          "updatedAt": "2018-05-28T03:04:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, I just implemented that algorithm. ",
          "createdAt": "2018-05-28T03:36:55Z",
          "updatedAt": "2018-05-28T03:36:55Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNjExMjQ2",
          "commit": {
            "abbreviatedOid": "ab66c9d"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Looks good so far. Out of interest, what's the source of the code/algorithm used here (i.e., is it lifted from the paper directly, or have you interpreted it?). ",
          "createdAt": "2018-05-28T02:48:10Z",
          "updatedAt": "2018-05-28T03:01:16Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "This notation for X1 etc. is a bit confusing. These are effectively inline function definitions, right? I think it might be clearer to just write `X1 = u` and so on. ",
              "createdAt": "2018-05-28T02:48:10Z",
              "updatedAt": "2018-05-29T19:40:08Z"
            },
            {
              "originalPosition": 72,
              "body": "I think these details are a little too much. I think it is sufficient to say something like \"The algorithm computes three candidate points, constructed such that at least one of them lies on the curve\".",
              "createdAt": "2018-05-28T02:56:17Z",
              "updatedAt": "2018-05-29T19:40:08Z"
            },
            {
              "originalPosition": 125,
              "body": "Should there be CMOVs here?",
              "createdAt": "2018-05-28T02:57:34Z",
              "updatedAt": "2018-05-29T19:40:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNjE1MTQw",
          "commit": {
            "abbreviatedOid": "ab66c9d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-28T03:35:41Z",
          "updatedAt": "2018-05-28T03:35:42Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Yeah, they are. I\u2019ll fix it per your suggestion!",
              "createdAt": "2018-05-28T03:35:41Z",
              "updatedAt": "2018-05-29T19:40:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNjE1MTg5",
          "commit": {
            "abbreviatedOid": "ab66c9d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-28T03:36:17Z",
          "updatedAt": "2018-05-28T03:36:17Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "Yeah, but I was going to do that for all algorithms in one swoop, in a different PR.",
              "createdAt": "2018-05-28T03:36:17Z",
              "updatedAt": "2018-05-29T19:40:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI0MDUwNzg0",
          "commit": {
            "abbreviatedOid": "acf0ed5"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-29T15:36:36Z",
          "updatedAt": "2018-05-29T15:36:37Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "I guess we should clarify (for this, and for the others) that it only works for any Weierstrauss curve? Or maybe \"curve in Weierstrauss form\"? Although I expect you could lift the encoding by just applying the suitable transformation?",
              "createdAt": "2018-05-29T15:36:37Z",
              "updatedAt": "2018-05-29T19:40:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI0MTQxNTc4",
          "commit": {
            "abbreviatedOid": "acf0ed5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-29T19:38:21Z",
          "updatedAt": "2018-05-29T19:38:21Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Right -- the Weierstrauss requirement applies for all (?) the algorithms in the document. I think it's easier to keep that pattern, and then later -- in the TODO section -- describe how to transform from one form to another.",
              "createdAt": "2018-05-29T19:38:21Z",
              "updatedAt": "2018-05-29T19:40:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI0MTQyMDY1",
          "commit": {
            "abbreviatedOid": "acf0ed5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-29T19:39:43Z",
          "updatedAt": "2018-05-29T19:39:44Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Doh, scratch that. Elligator2 is given for Montgomery curves.",
              "createdAt": "2018-05-29T19:39:43Z",
              "updatedAt": "2018-05-29T19:40:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI0NDk3ODYy",
          "commit": {
            "abbreviatedOid": "4bee51d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-30T16:56:07Z",
          "updatedAt": "2018-05-30T16:56:07Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "@samscott89 Are the latest changes good to go?",
              "createdAt": "2018-05-30T16:56:07Z",
              "updatedAt": "2018-05-30T16:56:07Z"
            }
          ]
        }
      ]
    },
    {
      "number": 31,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk0NDU2OTgw",
      "title": "hacspec implementations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/31",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Elligator2 and SWU are incomplete since there is no square root function defined for each respective curve. I'll work with the hacspec folks to get that fixed.",
      "createdAt": "2018-06-13T02:43:15Z",
      "updatedAt": "2018-06-19T20:36:05Z",
      "closedAt": "2018-06-19T20:36:04Z",
      "mergedAt": "2018-06-19T20:36:04Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the review, @franziskuskiefer!",
          "createdAt": "2018-06-13T23:08:33Z",
          "updatedAt": "2018-06-13T23:08:33Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@franziskuskiefer @samscott89 Updated the code. We'll need to adopt the square root computations when they land in mainline hacspec.",
          "createdAt": "2018-06-15T00:34:16Z",
          "updatedAt": "2018-06-15T00:34:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 OK to merge?",
          "createdAt": "2018-06-18T03:17:28Z",
          "updatedAt": "2018-06-18T03:17:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4NTg0MDQ1",
          "commit": {
            "abbreviatedOid": "a8fe21d"
          },
          "author": "franziskuskiefer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "I added a couple comments :)",
          "createdAt": "2018-06-13T22:12:06Z",
          "updatedAt": "2018-06-13T22:28:27Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "All functions must be annotated `@typechecked` to pass the hacspec checker.",
              "createdAt": "2018-06-13T22:12:07Z",
              "updatedAt": "2018-06-15T00:33:56Z"
            },
            {
              "originalPosition": 55,
              "body": "Raw Python lists aren't allowed in hacspec. You should wrap it into an array (`array([...])`).",
              "createdAt": "2018-06-13T22:15:19Z",
              "updatedAt": "2018-06-15T00:33:56Z"
            },
            {
              "originalPosition": 27,
              "body": "The return type should be `felem_t`.",
              "createdAt": "2018-06-13T22:21:20Z",
              "updatedAt": "2018-06-15T00:33:56Z"
            },
            {
              "originalPosition": 5,
              "body": "This changed to change to `refine_t` and `nat_t` to be more consistent using `_t`.",
              "createdAt": "2018-06-13T22:23:13Z",
              "updatedAt": "2018-06-15T00:33:56Z"
            },
            {
              "originalPosition": 18,
              "body": "The return type should be `felem_t`.",
              "createdAt": "2018-06-13T22:26:45Z",
              "updatedAt": "2018-06-15T00:33:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4NTk1NTgx",
          "commit": {
            "abbreviatedOid": "a8fe21d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-13T23:06:09Z",
          "updatedAt": "2018-06-13T23:06:10Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Aha! Thanks. :-)",
              "createdAt": "2018-06-13T23:06:09Z",
              "updatedAt": "2018-06-15T00:33:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4NTk1NjMx",
          "commit": {
            "abbreviatedOid": "a8fe21d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-13T23:06:24Z",
          "updatedAt": "2018-06-13T23:06:25Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Noted -- I'm going to remove this before merging anyway.",
              "createdAt": "2018-06-13T23:06:24Z",
              "updatedAt": "2018-06-15T00:33:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4NTk1Njc3",
          "commit": {
            "abbreviatedOid": "a8fe21d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-13T23:06:39Z",
          "updatedAt": "2018-06-13T23:06:40Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "ACK!",
              "createdAt": "2018-06-13T23:06:40Z",
              "updatedAt": "2018-06-15T00:33:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4NTk1NzI5",
          "commit": {
            "abbreviatedOid": "a8fe21d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-13T23:06:58Z",
          "updatedAt": "2018-06-13T23:06:58Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Indeed. I was waiting for the square root function to make it complete. For now, I'll change it to felem_t. ",
              "createdAt": "2018-06-13T23:06:58Z",
              "updatedAt": "2018-06-15T00:33:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5NzIxMzA5",
          "commit": {
            "abbreviatedOid": "adc1f15"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-18T20:18:02Z",
          "updatedAt": "2018-06-18T20:18:03Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Does this still need to be done?",
              "createdAt": "2018-06-18T20:18:02Z",
              "updatedAt": "2018-06-18T20:18:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5NzM3MTU3",
          "commit": {
            "abbreviatedOid": "adc1f15"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-18T20:59:55Z",
          "updatedAt": "2018-06-18T20:59:55Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "@samscott89  I elected not to do it, since this wouldn't go into the appendix. ",
              "createdAt": "2018-06-18T20:59:55Z",
              "updatedAt": "2018-06-18T21:00:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 33,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk3NTUyMDUz",
      "title": "Clarify Naive encoding",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/33",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-26T21:09:40Z",
      "updatedAt": "2018-07-01T20:42:02Z",
      "closedAt": "2018-07-01T20:42:02Z",
      "mergedAt": "2018-07-01T20:42:02Z",
      "mergedBy": "samscott89",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzNDY0OTkx",
          "commit": {
            "abbreviatedOid": "6534164"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-01T20:41:54Z",
          "updatedAt": "2018-07-01T20:41:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 44,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA4NDYwMzE1",
      "title": "encoding-tables",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/44",
      "state": "CLOSED",
      "author": "klcappelli",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Added curve primes and prime characteristics. Added table with possible encodings for a given curve.",
      "createdAt": "2018-08-15T02:48:48Z",
      "updatedAt": "2019-01-25T19:16:02Z",
      "closedAt": "2019-01-25T19:16:01Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@klcappelli do you plan to update this PR?",
          "createdAt": "2018-10-20T05:24:26Z",
          "updatedAt": "2018-10-20T05:24:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Overcome by events (ciphersuite additions), so closing for now. @klcappelli please re-open with requested changes when ready!",
          "createdAt": "2019-01-25T19:16:01Z",
          "updatedAt": "2019-01-25T19:16:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ2NjM4NzYy",
          "commit": {
            "abbreviatedOid": "2d9cf13"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-08-15T22:08:07Z",
          "updatedAt": "2018-08-15T22:09:32Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Some explanatory text or prologue before this table would be nice. Also, we don't have Elligator Squared or DE defined, so perhaps either add sections for them or remove them? And what is TI?",
              "createdAt": "2018-08-15T22:08:07Z",
              "updatedAt": "2018-08-15T22:09:32Z"
            },
            {
              "originalPosition": 10,
              "body": "When rendered, this is a bit more information than I expected. I think we ought to drop these two new rows, as they don't seem to help when making an encoding decision. ",
              "createdAt": "2018-08-15T22:09:30Z",
              "updatedAt": "2018-08-15T22:09:32Z"
            }
          ]
        }
      ]
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0MjIwNzg1Mzk0",
      "title": "Clarify definitions of utility functions.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/56",
      "state": "MERGED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #6, #40 and partially addresses #51.\r\n\r\nTrying to be a bit more rigorous with the HashToBase definition, and usage of the Legendre symbol computation. We could additionally specify hash functions which should be used with each field size?",
      "createdAt": "2018-10-05T18:22:55Z",
      "updatedAt": "2019-01-25T17:02:12Z",
      "closedAt": "2018-10-09T05:14:16Z",
      "mergedAt": "2018-10-09T05:14:16Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Can potentially roll #12 into this PR as well.",
          "createdAt": "2018-10-05T18:24:17Z",
          "updatedAt": "2018-10-05T18:24:17Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyNzE4MjU2",
          "commit": {
            "abbreviatedOid": "cb55b6a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "These changes look great! Merging as is.",
          "createdAt": "2018-10-09T05:14:10Z",
          "updatedAt": "2018-10-09T05:14:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 57,
      "id": "MDExOlB1bGxSZXF1ZXN0MjIzNDQ5Nzky",
      "title": "Ciphersuite changes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/57",
      "state": "MERGED",
      "author": "grittygrease",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-10-17T02:26:00Z",
      "updatedAt": "2018-10-20T05:23:31Z",
      "closedAt": "2018-10-20T05:23:31Z",
      "mergedAt": "2018-10-20T05:23:31Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY1NDM2NTAz",
          "commit": {
            "abbreviatedOid": "04997fe"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-10-17T02:33:19Z",
          "updatedAt": "2018-10-17T02:39:56Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "The title of the document uses \"hashes,\" so this seems to be inconsistent. Perhaps we can say \"encode or hash an arbitrary...\"?",
              "createdAt": "2018-10-17T02:33:19Z",
              "updatedAt": "2018-10-20T00:39:45Z"
            },
            {
              "originalPosition": 59,
              "body": "Should this be SSWU?",
              "createdAt": "2018-10-17T02:34:36Z",
              "updatedAt": "2018-10-20T00:39:45Z"
            },
            {
              "originalPosition": 59,
              "body": "Should we add \"-*\" to indicate that the Transformation is nil?",
              "createdAt": "2018-10-17T02:34:57Z",
              "updatedAt": "2018-10-20T00:39:45Z"
            },
            {
              "originalPosition": 74,
              "body": "Missing period after \"P-256\".",
              "createdAt": "2018-10-17T02:35:22Z",
              "updatedAt": "2018-10-20T00:39:45Z"
            },
            {
              "originalPosition": 110,
              "body": "I think this should say that the output is transformed with FFSTV, right?",
              "createdAt": "2018-10-17T02:39:04Z",
              "updatedAt": "2018-10-20T00:39:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NzMzNDI2",
          "commit": {
            "abbreviatedOid": "1330b82"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-20T01:32:56Z",
          "updatedAt": "2018-10-20T01:32:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 58,
      "id": "MDExOlB1bGxSZXF1ZXN0MjIzNzE2NDY4",
      "title": "Correcting some parts of the text",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/58",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR corrects some parts of the texts that are imprecise.\r\nElligator2 must consider mapping the 0 \\in Fp  to the point (0,0); thus a clear cofactor phase must be added later.",
      "createdAt": "2018-10-17T18:54:48Z",
      "updatedAt": "2018-10-18T23:36:03Z",
      "closedAt": "2018-10-18T23:36:03Z",
      "mergedAt": "2018-10-18T23:36:03Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "My editor automatically removed whitespaces at the end. ",
          "createdAt": "2018-10-17T18:55:37Z",
          "updatedAt": "2018-10-17T18:55:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY1Nzg2Nzk1",
          "commit": {
            "abbreviatedOid": "7f4e810"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me. Thanks!",
          "createdAt": "2018-10-17T18:57:26Z",
          "updatedAt": "2018-10-17T19:46:09Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "I guess this should either be \"must output\" or \"outputs\".",
              "createdAt": "2018-10-17T18:57:26Z",
              "updatedAt": "2018-10-18T23:34:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2MzMzODk1",
          "commit": {
            "abbreviatedOid": "7f4e810"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-18T23:29:22Z",
          "updatedAt": "2018-10-18T23:29:23Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "Yes -- please change this to \"outputs\". Otherwise, this looks great! Thanks!",
              "createdAt": "2018-10-18T23:29:22Z",
              "updatedAt": "2018-10-18T23:34:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2MzM1MDE4",
          "commit": {
            "abbreviatedOid": "e223a01"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-18T23:35:18Z",
          "updatedAt": "2018-10-18T23:35:18Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "Done.",
              "createdAt": "2018-10-18T23:35:18Z",
              "updatedAt": "2018-10-18T23:35:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2MzM1MTQw",
          "commit": {
            "abbreviatedOid": "e223a01"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-18T23:35:56Z",
          "updatedAt": "2018-10-18T23:35:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 59,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0NDE5MTY4",
      "title": "WIP specifics of HashToBase.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/59",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "WIP"
      ],
      "body": "Some attempts to formalize HashToBase a bit more.\r\nIncludes sage script for computing.\r\nPartially includes #54 #42 #12 ",
      "createdAt": "2018-10-19T21:50:04Z",
      "updatedAt": "2018-10-22T14:02:08Z",
      "closedAt": "2018-10-22T13:50:54Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks all for the comments.\r\n\r\nI would say the outstanding issue here is whether to standardise the use of this additional sign bit across all the algorithms. My changes reflect what that would look like.\r\nPersonally.... I'm not entirely sure it's justified. This would be a case of increasing complexity for the sake of an additional bit of security. At the same time, it has some precedent (see the [signal spec](https://signal.org/docs/specifications/xeddsa/#hashing-to-a-point-with-elligator-2), for example).\r\nThoughts?\r\n\r\nAlso, would be good to get some input about the example configurations text in C.5.2, and how to specify variable length hashing (#12). It would be good to have a precise definition here which the ciphersuites (#57) can refer to. I like the idea of using is to justify use of, e.g. SHA512 for P256 though.",
          "createdAt": "2018-10-20T15:59:44Z",
          "updatedAt": "2018-10-20T15:59:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 Will you have a chance to resolve these conflicts before tomorrow?",
          "createdAt": "2018-10-21T19:50:31Z",
          "updatedAt": "2018-10-21T19:50:31Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Could handle the conflicts, but not sure if it's ready (with respect to my comment above)",
          "createdAt": "2018-10-21T22:08:11Z",
          "updatedAt": "2018-10-21T22:08:11Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Just pushed a subset of these changes (the ones I believe don't require discussion).\r\nFor some reason I couldn't create a PR, and it fixes some broken links so I went ahead and pushed straight to master. Getting 500 errors from Github, sooo.... (@chris-wood)",
          "createdAt": "2018-10-22T03:56:28Z",
          "updatedAt": "2018-10-22T03:56:28Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Core changes made in other commit - 8f9d9a5cbb1c3994faa879e71d3656ac1aa711cf. Closing this for now.",
          "createdAt": "2018-10-22T13:50:54Z",
          "updatedAt": "2018-10-22T14:02:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NzE0OTI4",
          "commit": {
            "abbreviatedOid": "3a731c2"
          },
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "state": "DISMISSED",
          "body": "",
          "createdAt": "2018-10-19T22:29:17Z",
          "updatedAt": "2018-10-20T16:00:46Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "reduced -> reduces it",
              "createdAt": "2018-10-19T22:29:17Z",
              "updatedAt": "2018-10-22T13:50:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NzE3NDM3",
          "commit": {
            "abbreviatedOid": "3a731c2"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T22:43:46Z",
          "updatedAt": "2018-10-19T22:43:46Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "round -> floor",
              "createdAt": "2018-10-19T22:43:46Z",
              "updatedAt": "2018-10-22T13:50:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NzE3NjY2",
          "commit": {
            "abbreviatedOid": "3a731c2"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T22:45:13Z",
          "updatedAt": "2018-10-19T22:45:13Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I am not completely sure whether the hash output must be truncated. Since all the bits of the hash must contribute _in some manner_ to the value X in Fp.",
              "createdAt": "2018-10-19T22:45:13Z",
              "updatedAt": "2018-10-22T13:50:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NzE4Mjkw",
          "commit": {
            "abbreviatedOid": "3a731c2"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T22:48:58Z",
          "updatedAt": "2018-10-19T22:48:58Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Keeping one bit during all the mapping can result costly, if constant-time implementation is required.\r\nA better approach is that every suite decides a criteria for selecting square roots. \r\nFor example, for p=3 mod 4, one can choose the principal square root. \r\nAnd, for p=5 mod 8, one can choose the root x such that 0 <= x <= (p-1)/2. \r\nThese criteria must be set by the suite and not by the hash output",
              "createdAt": "2018-10-19T22:48:58Z",
              "updatedAt": "2018-10-22T13:50:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NzE5MDQw",
          "commit": {
            "abbreviatedOid": "3a731c2"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T22:53:41Z",
          "updatedAt": "2018-10-19T22:53:41Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "round -> floor",
              "createdAt": "2018-10-19T22:53:41Z",
              "updatedAt": "2018-10-22T13:50:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NzE5NDcw",
          "commit": {
            "abbreviatedOid": "3a731c2"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T22:56:15Z",
          "updatedAt": "2018-10-19T22:56:15Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "This definition is quite complicated. The number of bits of a positive integer x is floor(log2(x))+1.\r\n",
              "createdAt": "2018-10-19T22:56:15Z",
              "updatedAt": "2018-10-22T13:50:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NzUyMzkw",
          "commit": {
            "abbreviatedOid": "3a731c2"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-20T15:12:15Z",
          "updatedAt": "2018-10-20T15:12:15Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "So I'm with you on the principal square root computation. But the idea of returning an additional bit from HashToBase is to be able to cover more elements in the encoding phase. Given a properly specified principal `sqrt` function, it is still useful to be able to do `CNEG(sqrt(x), s)`, making use of the additional bit of entropy. Or perhaps a better way would be to move it to the final computation. I.e. replace `return P` with `return CNEG(P, s)`.\r\n\r\nI'm not sure I follow the claim about making it costly and relevance to constant time operations though.",
              "createdAt": "2018-10-20T15:12:15Z",
              "updatedAt": "2018-10-22T13:50:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NzUyNjI1",
          "commit": {
            "abbreviatedOid": "3a731c2"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-20T15:21:57Z",
          "updatedAt": "2018-10-20T15:21:57Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "The original idea of using `round` was to allow for primes which are slightly higher than a power of 2 to be used. E.g. mapping to 2^256 + 297, you can get away with just taking 256 bits of output, since the bias is negligible. Whereas using `floor +1` would require 257 bits, thus potentially needing another hash invocation.\r\n\r\nBUT... since this doesn't to be the case for any fields in use afaict, it probably is just over complicating things.",
              "createdAt": "2018-10-20T15:21:57Z",
              "updatedAt": "2018-10-22T13:50:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 60,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0NTY2MjQw",
      "title": "Various edits.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/60",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "For #50.",
      "createdAt": "2018-10-21T20:18:44Z",
      "updatedAt": "2018-10-22T13:49:08Z",
      "closedAt": "2018-10-22T13:49:08Z",
      "mergedAt": "2018-10-22T13:49:08Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": []
    },
    {
      "number": 64,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0Nzk4NzQ4",
      "title": "Add general CMOV implementation suggestion.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/64",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-10-22T20:10:54Z",
      "updatedAt": "2018-10-22T20:12:58Z",
      "closedAt": "2018-10-22T20:12:58Z",
      "mergedAt": "2018-10-22T20:12:58Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3MDg4MTkz",
          "commit": {
            "abbreviatedOid": "fb287f7"
          },
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-22T20:11:47Z",
          "updatedAt": "2018-10-22T20:11:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 65,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0ODAxODgx",
      "title": "More cleanup and missing details.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/65",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #38, #14, and #11.",
      "createdAt": "2018-10-22T20:22:13Z",
      "updatedAt": "2018-10-22T20:33:23Z",
      "closedAt": "2018-10-22T20:33:23Z",
      "mergedAt": "2018-10-22T20:33:23Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3MDk1MjU2",
          "commit": {
            "abbreviatedOid": "0799b43"
          },
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-22T20:29:27Z",
          "updatedAt": "2018-10-22T20:29:27Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Should be -1 according to @armfazh ",
              "createdAt": "2018-10-22T20:29:27Z",
              "updatedAt": "2018-10-22T20:31:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3MDk1NjYw",
          "commit": {
            "abbreviatedOid": "0799b43"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-22T20:30:27Z",
          "updatedAt": "2018-10-22T20:30:27Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "We were just double checking this!",
              "createdAt": "2018-10-22T20:30:27Z",
              "updatedAt": "2018-10-22T20:31:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3MDk2NTAw",
          "commit": {
            "abbreviatedOid": "67986e2"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-22T20:32:40Z",
          "updatedAt": "2018-10-22T20:32:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 67,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0ODA3MTA4",
      "title": "Fix bug in Icart definition.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/67",
      "state": "MERGED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #61.",
      "createdAt": "2018-10-22T20:40:55Z",
      "updatedAt": "2019-01-25T17:02:57Z",
      "closedAt": "2018-10-22T20:42:34Z",
      "mergedAt": "2018-10-22T20:42:34Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3MTAwMzEw",
          "commit": {
            "abbreviatedOid": "ec7ddd1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-22T20:42:29Z",
          "updatedAt": "2018-10-22T20:42:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 68,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0ODExODUy",
      "title": "Minor fixes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/68",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Added some minor fixes on the text.\r\nIn algorithms, the operations are performed over the finite field; thus removing (mod p) is more precise.",
      "createdAt": "2018-10-22T20:57:16Z",
      "updatedAt": "2019-01-25T19:08:53Z",
      "closedAt": "2019-01-25T19:08:53Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Submit a new PR based on the latest version of the draft and after our meeting.\r\n",
          "createdAt": "2019-01-25T19:08:53Z",
          "updatedAt": "2019-01-25T19:08:53Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3MTQyODI2",
          "commit": {
            "abbreviatedOid": "2413c79"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-22T22:53:38Z",
          "updatedAt": "2018-10-22T22:53:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3NDc2ODY0",
          "commit": {
            "abbreviatedOid": "2413c79"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think this is a good idea overall. But we should make sure to be more explicit in the cases which *are* over the integers. And each algorithm block should be clear to state that all operations (unless otherwise specified) are over the field.\r\n(E.g. in the Icart algorithm there is `t2 = (2*p - 1) / 3` which should be specified to be done as scalars).",
          "createdAt": "2018-10-23T15:08:02Z",
          "updatedAt": "2018-10-23T15:08:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 72,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ3Nzc3NDk2",
      "title": "Algorithm clarity + consistency",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/72",
      "state": "MERGED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Just dropping this here for now discussion in the meeting. An attempt to make the algorithms more consistent, and instrument the code for producing test vectors.",
      "createdAt": "2019-01-25T18:54:29Z",
      "updatedAt": "2019-02-09T15:59:55Z",
      "closedAt": "2019-02-09T15:59:55Z",
      "mergedAt": "2019-02-09T15:59:55Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "This will try and tackle a lot of minor issues. Relevant ones include:\r\n#40, #41, #45, #53, #55, #66, #69, #70, ",
          "createdAt": "2019-01-25T19:01:28Z",
          "updatedAt": "2019-01-25T19:01:28Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay, I claim this addresses the above issues:\r\n - #40, #70 - specified [here](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/blob/bdc2d53db28a9e0d5bde01c82527aa73669f825e/draft-irtf-cfrg-hash-to-curve.md#hashtobase-hashtobase). Prefix the input with the length (encoded as 4 bytes).\r\n - #41 - alpha is now only the bytestring input for all algorithms\r\n - #45 - corrected [here](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/72/files#diff-85468ed261a4878a3be0d009ecea2048R667)\r\n - #53 - various fixes, but square root added [here](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/72/files#diff-85468ed261a4878a3be0d009ecea2048R755)\r\n - #69 - added condition [here](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/72/files#diff-85468ed261a4878a3be0d009ecea2048R544)\r\n\r\nOpen issue is #66 - how to specify square root algorithm. Initial attempt [here](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/72/files#diff-85468ed261a4878a3be0d009ecea2048R436).\r\n",
          "createdAt": "2019-01-26T01:24:11Z",
          "updatedAt": "2019-01-26T01:24:11Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 will you have time to update this by end of the week?",
          "createdAt": "2019-02-07T15:36:27Z",
          "updatedAt": "2019-02-07T15:36:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk2Nzk4ODAy",
          "commit": {
            "abbreviatedOid": "60909de"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Overall, this a great set of changes. I have minor editorial comments. I went through each pseudocode description and tried to make sure they have not changed, though I didn't run the code. ",
          "createdAt": "2019-01-26T19:08:08Z",
          "updatedAt": "2019-01-26T19:22:29Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Can we remove this commented out code?",
              "createdAt": "2019-01-26T19:08:08Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            },
            {
              "originalPosition": 29,
              "body": "Can we give an example of how indexed values are used for clarity?",
              "createdAt": "2019-01-26T19:11:54Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            },
            {
              "originalPosition": 38,
              "body": "Can we drop a reference to Sage?",
              "createdAt": "2019-01-26T19:12:27Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            },
            {
              "originalPosition": 315,
              "body": "Can we move `n` out of the algorithm, and just specify it in the preceding textual description? ",
              "createdAt": "2019-01-26T19:14:18Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            },
            {
              "originalPosition": 291,
              "body": "Should these be `sqrt` calls?",
              "createdAt": "2019-01-26T19:14:58Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            },
            {
              "originalPosition": 18,
              "body": "I wonder if we should be specific about which curves meet `p = 3 mod 4`, so as to save the reader the extra step of looking up the prime.",
              "createdAt": "2019-01-26T19:16:22Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            },
            {
              "originalPosition": 122,
              "body": "Should we provide guidance for how to check if an element is square (is a quadratic residue)?",
              "createdAt": "2019-01-26T19:20:46Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk5MDM2NTQ1",
          "commit": {
            "abbreviatedOid": "60909de"
          },
          "author": "vadym-f",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-01T11:40:02Z",
          "updatedAt": "2019-02-01T11:40:03Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "if(legendre(z) == 1)  { \"z is a square\" case }",
              "createdAt": "2019-02-01T11:40:02Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODUwMTQ5",
          "commit": {
            "abbreviatedOid": "e775014"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-09T04:18:25Z",
          "updatedAt": "2019-02-09T04:18:25Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Done in latest.",
              "createdAt": "2019-02-09T04:18:25Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODUwMTY4",
          "commit": {
            "abbreviatedOid": "e775014"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-09T04:18:51Z",
          "updatedAt": "2019-02-09T04:18:51Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Done.",
              "createdAt": "2019-02-09T04:18:51Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODUwMzAy",
          "commit": {
            "abbreviatedOid": "e775014"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-09T04:23:54Z",
          "updatedAt": "2019-02-09T04:23:54Z",
          "comments": [
            {
              "originalPosition": 315,
              "body": "Done.",
              "createdAt": "2019-02-09T04:23:54Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODUwMzA3",
          "commit": {
            "abbreviatedOid": "e775014"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-09T04:24:02Z",
          "updatedAt": "2019-02-09T04:24:02Z",
          "comments": [
            {
              "originalPosition": 291,
              "body": "Good catch",
              "createdAt": "2019-02-09T04:24:02Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODUwMzMy",
          "commit": {
            "abbreviatedOid": "e775014"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-09T04:24:45Z",
          "updatedAt": "2019-02-09T04:24:45Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Yeah, will have a look. If most are 3 (mod 4) then even easier, can just point out the outliers.",
              "createdAt": "2019-02-09T04:24:45Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODUwMzU0",
          "commit": {
            "abbreviatedOid": "e775014"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-09T04:25:33Z",
          "updatedAt": "2019-02-09T04:25:33Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "In the unrolled code we use the legendre method. Should we explain this somewhere? Or can replace the text by the computation?",
              "createdAt": "2019-02-09T04:25:33Z",
              "updatedAt": "2019-02-09T15:59:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODY3NTMy",
          "commit": {
            "abbreviatedOid": "e775014"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-09T15:59:00Z",
          "updatedAt": "2019-02-09T15:59:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 74,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUxNjgzODIw",
      "title": "Address #48 and #36",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/74",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-02-09T16:42:47Z",
      "updatedAt": "2019-02-09T21:04:55Z",
      "closedAt": "2019-02-09T21:04:55Z",
      "mergedAt": "2019-02-09T21:04:55Z",
      "mergedBy": "samscott89",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM!",
          "createdAt": "2019-02-09T21:04:50Z",
          "updatedAt": "2019-02-09T21:04:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODc2NjY0",
          "commit": {
            "abbreviatedOid": "a9080d3"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Good additions, just a few suggestions.",
          "createdAt": "2019-02-09T20:17:41Z",
          "updatedAt": "2019-02-09T20:32:46Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "The invertible part generally doesn't hold for random oracle constructions. ",
              "createdAt": "2019-02-09T20:17:41Z",
              "updatedAt": "2019-02-09T21:02:46Z"
            },
            {
              "originalPosition": 60,
              "body": "```suggestion\r\n| Curve448 | Elligator2 {{elligator2}} | FFSTV(Elligator2)\r\n```",
              "createdAt": "2019-02-09T20:18:12Z",
              "updatedAt": "2019-02-09T21:02:46Z"
            },
            {
              "originalPosition": 44,
              "body": "This is a much nicer way to present this information :)\r\n\r\nShould we add that when in doubt, a random oracle construction is safer? As a separate note, it might be useful to include some basic intuition (in the appendix most likely) around the gaps between them.",
              "createdAt": "2019-02-09T20:28:39Z",
              "updatedAt": "2019-02-09T21:02:46Z"
            },
            {
              "originalPosition": 51,
              "body": "Maybe add a sentence to explain the FFSTV(_) notation?",
              "createdAt": "2019-02-09T20:29:26Z",
              "updatedAt": "2019-02-09T21:02:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODc3Nzg1",
          "commit": {
            "abbreviatedOid": "a9080d3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-09T20:54:05Z",
          "updatedAt": "2019-02-09T20:54:05Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Oops. I meant to say non-invertible!",
              "createdAt": "2019-02-09T20:54:05Z",
              "updatedAt": "2019-02-09T21:02:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODc3ODQ1",
          "commit": {
            "abbreviatedOid": "a9080d3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-09T20:55:30Z",
          "updatedAt": "2019-02-09T20:55:30Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Yep, will add!",
              "createdAt": "2019-02-09T20:55:30Z",
              "updatedAt": "2019-02-09T21:02:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODc3OTEw",
          "commit": {
            "abbreviatedOid": "a9080d3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-09T20:57:42Z",
          "updatedAt": "2019-02-09T20:57:42Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Yep, will do!",
              "createdAt": "2019-02-09T20:57:42Z",
              "updatedAt": "2019-02-09T21:02:46Z"
            }
          ]
        }
      ]
    },
    {
      "number": 75,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUxNzAxMjM4",
      "title": "Details square root",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/75",
      "state": "CLOSED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Solves #66.",
      "createdAt": "2019-02-09T21:58:52Z",
      "updatedAt": "2019-02-09T22:00:39Z",
      "closedAt": "2019-02-09T22:00:39Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 76,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUxNzAxMzYy",
      "title": "More details on computing constant time square root.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/76",
      "state": "MERGED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #66 .",
      "createdAt": "2019-02-09T22:01:19Z",
      "updatedAt": "2019-02-10T03:10:40Z",
      "closedAt": "2019-02-10T03:10:40Z",
      "mergedAt": "2019-02-10T03:10:40Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "For verifying the primes:\r\nhttps://sagecell.sagemath.org/?z=eJyNj00OwiAQRvdNeocvbZpAjQumYIDElRfwBK504UJt6s_5HUZpo4sqC76BPN4wNTb34XEg50woix5rUNvyCUvIxXA831Q1MRE91Omyh9XMNtcKDVTPm9V6DvdfuE94WdTYklu9G--45L6cZLHgNIEkQ7o2oz49iXitud-IvvM267kUvSEvydpk7yjZMemZ-1cvk1rrcwsuxwk-pBmMP6VPt1lWWg==&lang=sage",
          "createdAt": "2019-02-09T22:05:12Z",
          "updatedAt": "2019-02-09T22:05:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODgzMTkz",
          "commit": {
            "abbreviatedOid": "3abfe31"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-10T00:08:10Z",
          "updatedAt": "2019-02-10T00:08:11Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "s/Fieldsand/Fields and",
              "createdAt": "2019-02-10T00:08:11Z",
              "updatedAt": "2019-02-10T03:01:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODgzMjMw",
          "commit": {
            "abbreviatedOid": "3abfe31"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-10T00:09:36Z",
          "updatedAt": "2019-02-10T00:09:36Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Should we add a comment which says this is -1 mod p? (I'm assuming it is, so please correct me and help clarify if I'm wrong!)",
              "createdAt": "2019-02-10T00:09:36Z",
              "updatedAt": "2019-02-10T03:01:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODgzMjQx",
          "commit": {
            "abbreviatedOid": "3abfe31"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Approved pending two suggestions!",
          "createdAt": "2019-02-10T00:09:59Z",
          "updatedAt": "2019-02-10T00:09:59Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODg2NTQ0",
          "commit": {
            "abbreviatedOid": "235d2ba"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-10T03:02:04Z",
          "updatedAt": "2019-02-10T03:02:04Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Thanks",
              "createdAt": "2019-02-10T03:02:04Z",
              "updatedAt": "2019-02-10T03:02:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODg2NTYz",
          "commit": {
            "abbreviatedOid": "235d2ba"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-10T03:02:41Z",
          "updatedAt": "2019-02-10T03:02:41Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "It is indeed, and I agree it is worth clarifying (especially since it should be precomputed) ",
              "createdAt": "2019-02-10T03:02:41Z",
              "updatedAt": "2019-02-10T03:02:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 77,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUxNzU5MTQ3",
      "title": "Added test vectors.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/77",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #5 as well.",
      "createdAt": "2019-02-10T19:18:13Z",
      "updatedAt": "2019-02-11T22:07:14Z",
      "closedAt": "2019-02-11T22:07:14Z",
      "mergedAt": "2019-02-11T22:07:14Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Would it make sense to have some kind of easily machine-parseable artifact as well, that people can use for local tests?\r\n\r\nCan you give an example?",
          "createdAt": "2019-02-11T21:20:19Z",
          "updatedAt": "2019-02-11T21:20:19Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Might be unnecessary, but I was thinking the same information as is in the draft, but in a single text file (or one per ciphersuite), to allow people to just download the file and parse for tests. Probably unnecessary thinking about it though, easier to keep it in one place.",
          "createdAt": "2019-02-11T21:27:22Z",
          "updatedAt": "2019-02-11T21:27:22Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Bug: points calculated by Elligator2 suite must be multiplied by the cofactor at the end (Sage script does not do that). Also I consider this task is not optional as the document says.\r\n\r\n",
          "createdAt": "2019-02-11T21:47:09Z",
          "updatedAt": "2019-02-11T21:47:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @armfazh! I'll fix in a separate PR.",
          "createdAt": "2019-02-11T22:07:11Z",
          "updatedAt": "2019-02-11T22:07:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAyMzI4NzMw",
          "commit": {
            "abbreviatedOid": "614758d"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-11T20:46:55Z",
          "updatedAt": "2019-02-11T20:46:55Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Thinking about this a bit more, there are a few operations which are similar complexity. Inverses, square root, cube root, quadratic residues, are all implemented in constant time using an exponentiation of approx about p. These would all count towards the running time.\r\n\r\nMy calculation (in terms of # of field mults):\r\n - Elligator2 has one sqrt, one inv = ~2log(p)\r\n - Icart has one inv, one cube root = ~ 2log(p)\r\n - SWU has one inv, onesqrt, two qrs = 4log(p)\r\n - SimpleSWU has one inv, one sqrt, one qr. = ~3log(p)\r\n\r\n----\r\nedited to reflect optimization from below",
              "createdAt": "2019-02-11T20:46:55Z",
              "updatedAt": "2019-02-11T21:02:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAyMzMwNzcy",
          "commit": {
            "abbreviatedOid": "614758d"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "These all seem like great additions, and awesome to finally have test vectors. \r\nWould it make sense to have some kind of easily machine-parseable artifact as well, that people can use for local tests?",
          "createdAt": "2019-02-11T20:51:49Z",
          "updatedAt": "2019-02-11T20:51:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAyMzMxMjA0",
          "commit": {
            "abbreviatedOid": "614758d"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-11T20:52:48Z",
          "updatedAt": "2019-02-11T20:52:48Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "(I think that makes sense, any errors I'm blaming on a fever).",
              "createdAt": "2019-02-11T20:52:48Z",
              "updatedAt": "2019-02-11T20:52:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAyMzMxNzkz",
          "commit": {
            "abbreviatedOid": "614758d"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-11T20:54:08Z",
          "updatedAt": "2019-02-11T20:54:08Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Actually, those square roots should all be brought down to 1, our implementation is inefficient.... We should compute the square root after doing a conditional swap on the x values so we only compute it once.",
              "createdAt": "2019-02-11T20:54:08Z",
              "updatedAt": "2019-02-11T20:54:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAyMzM0OTU4",
          "commit": {
            "abbreviatedOid": "614758d"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-11T21:01:27Z",
          "updatedAt": "2019-02-11T21:01:27Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "#78 opened to solve that.",
              "createdAt": "2019-02-11T21:01:27Z",
              "updatedAt": "2019-02-11T21:01:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 78,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUyMDYyNDkw",
      "title": "Reorder conditional moves and sqrt for efficiency.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/78",
      "state": "MERGED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-02-11T21:00:56Z",
      "updatedAt": "2019-03-01T16:21:41Z",
      "closedAt": "2019-03-01T16:21:41Z",
      "mergedAt": "2019-03-01T16:21:41Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 can you update the Sage script, too?",
          "createdAt": "2019-02-11T22:08:22Z",
          "updatedAt": "2019-02-11T22:08:22Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA5NjY2MDM3",
          "commit": {
            "abbreviatedOid": "d19c96f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-01T16:20:26Z",
          "updatedAt": "2019-03-01T16:20:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 83,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUyNTIxNDQ4",
      "title": "Removes the index from HashToBase function.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/83",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes: issue #80\r\n\r\nChanges:\r\n - Description of HashToBase in main document.\r\n - Sage scripts updated.\r\n - SWU test vectors were updated.",
      "createdAt": "2019-02-13T00:34:51Z",
      "updatedAt": "2019-02-13T18:34:04Z",
      "closedAt": "2019-02-13T18:33:54Z",
      "mergedAt": "2019-02-13T18:33:54Z",
      "mergedBy": "samscott89",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed, this looks like a good change to me too.",
          "createdAt": "2019-02-13T18:33:50Z",
          "updatedAt": "2019-02-13T18:34:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzMDEzMDY4",
          "commit": {
            "abbreviatedOid": "a5bc63a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This looks good to me! And thanks for catching the other small errors, and updating the vectors.",
          "createdAt": "2019-02-13T03:12:11Z",
          "updatedAt": "2019-02-13T03:12:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 84,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUyNTIyMTQz",
      "title": "Make more emphasis on preconditions for each algorithm.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/84",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds few things about formatting of algorithms. \r\nMakes a visible separation between Weierstrass and Montgomery curves.\r\n",
      "createdAt": "2019-02-13T00:38:47Z",
      "updatedAt": "2019-03-01T16:16:25Z",
      "closedAt": "2019-03-01T16:16:25Z",
      "mergedAt": "2019-03-01T16:16:25Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": " - This PR was updated with latest master branch.\r\n - The Random Oracle section was updated to be more consistent. (related to #85)",
          "createdAt": "2019-02-13T19:34:59Z",
          "updatedAt": "2019-02-13T19:37:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNDk5MTk0",
          "commit": {
            "abbreviatedOid": "4cdd03a"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-13T23:16:42Z",
          "updatedAt": "2019-02-13T23:16:43Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Sense check: does this properly separate domains?\r\nFor example, using I can call regular Icart on inputs `alpha || 0x02`, `alpha || 0x03`, and add the outputs.\r\n\r\nI think this would only be an issue in a situation where both were exposed in the same protocol?",
              "createdAt": "2019-02-13T23:16:42Z",
              "updatedAt": "2019-03-01T16:16:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDM0OTM1",
          "commit": {
            "abbreviatedOid": "4cdd03a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-15T00:18:53Z",
          "updatedAt": "2019-02-15T00:18:53Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Agree, it is required to separate the two cases when using an encoding X with and without the random oracle property. \r\nRequires further investigation.\r\n",
              "createdAt": "2019-02-15T00:18:53Z",
              "updatedAt": "2019-03-01T16:16:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 86,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUyOTA4MTQy",
      "title": "Includes encodings for Weierstrass curves with A=0",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/86",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Changes:\r\n - Adds two new encodings FT and BF.\r\n - BF works for supersingular curves.\r\n - It is based on the suggested changes of\r\n   Ela B. Lee (#20) for the case of pairing-friendly\r\n   curves.\r\n - FT encoding supports all pairing-friendly curves.\r\n - FT also supports SECP256K1 (Bitcoin curve).\r\n\r\nAddresses: #16, #9 (partially), #39.",
      "createdAt": "2019-02-14T01:30:09Z",
      "updatedAt": "2019-03-01T16:12:19Z",
      "closedAt": "2019-03-01T16:12:18Z",
      "mergedAt": "2019-03-01T16:12:18Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "This might take some time to review. Looks great at first glance though.",
          "createdAt": "2019-02-14T01:54:20Z",
          "updatedAt": "2019-02-14T01:54:20Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The FT paper is behind a paywall. Do we have a soft copy?",
          "createdAt": "2019-02-14T02:25:06Z",
          "updatedAt": "2019-02-14T02:25:06Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> The FT paper is behind a paywall. Do we have a soft copy?\r\nhttps://www.di.ens.fr/~fouque/pub/latincrypt12.pdf",
          "createdAt": "2019-02-14T22:59:09Z",
          "updatedAt": "2019-02-14T22:59:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh please have a look!",
          "createdAt": "2019-02-20T20:03:08Z",
          "updatedAt": "2019-02-20T20:03:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM! @samscott89, can you please have a look?",
          "createdAt": "2019-02-27T00:46:49Z",
          "updatedAt": "2019-02-27T00:46:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNTQzMjQ4",
          "commit": {
            "abbreviatedOid": "ee5d184"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-14T02:20:19Z",
          "updatedAt": "2019-02-14T02:23:46Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "nit: here we use `alpha: an...` and below we use `alpha - an...`. Can we be consistent?",
              "createdAt": "2019-02-14T02:20:19Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 121,
              "body": "Why is `covering the case...` a parenthetical? Can we make it a proper sentence? Perhaos:\r\n\r\n`... and q=7 mod 12. This covers the case of q=1 mod, which is not handled by the Boneh-Franklin method.`",
              "createdAt": "2019-02-14T02:21:48Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 126,
              "body": "We should cite these curves.",
              "createdAt": "2019-02-14T02:21:59Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 146,
              "body": "Why is this an operation? Can we lift this up to somewhere above?",
              "createdAt": "2019-02-14T02:22:43Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNTQ0NDc3",
          "commit": {
            "abbreviatedOid": "ee5d184"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-14T02:26:46Z",
          "updatedAt": "2019-02-14T02:26:46Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Stupid question: on what page is this method described in the paper?",
              "createdAt": "2019-02-14T02:26:46Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDE1MzE4",
          "commit": {
            "abbreviatedOid": "ee5d184"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-14T22:59:59Z",
          "updatedAt": "2019-02-14T23:00:00Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Secction 5.2 of \"Identity-Based Encryption from the Weil Pairing\" Boneh, Franklin",
              "createdAt": "2019-02-14T23:00:00Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDMzMDE5",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-15T00:09:41Z",
          "updatedAt": "2019-02-15T00:09:41Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "Done",
              "createdAt": "2019-02-15T00:09:41Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDMzMDM5",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-15T00:09:48Z",
          "updatedAt": "2019-02-15T00:09:48Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Done",
              "createdAt": "2019-02-15T00:09:48Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDMzMDcx",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-15T00:09:54Z",
          "updatedAt": "2019-02-15T00:09:54Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "Done",
              "createdAt": "2019-02-15T00:09:54Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDMzMTI3",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-15T00:10:16Z",
          "updatedAt": "2019-02-15T00:10:16Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "Removed and explicitly stated.",
              "createdAt": "2019-02-15T00:10:16Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NTQwMjM0",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Good start! I still need to review the FT method, though I've left comments on the BF method. As an aside, can we please ensure that all expressions are written with spacing between operator terms, e.g., `3 + x * 2` instead of `3+x*2`",
          "createdAt": "2019-02-17T00:24:31Z",
          "updatedAt": "2019-02-17T00:35:36Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "It also requires that `b=1`, no? Can you explain why it works for other values of `b`?",
              "createdAt": "2019-02-17T00:24:32Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 157,
              "body": "Should we express this cube root as `(u^2 - B)^((2*q - 1)/3)`?",
              "createdAt": "2019-02-17T00:26:13Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 158,
              "body": "IIUC, the paper also describes multiplying by the cofactor (`l`). Do we need that? If not, why?",
              "createdAt": "2019-02-17T00:27:38Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 229,
              "body": "nit: s/`st`/`s*t`",
              "createdAt": "2019-02-17T00:28:43Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 234,
              "body": "nit: capitalize \"if\", and same below.",
              "createdAt": "2019-02-17T00:29:09Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 115,
              "body": "What is the purpose of this section? Do we plan to specify encodings for other curve representations?",
              "createdAt": "2019-02-17T00:29:41Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA1OTY3ODU2",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Okay, my pass with the FT algorithm is done. I think there might be one error in the description (for `x3` specifically). My other comments are editorial.",
          "createdAt": "2019-02-20T19:53:44Z",
          "updatedAt": "2019-02-20T20:02:40Z",
          "comments": [
            {
              "originalPosition": 194,
              "body": "Can you please drop a reference to Section 3, Definition 2 of the paper?",
              "createdAt": "2019-02-20T19:53:44Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 229,
              "body": "nit: `st` -> `s*t`",
              "createdAt": "2019-02-20T19:54:30Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 230,
              "body": "Can you add parentheses around (-1 + s) / 2 so that order of operations are clear? Also `tw` -> `t*w`",
              "createdAt": "2019-02-20T19:56:10Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 232,
              "body": "`x3` seems wrong. Should it be `x3 = 1 - 1/w^2`?",
              "createdAt": "2019-02-20T19:59:14Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 263,
              "body": "Can this be t, as in the paper and above description?",
              "createdAt": "2019-02-20T20:00:18Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 268,
              "body": "Can we use different values (and names -- not `ti`) for these intermediates? That would help with test vector generation.",
              "createdAt": "2019-02-20T20:00:43Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            },
            {
              "originalPosition": 294,
              "body": "Can we remove the values for `h`, as those depend on the curve? We can just say that multiplication by the cofactor is required.",
              "createdAt": "2019-02-20T20:01:54Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4MjQxNDk3",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-26T22:21:21Z",
          "updatedAt": "2019-02-26T22:21:21Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "It works for any `B` since there exist always a cubic root of any element in `Fp`.\r\n",
              "createdAt": "2019-02-26T22:21:21Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4MjQzNzQ4",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-26T22:26:38Z",
          "updatedAt": "2019-02-26T22:26:38Z",
          "comments": [
            {
              "originalPosition": 157,
              "body": "Fixed.",
              "createdAt": "2019-02-26T22:26:38Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4MjUyOTYx",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-26T22:49:41Z",
          "updatedAt": "2019-02-26T22:49:41Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "Yes, it is required to multiply by a cofactor and this is recurrent in several encodings to obtain points in a subgroup of points. For the BF encoding, the value of the cofactor varies as is dependent on the target subgroup.\r\n",
              "createdAt": "2019-02-26T22:49:41Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4MjU1NTE3",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-26T22:56:29Z",
          "updatedAt": "2019-02-26T22:56:29Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "Basically, I was planning to include encodings for \r\n 2. Montgomery curves\r\n 2.1. Elligator2 ( A!=0 )\r\n 2.2  Elligator2 specillized for  A=0 \r\n\r\nHowever, this can be discussed in the future.\r\n",
              "createdAt": "2019-02-26T22:56:29Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4MjczNTA0",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-26T23:55:20Z",
          "updatedAt": "2019-02-26T23:55:20Z",
          "comments": [
            {
              "originalPosition": 194,
              "body": "Done.",
              "createdAt": "2019-02-26T23:55:20Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4Mjc3ODY1",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T00:12:13Z",
          "updatedAt": "2019-02-27T00:12:14Z",
          "comments": [
            {
              "originalPosition": 232,
              "body": "`x3 = 1+1/w^2` is correct.\r\nIn the paper, there is a minus sign due to the squaring of sqrt(-3) produces the minus sign. ",
              "createdAt": "2019-02-27T00:12:14Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4Mjc4MTk4",
          "commit": {
            "abbreviatedOid": "be6690a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T00:13:33Z",
          "updatedAt": "2019-02-27T00:13:33Z",
          "comments": [
            {
              "originalPosition": 263,
              "body": "Done.",
              "createdAt": "2019-02-27T00:13:33Z",
              "updatedAt": "2019-02-27T00:23:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4MjgwODc5",
          "commit": {
            "abbreviatedOid": "0dc9968"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T00:24:08Z",
          "updatedAt": "2019-02-27T00:24:08Z",
          "comments": [
            {
              "originalPosition": 294,
              "body": "Done",
              "createdAt": "2019-02-27T00:24:08Z",
              "updatedAt": "2019-02-27T00:24:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4Mjg2Mzg3",
          "commit": {
            "abbreviatedOid": "0dc9968"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-27T00:46:31Z",
          "updatedAt": "2019-02-27T00:46:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 89,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU3NTc3ODg3",
      "title": "Rename HashToBase.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/89",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #88.",
      "createdAt": "2019-03-01T20:50:18Z",
      "updatedAt": "2019-03-01T21:13:31Z",
      "closedAt": "2019-03-01T21:13:31Z",
      "mergedAt": "2019-03-01T21:13:31Z",
      "mergedBy": "samscott89",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "This makes sense!",
          "createdAt": "2019-03-01T21:13:16Z",
          "updatedAt": "2019-03-01T21:13:16Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 91,
      "id": "MDExOlB1bGxSZXF1ZXN0MjYwMDY5MTkw",
      "title": "Reference for BLS curves fixed.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/91",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Solving #90 ",
      "createdAt": "2019-03-11T17:40:42Z",
      "updatedAt": "2019-03-11T18:47:48Z",
      "closedAt": "2019-03-11T18:47:48Z",
      "mergedAt": "2019-03-11T18:47:48Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzMDIwMzg2",
          "commit": {
            "abbreviatedOid": "24a84bc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-11T18:47:44Z",
          "updatedAt": "2019-03-11T18:47:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 92,
      "id": "MDExOlB1bGxSZXF1ZXN0MjYxMzgyNTIz",
      "title": "Fix non-ascii character",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/92",
      "state": "MERGED",
      "author": "samscott89",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\u2260 symbol appears as `&#8800;` in the HTML version",
      "createdAt": "2019-03-15T00:15:06Z",
      "updatedAt": "2019-03-15T01:09:23Z",
      "closedAt": "2019-03-15T01:09:23Z",
      "mergedAt": "2019-03-15T01:09:22Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": []
    },
    {
      "number": 94,
      "id": "MDExOlB1bGxSZXF1ZXN0MjYxNzAwMTcz",
      "title": "Updates the hash2base test vectors.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/94",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The reference code for hash2base is compliant with the specification in the main file.\r\nThis function must be correct as it has effect on all encodings.\r\n",
      "createdAt": "2019-03-15T21:11:33Z",
      "updatedAt": "2019-06-13T09:31:36Z",
      "closedAt": "2019-06-13T09:31:36Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh are we still waiting on Michelle\u2019s proof and PR? If so, can you please check with him?",
          "createdAt": "2019-05-02T18:37:31Z",
          "updatedAt": "2019-05-02T18:37:31Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this PR.\r\nChanges here proposed were superseded and test vectors will be stable once the definition of all functions be completed.",
          "createdAt": "2019-06-13T09:31:36Z",
          "updatedAt": "2019-06-13T09:31:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE1MjU0NjI1",
          "commit": {
            "abbreviatedOid": "5a67758"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-15T21:21:48Z",
          "updatedAt": "2019-03-15T21:21:48Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Why change this to not? Also, I think it should be `not(min_bits > hbits)`.",
              "createdAt": "2019-03-15T21:21:48Z",
              "updatedAt": "2019-03-15T21:21:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE1MjYwODY4",
          "commit": {
            "abbreviatedOid": "5a67758"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-15T21:43:24Z",
          "updatedAt": "2019-03-15T21:43:24Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "I followed what the main document states.\r\n\r\n```\r\n Preconditions:\r\n     floor(log2(p)) + 1 >= hbits\r\n```\r\nWhat would be the right equation to test?",
              "createdAt": "2019-03-15T21:43:24Z",
              "updatedAt": "2019-03-15T21:43:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE2NDgzNTQ4",
          "commit": {
            "abbreviatedOid": "5a67758"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-20T00:36:43Z",
          "updatedAt": "2019-03-20T00:36:43Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Hmm,  the spec is actually wrong here. The spec should be:\r\n\r\n```\r\nhbits >= floor(log2(p)) + 1\r\n```\r\nand the code should be:\r\n```py\r\n     assert hbits >= min_bits, \"Need at least %d bits to hash p. H only outputs %d\" % (min_bits, hbits) \r\n```\r\n(In particular, `hbits` can be equal to `min_bits` ).",
              "createdAt": "2019-03-20T00:36:43Z",
              "updatedAt": "2019-03-20T00:36:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE2NDgzNzk4",
          "commit": {
            "abbreviatedOid": "5a67758"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-20T00:38:17Z",
          "updatedAt": "2019-03-20T00:38:18Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "For my own sanity:\r\n\r\nThe output of the hash function `H` needs to output at least `log2(p) + 1` bits so that when we reduce the output of `H` by `mod p` we get as close to uniform as possible.",
              "createdAt": "2019-03-20T00:38:18Z",
              "updatedAt": "2019-03-20T00:38:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE2NDk1NTQ4",
          "commit": {
            "abbreviatedOid": "5a67758"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-20T01:43:38Z",
          "updatedAt": "2019-03-20T01:43:38Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "On reading more about this, NIST.SP.800-56Ar3 suggests taking log(p)+64 bits instead of log(p)+1 to remove statistical bias introduced by the mod. Perhaps we should follow that advice?",
              "createdAt": "2019-03-20T01:43:38Z",
              "updatedAt": "2019-03-20T01:43:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE2NDk1NjI3",
          "commit": {
            "abbreviatedOid": "5a67758"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Requesting changes to increase the number of bits extracted before modulation.",
          "createdAt": "2019-03-20T01:44:03Z",
          "updatedAt": "2019-03-20T01:44:03Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE2NTEwNzE1",
          "commit": {
            "abbreviatedOid": "5a67758"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-20T03:07:21Z",
          "updatedAt": "2019-03-20T03:07:21Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "I think that's too conservative in this case, since the bias in the output is generally pretty negligible, and feeds into an encoding algorithm which is itself biased anyway. ",
              "createdAt": "2019-03-20T03:07:21Z",
              "updatedAt": "2019-03-20T03:07:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE2NzMzNDMz",
          "commit": {
            "abbreviatedOid": "5a67758"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-20T13:55:34Z",
          "updatedAt": "2019-03-20T13:55:34Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "> ... and feeds into an encoding algorithm which is itself biased anyway\r\n\r\nThat may be the case, though I still think we should follow what seems to be best practice here, rather than deviate without cause. ",
              "createdAt": "2019-03-20T13:55:34Z",
              "updatedAt": "2019-03-20T13:55:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE2ODUyNTcy",
          "commit": {
            "abbreviatedOid": "5a67758"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-20T16:54:26Z",
          "updatedAt": "2019-03-20T16:54:27Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "The downside would be removing the validity of the SHA256-based ciphersuites. Neither P256 nor Curve25519 (which incidentally seems to be missing atm?) could be used with SHA256.\r\n\r\nFor the other combinations, we are already taking more that 64 extra (Curve448 has just about enough space).\r\n\r\nSo on one hand, we gain meeting best practice, and set stricter limits for future implementation.\r\n\r\nOn the other hand, we lose some ciphersuite combinations.",
              "createdAt": "2019-03-20T16:54:26Z",
              "updatedAt": "2019-03-20T16:54:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE3MDQyMjUw",
          "commit": {
            "abbreviatedOid": "5a67758"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-21T00:23:04Z",
          "updatedAt": "2019-03-21T00:23:04Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Are you agree with these parameters ?\r\n\r\n| bit length of primes  | size of hash |\r\n|----|-------|\r\n| 256 | SHA-512 |\r\n| 384 | SHA-512 |\r\n| 448 | SHA-512 |\r\n| 521 |  ? |\r\n\r\nAre you considering some suites with SHAKE/XOF? \r\n",
              "createdAt": "2019-03-21T00:23:04Z",
              "updatedAt": "2019-03-21T00:23:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE3MjQ4OTA3",
          "commit": {
            "abbreviatedOid": "5a67758"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-21T13:50:07Z",
          "updatedAt": "2019-03-21T13:50:08Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Yeah, the tradeoff is clear, and I'm not sure what is best. Perhaps we can email the list?",
              "createdAt": "2019-03-21T13:50:07Z",
              "updatedAt": "2019-03-21T13:50:08Z"
            }
          ]
        }
      ]
    },
    {
      "number": 97,
      "id": "MDExOlB1bGxSZXF1ZXN0MjY2ODYyNDEw",
      "title": "A major update",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/97",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I did a lot of changes in the text but I tried to keep the same structure of the document. You will notice that I remove some lines and comments. Hopefully, I did not erase something relevant; otherwise we can included again.\r\n\r\n",
      "createdAt": "2019-04-03T01:31:48Z",
      "updatedAt": "2019-04-20T01:17:18Z",
      "closedAt": "2019-04-20T01:17:18Z",
      "mergedAt": "2019-04-20T01:17:18Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "This update in the PR only solves most of the nits.\r\nIt remains as a to-do:  #99, which will be in another PR.\r\n",
          "createdAt": "2019-04-16T01:27:55Z",
          "updatedAt": "2019-04-16T01:27:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 @grittygrease any comments? If not, can we merge?",
          "createdAt": "2019-04-18T22:33:28Z",
          "updatedAt": "2019-04-18T22:33:28Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "body": "No specific comments. Thanks for the continued effort.\n\nOn Thu, Apr 18, 2019 at 3:33 PM Christopher Wood <notifications@github.com>\nwrote:\n\n> @samscott89 <https://github.com/samscott89> @grittygrease\n> <https://github.com/grittygrease> any comments? If not, can we merge?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/97#issuecomment-484711470>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABHDHZ7WIT2FAESUSHKHBHDPRDZLTANCNFSM4HDFWW7A>\n> .\n>\n",
          "createdAt": "2019-04-18T23:58:18Z",
          "updatedAt": "2019-04-18T23:58:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI1MDc2NzIw",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Great start! I left some comments and food for thought. There are a few major ones, e.g., defining hash2base and cofactor clearing. I'm happy to hop on a call to discuss any of these. \r\n\r\n(Also, as Nick suggests, please add yourself as an author!)",
          "createdAt": "2019-04-10T16:15:41Z",
          "updatedAt": "2019-04-13T00:20:23Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "For clarity, should we just make a class to store the entire set of curve parameters? Or maybe just have a factory that returns curve objects given an input string?",
              "createdAt": "2019-04-10T16:15:41Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 79,
              "body": "Should we note that this is not constant time?",
              "createdAt": "2019-04-12T23:39:59Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 56,
              "body": "nit: please spell out Edwards. I think we ought to avoid abbreviations in this code.",
              "createdAt": "2019-04-12T23:41:29Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 77,
              "body": "nit: same here -- let's please spell out Affine and Edwards",
              "createdAt": "2019-04-12T23:42:06Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 87,
              "body": "nit: maybe we should refer to these textbook implementations as \"reference\" implementations? And we could then rename the \"slp\" variants to \"constant_time\", or something?",
              "createdAt": "2019-04-12T23:43:51Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 1,
              "body": "Can we please rename this file back to its full form? ft might be misread as something else.",
              "createdAt": "2019-04-12T23:46:10Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 617,
              "body": "nit: what is \"it\" in \"it is allowed? Can we just say \"For example, some elliptic curves have order n = hr, where r is a large prime, and h is a non-negative integer known as the cofactor.\"",
              "createdAt": "2019-04-12T23:52:03Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 618,
              "body": "I would expand on the possible subgroups here. In particular, we have subgroups of order r and any multiple of h times r, right? I would then say that any encoding typically requires an encoding to a subgroup of prime order, i.e., of order r. ",
              "createdAt": "2019-04-12T23:53:56Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 621,
              "body": "I might also add that we refer to this process as \"cofactor clearing.\"",
              "createdAt": "2019-04-12T23:54:11Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 587,
              "body": "Nit: we need to define `char(p)` here, as we use it below.",
              "createdAt": "2019-04-12T23:54:56Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 637,
              "body": "s/\"For mapping to subgroup, need to multiply by cofactor.\"/\"Constant used in cofactor clearing to map to prime-order subgroup.\"?",
              "createdAt": "2019-04-12T23:55:31Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 763,
              "body": "I would remove this computation from the text. Folks may read the prior sentence, use this, and then stop reading. ",
              "createdAt": "2019-04-12T23:58:17Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 819,
              "body": "s/should/MUST?",
              "createdAt": "2019-04-12T23:59:12Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 915,
              "body": "\ud83d\udc4d ",
              "createdAt": "2019-04-13T00:00:05Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 837,
              "body": "Based on discussion, shouldn't this be at least `floor(log2(p))+64`?",
              "createdAt": "2019-04-13T00:00:49Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 837,
              "body": "If so, can we also move the rationale for this requirement to an appendix, perhaps with a sketch from Michele's proof?",
              "createdAt": "2019-04-13T00:01:43Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 852,
              "body": "nit: based on list feedback, \"as many bits as possible\" is not a meaningful requirement. We should probably be more precise here.",
              "createdAt": "2019-04-13T00:02:35Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 876,
              "body": "nit: this should be +64?",
              "createdAt": "2019-04-13T00:03:21Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 935,
              "body": "nit: missing comma after `e.g.`",
              "createdAt": "2019-04-13T00:03:42Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 940,
              "body": "s/the coordinates/the affine coordinates/?",
              "createdAt": "2019-04-13T00:03:59Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 1003,
              "body": "Can we make `3*A` a constant?",
              "createdAt": "2019-04-13T00:04:58Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 1386,
              "body": "nit: extra space between `curve` and `space`",
              "createdAt": "2019-04-13T00:09:11Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 1483,
              "body": "nit: the style of this constants list does not match that of previous sections",
              "createdAt": "2019-04-13T00:12:00Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 805,
              "body": "The code uses `sq_root` in some places. Can we make this usage consistent?",
              "createdAt": "2019-04-13T00:12:52Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 2007,
              "body": "nit: copy-paste error for these suite IDs? They're all `H2C-0000`. Maybe we should make `H2C-0000` reserved and start at `H2C-0001`? ",
              "createdAt": "2019-04-13T00:14:48Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 2017,
              "body": "It seems odd that callers of `hash2curve` may have to *also* multiply by the cofactor to get a usable point in the curve. I think we should bake this step into the algorithms, i.e., always include a step that multiplies by the cofactor in each algorithm. This works for all curves, since for curves where p=n (h=1) nothing changes.",
              "createdAt": "2019-04-13T00:17:24Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            },
            {
              "originalPosition": 2140,
              "body": "Why drop this section? I think we ought to keep it.",
              "createdAt": "2019-04-13T00:17:41Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ0MTA4",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:00:11Z",
          "updatedAt": "2019-04-16T01:00:11Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "It would be good to have the factory model that matches with recommended suites.",
              "createdAt": "2019-04-16T01:00:11Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ0MTM2",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:00:18Z",
          "updatedAt": "2019-04-16T01:00:18Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "Done",
              "createdAt": "2019-04-16T01:00:18Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ0MzI3",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:01:15Z",
          "updatedAt": "2019-04-16T01:01:15Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "Done",
              "createdAt": "2019-04-16T01:01:15Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ0MzU2",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:01:23Z",
          "updatedAt": "2019-04-16T01:01:24Z",
          "comments": [
            {
              "originalPosition": 617,
              "body": "Done",
              "createdAt": "2019-04-16T01:01:23Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ0NDU1",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:01:57Z",
          "updatedAt": "2019-04-16T01:01:57Z",
          "comments": [
            {
              "originalPosition": 618,
              "body": "I didn't get the point, could you please rephrase it.",
              "createdAt": "2019-04-16T01:01:57Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ0NTYx",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:02:32Z",
          "updatedAt": "2019-04-16T01:02:32Z",
          "comments": [
            {
              "originalPosition": 621,
              "body": "Done. The cofactor clearing section was moved before presenting encodings.",
              "createdAt": "2019-04-16T01:02:32Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ0NjI0",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:02:47Z",
          "updatedAt": "2019-04-16T01:02:47Z",
          "comments": [
            {
              "originalPosition": 587,
              "body": "Removed.",
              "createdAt": "2019-04-16T01:02:47Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ0Njcy",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:03:02Z",
          "updatedAt": "2019-04-16T01:03:03Z",
          "comments": [
            {
              "originalPosition": 637,
              "body": "Done.",
              "createdAt": "2019-04-16T01:03:02Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ0NzM0",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:03:20Z",
          "updatedAt": "2019-04-16T01:03:20Z",
          "comments": [
            {
              "originalPosition": 763,
              "body": "Good observation.",
              "createdAt": "2019-04-16T01:03:20Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ0ODc5",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:03:51Z",
          "updatedAt": "2019-04-16T01:03:51Z",
          "comments": [
            {
              "originalPosition": 819,
              "body": "Changed.",
              "createdAt": "2019-04-16T01:03:51Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ1MTgy",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:05:29Z",
          "updatedAt": "2019-04-16T01:05:29Z",
          "comments": [
            {
              "originalPosition": 915,
              "body": "Let's see how this matches with cofactor multiplication step.",
              "createdAt": "2019-04-16T01:05:29Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ2NTE1",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:12:59Z",
          "updatedAt": "2019-04-16T01:12:59Z",
          "comments": [
            {
              "originalPosition": 618,
              "body": "The text currently implies there are only two possible subgroups, one of order `r` and another of order `hr`, though that's not the case, right? Aren't there more? See https://safecurves.cr.yp.to/twist.html.",
              "createdAt": "2019-04-16T01:12:59Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ2NjUw",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:13:50Z",
          "updatedAt": "2019-04-16T01:13:50Z",
          "comments": [
            {
              "originalPosition": 837,
              "body": "This will be resolved in another PR. Currently #99 will track this issue.",
              "createdAt": "2019-04-16T01:13:50Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ2NzIw",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:14:12Z",
          "updatedAt": "2019-04-16T01:14:12Z",
          "comments": [
            {
              "originalPosition": 852,
              "body": "Tracked on #99 .",
              "createdAt": "2019-04-16T01:14:12Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ2NzU2",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:14:25Z",
          "updatedAt": "2019-04-16T01:14:25Z",
          "comments": [
            {
              "originalPosition": 876,
              "body": "Tracked on #99 ",
              "createdAt": "2019-04-16T01:14:25Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ2Nzcy",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:14:31Z",
          "updatedAt": "2019-04-16T01:14:32Z",
          "comments": [
            {
              "originalPosition": 935,
              "body": "Done",
              "createdAt": "2019-04-16T01:14:31Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ2Nzk0",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:14:38Z",
          "updatedAt": "2019-04-16T01:14:38Z",
          "comments": [
            {
              "originalPosition": 940,
              "body": "Done",
              "createdAt": "2019-04-16T01:14:38Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ2ODc3",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:15:06Z",
          "updatedAt": "2019-04-16T01:15:06Z",
          "comments": [
            {
              "originalPosition": 1003,
              "body": "Done. It was changed in the implementation, but not in the description.",
              "createdAt": "2019-04-16T01:15:06Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ2OTk5",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:15:35Z",
          "updatedAt": "2019-04-16T01:15:35Z",
          "comments": [
            {
              "originalPosition": 1386,
              "body": "done. However parser eats extra spaces.",
              "createdAt": "2019-04-16T01:15:35Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ3MTcy",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:16:38Z",
          "updatedAt": "2019-04-16T01:16:38Z",
          "comments": [
            {
              "originalPosition": 1483,
              "body": "Changed.",
              "createdAt": "2019-04-16T01:16:38Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ3Mjc4",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:17:11Z",
          "updatedAt": "2019-04-16T01:17:11Z",
          "comments": [
            {
              "originalPosition": 805,
              "body": "Good catch.",
              "createdAt": "2019-04-16T01:17:11Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ3Mzgx",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:17:42Z",
          "updatedAt": "2019-04-16T01:17:42Z",
          "comments": [
            {
              "originalPosition": 2007,
              "body": "These are TBD numbers.",
              "createdAt": "2019-04-16T01:17:42Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ3NDkw",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:18:17Z",
          "updatedAt": "2019-04-16T01:18:17Z",
          "comments": [
            {
              "originalPosition": 2017,
              "body": "Now it is included a cofactor multiplication for each encoding in the last step.",
              "createdAt": "2019-04-16T01:18:17Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ3NjU5",
          "commit": {
            "abbreviatedOid": "cea8485"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:19:15Z",
          "updatedAt": "2019-04-16T01:19:16Z",
          "comments": [
            {
              "originalPosition": 2140,
              "body": "The performance paragraph was included again now in Section 4.\r\nThe remainder of the paragraphs are also in Section 4.",
              "createdAt": "2019-04-16T01:19:15Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTQ5NDYy",
          "commit": {
            "abbreviatedOid": "986d061"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:28:54Z",
          "updatedAt": "2019-04-16T01:28:54Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Tracked in #98. \r\nCurrent PR will not handle this issue.",
              "createdAt": "2019-04-16T01:28:54Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTUxMzk3",
          "commit": {
            "abbreviatedOid": "986d061"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T01:38:54Z",
          "updatedAt": "2019-04-16T01:38:54Z",
          "comments": [
            {
              "originalPosition": 618,
              "body": "Got it, the elliptic curve, as a whole, is a group order `n=hr` (the entire curve). But, it also has several subgroups.\r\n\r\nIn the text, it should be clear that the subgroup of interest is one of prime order `r`, with `r | n` hence `n=h*r` .\r\nThe other subgroup of the curve is one of order h. \r\nHowever, `h` could be again a composite number indicating the presence of smaller subgroups inside of the group of order `h`.\r\nHope this helps.\r\n",
              "createdAt": "2019-04-16T01:38:54Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTU5MzEy",
          "commit": {
            "abbreviatedOid": "986d061"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T02:22:58Z",
          "updatedAt": "2019-04-16T02:22:58Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "We're keeping the list alphabetical, so please move your name up! :)",
              "createdAt": "2019-04-16T02:22:58Z",
              "updatedAt": "2019-04-16T17:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI3MzMzODM2",
          "commit": {
            "abbreviatedOid": "1b20fdf"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T17:17:34Z",
          "updatedAt": "2019-04-16T17:17:35Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done\r\n",
              "createdAt": "2019-04-16T17:17:35Z",
              "updatedAt": "2019-04-16T17:17:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 104,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc0MjM5Mjc1",
      "title": "omnibus: new hash2curve ; undefined cases ; sign issues ; etc.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/104",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Hello folks,\r\n\r\nUPDATE (20190430): at this point most of the work is done, barring decisions on how to proceed. Please see specific notes on the checkbox items below.\r\n\r\nThanks again for all of your hard work on this standardization effort!\r\n\r\nThis is a WIP pull request that rolls up a bunch of edits addressing a few open issues. I'm sharing now to start getting feedback and to start discussing how to handle some of the remaining open questions.\r\n\r\nI look forward to your feedback! And, of course, I'm happy to split this up into multiple PRs, squash commits, etc. as you prefer.\r\n\r\nThe issues that this PR touches are:\r\n\r\n- [x] #52 - explicitly defined a primitive `inv0` in S3 that returns 0 on input 0. Could require impl via exponentiation as suggested in that issue. ~~**TODO** decide whether to require impl via exponentiation.~~ leave this unresolved in #52\r\n\r\n- [x] #54 - ~~this is WIP. Need to decide what to do for some of these.~~ I changed the way Simplified SWU and SvdW work to match with our suggestions in the paper, and I'm happy to suggest specific changes to the others. ~~**TODO** decide whether to hash to an extra bit for Elligator (supersingular)~~\r\nUPDATE (20190429): updated sign for SvdW\r\nUPDATE (20190430): suggested how to choose sign for all of them\r\n  - [x] sign for Simplified SWU\r\n  - [x] sign for Icart (need to check the paper on this)\r\n  - [x] sign for Elligator\r\n  - [x] sign for Elligator (Edwards)\r\n  - [x] sign for Elligator (supersingular)\r\n  - [x] sign for Boneh-Franklin\r\n  - [x] sign for SWU\r\n\r\n\r\n- [x] #79, #95 - I added a subsection in 5 that talks about multiplying by the cofactor. I'm happy to go through and make sure all impls do this. Probably it is worthwhile to make specific recommendations, especially for curves with big cofactors (e.g., both of the groups of BLS12-381).\r\n~~**TODO** need to decide whether the appx will have curve-specific impls, in which case this should go there for BLS12-381 G1 and G2.~~\r\n#111 should take care of this.\r\n  - [x] general discussion of cofactor clearing\r\n  - [x] cofactor clearing discussion for BLS12-381 G1\r\n  - [x] cofactor clearing discussion for BLS12-381 G2\r\n\r\n\r\n- [x] #82 - I defined a primitive `sgn0` that returns -1 if a point is \"negative,\" in a way that is defined for fields and extensions. This can be used everywhere for fixing a specific branch of sqrt.\r\nUPDATE (20190430): probably all of the decisions to be made are now in the sign of output point discussion\r\n\r\n- [x] #96 - added support in common.sage using tags \"BLS12_381_1\" and \"BLS12_381_2\" as Hoeteck suggested.\r\n\r\n\r\n- [x] #99 - added words suggesting how many extra bits to use. ~~Can strengthen this from a recommendation to a requirement.~~ ~~**TODO**: require rather than recommend number of extra bits?~~\r\n~~UPDATE (20190430): strengthened recommendations and made explicit how to use a \"small\" hash function~~\r\nLeave this unresolved in #99.\r\n\r\n- [x] #100 - ~~WIP, because I think probably what's currently in the Fouque-Tibouchi section needs to change a bit to make handling exceptional cases easier. I suggest following our recommendations in WB19; I'm planning to push an edit to this effect in the next couple days.~~\r\nUPDATE (20190429): renamed FT to \"Shallue-van de Woestijne,\" updated recommendations for constants and recovering from exceptional cases, added implementation for Secp256k1.\r\n\r\n\r\n- [x] #101 - rolls in a description of the algorithm and relevant implementations for both G1 and G2\r\n\r\n\r\n- [x] #102 - done. There aren't any curves for which you'd pick non-simplified over simplified SWU given the generalization in WB19.\r\n\r\n\r\n- [x] #103 - ~~WIP. I made explicit the way to handle exceptions for Icart, Elligator 2, and Simplified SWU. I still need to do so for the other variants of Elligator (Edwards and A0), the Boneh and Franklin method, and the Fouque-Tibouchi (I mentioned the latter above).~~\r\nUPDATE (20190429): handled for FT\r\nUPDATE (20190430): finished\r\n  - [x] Icart\r\n  - [x] Simplified SWU\r\n  - [x] Elligator\r\n  - [x] Elligator (Edwards)\r\n  - [x] Elligator (supersingular)\r\n  - [x] Boneh-Franklin\r\n  - [x] FT / SvdW\r\n\r\n- [x] ~~update test vectors in document~~ moved to #112 \r\n\r\n- [x] ~~add discussion of points-as-bitstrings relwork (Elligator, Elligator squared, binary Elligator squared)~~ moved to #113\r\n\r\n- [x] ~~consider moving detailed impls for each of the recommended curves to the appendix.~~ Moved to #111\r\n\r\n- [x] ~~consider removing some of the unused impls (e.g., ell2edwards, fouquetibouchi)~~ moved to #112 \r\n\r\n- [x] ~~hacspec impls for new encodings?~~ moved to #112",
      "createdAt": "2019-04-29T04:09:26Z",
      "updatedAt": "2019-05-21T21:38:03Z",
      "closedAt": "2019-05-21T21:38:02Z",
      "mergedAt": "2019-05-21T21:38:02Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, yes: test vectors at the end of the file are not in sync with the changes here.\r\n\r\nTODO for later",
          "createdAt": "2019-04-29T04:13:48Z",
          "updatedAt": "2019-04-29T04:13:48Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "just pushed commits that more or less handle the open issues with FT12 (see updates marked 20190429 in original message).\r\n\r\nI renamed Fouque-Tibouchi to Shallue-van de Woestijne, which is I think the more correct terminology. But I want to be clear that I'm not ignoring Fouque and Tibouchi's contributions! I'm just trying to avoid confusion...",
          "createdAt": "2019-04-29T18:08:58Z",
          "updatedAt": "2019-04-29T18:09:11Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Update: I think at this point I've at least suggested how to address all of the above issues. I've updated the checklist accordingly.",
          "createdAt": "2019-05-01T04:14:33Z",
          "updatedAt": "2019-05-01T04:14:33Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Riad, I suggest you to make a cut-off here to review all the changes. Otherwise, the PR will get giant. I am going to review your changes.",
          "createdAt": "2019-05-02T16:01:30Z",
          "updatedAt": "2019-05-02T16:01:30Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good. Please let me know how I can make it easier! Happy to chat in person or on the phone.",
          "createdAt": "2019-05-02T18:37:20Z",
          "updatedAt": "2019-05-02T18:37:20Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam I propose @armfazh and I review the PR and then we schedule a call for sometime next week to discuss any lingering issues. Will that work?",
          "createdAt": "2019-05-02T18:38:34Z",
          "updatedAt": "2019-05-02T18:38:34Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good. Meanwhile I'll hold off on pushing the change to hash2base that we discussed via email. It's relatively self-contained, so we can just do it in a separate PR.",
          "createdAt": "2019-05-02T18:40:36Z",
          "updatedAt": "2019-05-02T18:40:36Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I dealt with most of the nits, except for the ones that require some more discussion (see above).\r\n\r\nI think most of the remaining checkboxes in the first post of this thread either need a decision or should be pushed to their own issue (or both).\r\n\r\nOnce we've landed this I'll start whittling away at the new issues I just made, plus a suggestion for hash2base that we've previously discussed.",
          "createdAt": "2019-05-19T05:31:24Z",
          "updatedAt": "2019-05-19T05:31:24Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I was going over the impl and noticed a discrepancy with the cofactor clearing method for BLS12-381 G1. I pushed the (very small) fix.",
          "createdAt": "2019-05-21T20:53:07Z",
          "updatedAt": "2019-05-21T20:53:07Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's freeze the changes on this PR. Most of the items were addressed by @kwantam, who does a great job. During the review were raised some items in the form of issues. Let's move on with this PR as is, and the next time, let's update this document incrementally.",
          "createdAt": "2019-05-21T21:07:04Z",
          "updatedAt": "2019-05-21T21:07:04Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh @chris-wood before merging this PR I recommend that we go through and check the commit messages to make sure that they don't end up closing issues that should remain open.\r\n\r\nAlso, do you want me to squash this into one commit, or keep as-is?",
          "createdAt": "2019-05-21T21:14:58Z",
          "updatedAt": "2019-05-21T21:14:58Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, just checked. Merging as-is will close #99, #100, and #102. Of these, #99 should definitely remain open. We can either re-open manually or I can rewrite the commit history. Happy to do either, please let me know what you prefer.",
          "createdAt": "2019-05-21T21:19:07Z",
          "updatedAt": "2019-05-21T21:19:22Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Please rewrite the commit history closing only the solved tickets. \r\n\r\n",
          "createdAt": "2019-05-21T21:31:17Z",
          "updatedAt": "2019-05-21T21:31:17Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh done.",
          "createdAt": "2019-05-21T21:36:19Z",
          "updatedAt": "2019-05-21T21:36:19Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1ODc0NjIx",
          "commit": {
            "abbreviatedOid": "d6e0d67"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "First partial pass complete. More to come. Great stuff so far!",
          "createdAt": "2019-05-09T23:49:57Z",
          "updatedAt": "2019-05-10T00:16:14Z",
          "comments": [
            {
              "originalPosition": 483,
              "body": "nit: I'd revert this change since `m` is used as input to `F` and, to me, `m` reads better.",
              "createdAt": "2019-05-09T23:49:57Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 486,
              "body": "```suggestion\r\nIBE schemes {{BF01}}. When the required encoding is not clear, applications\r\n```",
              "createdAt": "2019-05-09T23:50:23Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 586,
              "body": "Do we want this to be constant time? If so, this doesn't achieve that, does it? (Runtime seems to be a function of `x_i`.)",
              "createdAt": "2019-05-09T23:55:24Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 638,
              "body": "```suggestion\r\nhash2base should map its input to a uniformly random element of F.\r\n```",
              "createdAt": "2019-05-09T23:56:37Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 651,
              "body": "nit: this should clarify that the results fo each invocation of H are concatenated, and point to the algorithm implementation below. (Maybe also label that section?)",
              "createdAt": "2019-05-09T23:57:57Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 731,
              "body": "nit: maybe reference the NIST curves as an example?",
              "createdAt": "2019-05-10T00:01:45Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 749,
              "body": "This paragraph ends on a cliffhanger! What is the trick? Is it specified? If not, perhaps this belongs in an appendix?",
              "createdAt": "2019-05-10T00:02:35Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 669,
              "body": "s/`msg`/`alpha` to be consistent with use of `hash2base` in the rest of the document?",
              "createdAt": "2019-05-10T00:03:21Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 1005,
              "body": "nit: comment is not aligned with the others. Was that due to column overflow?",
              "createdAt": "2019-05-10T00:09:24Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1OTE1OTE2",
          "commit": {
            "abbreviatedOid": "d6e0d67"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-10T03:55:23Z",
          "updatedAt": "2019-05-10T03:55:24Z",
          "comments": [
            {
              "originalPosition": 483,
              "body": "Sure, that works. Or we can make it\r\n\r\n    F(k, msg) = k * H(msg)\r\n\r\nThe reason I went through getting rid of `m` in this context is because the document defines `q = p^m` elsewhere and I was hoping to avoid overloading.\r\n\r\nWhat do you think?",
              "createdAt": "2019-05-10T03:55:23Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1OTE5NjA2",
          "commit": {
            "abbreviatedOid": "896a906"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-10T04:20:54Z",
          "updatedAt": "2019-05-10T04:20:55Z",
          "comments": [
            {
              "originalPosition": 586,
              "body": "D'oh, great catch! I pushed a fix.",
              "createdAt": "2019-05-10T04:20:54Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1OTIwMDE5",
          "commit": {
            "abbreviatedOid": "e1a25a8"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-10T04:23:41Z",
          "updatedAt": "2019-05-10T04:23:41Z",
          "comments": [
            {
              "originalPosition": 1005,
              "body": "Yes, was trying to prevent the HTML version from needing a horizontal scrollbar for this code snippet. Which style do you prefer?",
              "createdAt": "2019-05-10T04:23:41Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1OTIwNzU0",
          "commit": {
            "abbreviatedOid": "e1a25a8"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-10T04:28:09Z",
          "updatedAt": "2019-05-10T04:28:10Z",
          "comments": [
            {
              "originalPosition": 749,
              "body": "Haha, sorry for the cliffhanger.\r\n\r\nAn appendix seems like the right place for this trick. Putting it here would probably be a big distraction.\r\n\r\nThis touches on something we can chat about next week: it seems like (maybe in the appx) we should give optimized implementations for the standard curves (whatever that means... but probably at least P256, secp256k1, Curve25519, Curve448, BLS12-381, ...). In that case, at least for BLS12-381 we'd also end up specifying how to clear the cofactor quickly.",
              "createdAt": "2019-05-10T04:28:10Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1OTIyMjIw",
          "commit": {
            "abbreviatedOid": "d3ce62f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-10T04:38:38Z",
          "updatedAt": "2019-05-10T04:38:38Z",
          "comments": [
            {
              "originalPosition": 651,
              "body": "Good catch! Done.",
              "createdAt": "2019-05-10T04:38:38Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1OTI2MDU0",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-10T05:04:11Z",
          "updatedAt": "2019-05-10T05:04:11Z",
          "comments": [
            {
              "originalPosition": 731,
              "body": "Good idea. Done.",
              "createdAt": "2019-05-10T05:04:11Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1OTI3MTA5",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-10T05:10:58Z",
          "updatedAt": "2019-05-10T05:10:58Z",
          "comments": [
            {
              "originalPosition": 669,
              "body": "Sure. Is it OK if I roll this into the changes to hash2base that we discussed via email (referenced in a comment above)?",
              "createdAt": "2019-05-10T05:10:58Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1OTI3NTkw",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-10T05:13:56Z",
          "updatedAt": "2019-05-10T05:13:56Z",
          "comments": [
            {
              "originalPosition": 669,
              "body": "Also: do you think a global msg -> alpha replacement, or just local to this definition?\r\n\r\n(Also, I suppose it's worth mentioning the other obvious option: we could do alpha -> msg instead...)",
              "createdAt": "2019-05-10T05:13:56Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM2MTY0OTcw",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-10T15:19:06Z",
          "updatedAt": "2019-05-10T15:19:07Z",
          "comments": [
            {
              "originalPosition": 483,
              "body": "Agreed -- let's go with your suggestion to avoid confusion! ",
              "createdAt": "2019-05-10T15:19:06Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM2MTY1NDUy",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-10T15:19:58Z",
          "updatedAt": "2019-05-10T15:19:58Z",
          "comments": [
            {
              "originalPosition": 669,
              "body": "Hmm, I think just doing it locally is probably fine for now. Though I'm curious to hear what @armfazh and @samscott89 think.",
              "createdAt": "2019-05-10T15:19:58Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM2MTY1NjY3",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-10T15:20:21Z",
          "updatedAt": "2019-05-10T15:20:21Z",
          "comments": [
            {
              "originalPosition": 1005,
              "body": "Lack of overflow is best, so let's keep it as is.",
              "createdAt": "2019-05-10T15:20:21Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5MjE3NDU3",
          "commit": {
            "abbreviatedOid": "6f70a30"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-19T00:57:46Z",
          "updatedAt": "2019-05-19T00:57:47Z",
          "comments": [
            {
              "originalPosition": 749,
              "body": "Agreed!",
              "createdAt": "2019-05-19T00:57:47Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5MjE3NDk2",
          "commit": {
            "abbreviatedOid": "c66051f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "OK, this is a tremendously massive and ambitious PR. Many thanks, @kwantam! \r\n\r\nI went through the new BLS map2curve algorithm (from the paper) and I think it's correct. I went through the `q = 3 mod 4` Elligator2 implementation, too, and that seemed fine. I did not check the other optimized variants. My comments are mostly nits, with questions affecting perhaps the scope and structure of the document. We don't need to address them all here, so please feel free to file issues such that we can address them later if desired. ",
          "createdAt": "2019-05-19T01:00:06Z",
          "updatedAt": "2019-05-19T01:50:46Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "nit: missing terminal period",
              "createdAt": "2019-05-19T01:00:06Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 6,
              "body": "nit: missing spaces around `-` in `q-2`",
              "createdAt": "2019-05-19T01:31:26Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 53,
              "body": "nit: what happened to constant #2?",
              "createdAt": "2019-05-19T01:34:00Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 82,
              "body": "nit: missing spaces around `=` in `e2=True`",
              "createdAt": "2019-05-19T01:35:05Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 29,
              "body": "Perhaps we should re-write this section as a series of algorithms for the different conditions? That might help ease implementation should people choose to use one of them.",
              "createdAt": "2019-05-19T01:36:04Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 94,
              "body": "nit: missing spaces around `=`",
              "createdAt": "2019-05-19T01:37:14Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 98,
              "body": "nit: s/Elligator 2/Elligsator2",
              "createdAt": "2019-05-19T01:37:29Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 99,
              "body": "nit: missing spaces around `=`",
              "createdAt": "2019-05-19T01:41:07Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 157,
              "body": "Should we generalize the Montgomery->Edwards point conversion function? (I would have benefited from such a function being written in cleartext *somewhere* earlier this year.) We might then also include conversion from, say, Weierstrass to Montgomery, among others.",
              "createdAt": "2019-05-19T01:45:50Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 34,
              "body": "Unrelated to your change, but can we rename this to `hash2curve`? (I would now assume that hash implies RO functionality. Does it have the same meaning for you?)",
              "createdAt": "2019-05-19T01:47:21Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 9,
              "body": "Should we add a matching Python/Sage implementation? (Not in this PR -- we can do that in a separate one.)",
              "createdAt": "2019-05-19T01:48:08Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 5,
              "body": "nit: perhaps put parentheses around `W * b` for clarity?",
              "createdAt": "2019-05-19T01:48:48Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5MjIwOTg2",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-19T04:51:57Z",
          "updatedAt": "2019-05-19T04:51:57Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "I think I've cleaned all these up now.",
              "createdAt": "2019-05-19T04:51:57Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5MjIxMDEy",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-19T04:53:25Z",
          "updatedAt": "2019-05-19T04:53:25Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "It looks like in the other impls, named constants are just used directly. In other words, rather than using `c2 = Z`, other impls just use `Z` directly. I did the same here, which killed the old `c2`, and just forgot to renumber.\r\n\r\nDo we want to revisit this style decision throughout?",
              "createdAt": "2019-05-19T04:53:25Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5MjIxMTA2",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-19T04:59:20Z",
          "updatedAt": "2019-05-19T04:59:21Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "this seems to be a pervasive issue that I didn't quite manage to fix. I opened #105 about this, because fixing all of them would be a pretty huge diff to tack on to this one.",
              "createdAt": "2019-05-19T04:59:20Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5MjIxMTIx",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-19T05:00:45Z",
          "updatedAt": "2019-05-19T05:00:46Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "The Elligator paper puts a space between \"Elligator\" and \"2\", and I tried to be consistent with that.\r\n\r\nIf your preference is to remove the space everywhere, I'm happy to open another issue.",
              "createdAt": "2019-05-19T05:00:45Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5MjIxMTI0",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-19T05:01:11Z",
          "updatedAt": "2019-05-19T05:01:11Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "Opened #105 to decide on fix and handle document-wide.",
              "createdAt": "2019-05-19T05:01:11Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5MjIxMTcx",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-19T05:04:41Z",
          "updatedAt": "2019-05-19T05:04:41Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Created #106 ",
              "createdAt": "2019-05-19T05:04:41Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5MjIxMzUy",
          "commit": {
            "abbreviatedOid": "d7a3127"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-19T05:15:42Z",
          "updatedAt": "2019-05-19T05:15:42Z",
          "comments": [
            {
              "originalPosition": 157,
              "body": "Opened #107 about this\r\n\r\nNote that while Montgomery -> Weierstrass is easy, the opposite isn't guaranteed to exist, but it's relatively easy to write down the necessary and sufficient conditions for its existence (due to [Okeya, Kurumatani, and Sakurai, PKC 2000](https://doi.org/10.1007%2F978-3-540-46588-1_17))",
              "createdAt": "2019-05-19T05:15:42Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5MjIxNTQ1",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-19T05:26:42Z",
          "updatedAt": "2019-05-19T05:26:42Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "That makes sense. The version I added to common.sage for this PR gives the same answer but probably ends up obfuscated for trying to be too clever.\r\n\r\nI added #108 for this.",
              "createdAt": "2019-05-19T05:26:42Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5NTY2MzQ3",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-20T15:17:37Z",
          "updatedAt": "2019-05-20T15:17:37Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Ah, sorry, I meant that the list of constants is missing a second item! It has #1 and #3.",
              "createdAt": "2019-05-20T15:17:37Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5NzQ4NjA5",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "This PR has a lot of changes. \r\nI posted some questions for some issues must be discussed.\r\nI didn't check the sage files, I only focused on the main document.",
          "createdAt": "2019-05-20T22:20:37Z",
          "updatedAt": "2019-05-21T02:01:27Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "This is the full name \"Progress in Cryptology - LATINCRYPT 2012\"",
              "createdAt": "2019-05-20T22:20:37Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 181,
              "body": "Unfortunately, this must be an ASCII document.",
              "createdAt": "2019-05-20T22:21:55Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 447,
              "body": "i.e., as ~~vectors of~~ m elements of GF(p) ~~where vector elements are~~ written in ascending order",
              "createdAt": "2019-05-20T22:31:42Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 455,
              "body": "~~Each of these forms defines a category of curve equations that is sometimes called a \"curve shape.\"~~",
              "createdAt": "2019-05-20T22:34:44Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 462,
              "body": "~~non-negative~~",
              "createdAt": "2019-05-20T22:37:16Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 465,
              "body": "This line must refer to the points on the curve that have order multiple of `r`. Thus, by multiplying by `h` will give us a point `hP` that is in the subgroup of order `r`.\r\n",
              "createdAt": "2019-05-20T22:43:12Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 469,
              "body": " the curve ~~shape~~ form",
              "createdAt": "2019-05-20T22:43:43Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 29,
              "body": "Regarding square-root calculation.\r\n\r\nWe have faced the problem of root selection vs fixed algorithm for calculating square roots. Each method has pros/cons, but in my opinion the easiest way is to calculate the root and then select one using, for example, the `sign` function.\r\n\r\nSince we cannot cover all the cases for sqrt, the definition of the `sqrt` function should be simpler. The algorithms for the well-known cases could be attached in an appendix.\r\n\r\n\r\n\r\n",
              "createdAt": "2019-05-21T00:40:52Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 582,
              "body": "s/sgn0/sgn/\r\n\r\nThe classic definition sets `sgn(0)=0` easing the implementation of `sgn` for extension fields.\r\n\r\nIf required, other predicates such as `isNegative(x)= {true, false}` can be defined on top of the `sgn` function.",
              "createdAt": "2019-05-21T00:45:07Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 585,
              "body": "~~See {{bg-curves}} for a discussion of representing x as a vector.~~",
              "createdAt": "2019-05-21T00:45:38Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 593,
              "body": "-1,0,1",
              "createdAt": "2019-05-21T00:45:55Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 9,
              "body": "It is desired that the sage files contain explicit and easily to understand implementations. We can work on this in a further PR.",
              "createdAt": "2019-05-21T00:47:23Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 9,
              "body": "It maybe better to have a pseudo-code description (using `if`/`else`, if required) and then a constant-time implementation of it (using CMOV).",
              "createdAt": "2019-05-21T00:49:01Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 607,
              "body": "\r\nThis can be stated as: \r\n > This function extends the definition of a multiplicative inverse for all F by fixing inv(0) = 0.",
              "createdAt": "2019-05-21T00:51:52Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 641,
              "body": "I noticed the change `m` -> `msg` however, I prefer to use a variable, since the content is an arbitrary string. In fact, the random oracle construction modifies the actual input of the hash2base, e.g., hash2base(m || 0).",
              "createdAt": "2019-05-21T00:55:04Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 646,
              "body": "This paragraph can be removed.",
              "createdAt": "2019-05-21T00:58:00Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 713,
              "body": "I am not agree with this implementation. \r\n\r\nThe concatenation of hash outputs does not produce a stronger hash output. \r\n\r\n\r\n",
              "createdAt": "2019-05-21T01:02:34Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 661,
              "body": "As mentioned in #99, it is required a hash function that outputs at least k more bits than the size of the prime, where k is the security parameter.\r\n\r\nA problem that arises is to find large enough hash functions for large curves. We can think on including XOF in replacement. This topic can be moved to the main list seeking for guidance.\r\n\r\n\r\n",
              "createdAt": "2019-05-21T01:12:40Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 673,
              "body": " Pre-hashing must be done at a higher level by the user of a hashing suite. At this point, the definition of hash2base must be as generic as possible.",
              "createdAt": "2019-05-21T01:14:27Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 669,
              "body": "I prefer to use short variable names. \r\nHere there is no message unlike the case of encryption or signatures.\r\n`msg` could be the initial input at the very top level.",
              "createdAt": "2019-05-21T01:17:27Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 713,
              "body": "For example \r\nSHA256(X||0) || SHA256(X||1)\r\nis not equal to \r\nSHA512(X)\r\nin the sense of **security**.\r\n",
              "createdAt": "2019-05-21T01:18:39Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 713,
              "body": "It is hard to tell now a better approach. \r\nFor 256-bit fields, one can use either SHA384 or SHA512. However, for larger fields larger hashes are required.",
              "createdAt": "2019-05-21T01:22:38Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 739,
              "body": "This section can be more general for example: `Map To Subgroup`\r\nbecause this step ensures that the point obtained by the encoding is in the subgroup of order `r`.\r\n\r\nThere are three techniques to do that which are not strictly multiplication by `h`:\r\n1. The trivial h=1, it does nothing. (The case of prime order curves.)\r\n2. The classical, cofactor clearing, is exactly multiplying P times h. (Most of the cases.)\r\n3. The one used for pairing curves, which is multiplying P by h*c for some integer c. (the variants of Scott, Fuentes, and Budroni and recently the Scott trick in Wahby's paper.)\r\n\r\nHence, `Map To Subgroup` can be described as a more general task for sending points to a prime subgroup.\r\n\r\n\r\n\r\n",
              "createdAt": "2019-05-21T01:29:45Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 749,
              "body": "I think at this point, the draft should mention or give pointer to the algorithms. \r\nThe description of the actual algorithms seems to me is out of the scope of this draft. (maybe in the pairing draft is a good place) or attaching them on an appendix.",
              "createdAt": "2019-05-21T01:32:31Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 771,
              "body": "I am totally agree with this approach, however I think we must emphasize why this decision was taken and it is not arbitrary.",
              "createdAt": "2019-05-21T01:35:24Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 780,
              "body": "This can be rephrased with something like this.\r\n> Some encodings (as described in the literature) have exceptional cases. However, this section presents some modifications on top of the encodings that have no exceptional cases.",
              "createdAt": "2019-05-21T01:38:03Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 816,
              "body": "This can be changed by setting the proper `y`-coordinate at the end.\r\nFor example, \r\n`y = sgn(u) * y`\r\nin the cases were applies.",
              "createdAt": "2019-05-21T01:40:27Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 819,
              "body": "Previously was mentioned that the encodings presented will have no exceptions. Hence, this section can introduce some misunderstanding. It is better to handle the exceptions internally though arithmetic operations and remove this section.\r\nThis applies for all the encodings.",
              "createdAt": "2019-05-21T01:42:09Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 835,
              "body": "As I suggested to use a more general section called `map to Subgroup`\r\nI think it is ok to return only the (x,y) coordinates. As the `mapping to subgroup` function is dependent of the curve, hence this can be specified per suite basis.",
              "createdAt": "2019-05-21T01:45:04Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 1100,
              "body": "Elligator 2 method applies for any field. I do not see any difference between making special cases for 3 mod 4 and 5 mod 8. The only change is the calculation of the square-root, which must be handled by the `sqrt` function defined above.\r\n",
              "createdAt": "2019-05-21T01:49:10Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 1263,
              "body": "I do not understand why the previous version was changed?\r\nThe previous formulas directly compute a point in a twisted Edwards curve.\r\n",
              "createdAt": "2019-05-21T01:51:49Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 157,
              "body": "I think that conversions are well-known, hence pointers to the original papers should be enough.",
              "createdAt": "2019-05-21T01:53:37Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 1436,
              "body": "Maybe some curious reader can ask why to fix to a positive root.",
              "createdAt": "2019-05-21T01:55:19Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            },
            {
              "originalPosition": 2071,
              "body": "I am not sure whether this description is in the scope of hash2curve draft.",
              "createdAt": "2019-05-21T01:59:34Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODIyOTA2",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T04:45:47Z",
          "updatedAt": "2019-05-21T04:45:47Z",
          "comments": [
            {
              "originalPosition": 749,
              "body": "@armfazh agreed, this seems like a possible option. The only issue is, it's not obvious (to me) what the overall intent is. To be explicit, it seems like there are two options:\r\n\r\n1. For each of a set of curves that are \"of interest\" (i.e., in common use---obviously Curve25519, but perhaps also BLS12-381...) give a full description of an optimized hash-to-curve implementation.\r\n\r\n2. Describe the maps in a general way and leave implementors to \"figure out the details\" for the curves they care about.\r\n\r\nFrom my perspective, (1) seems pretty workable---there are only a few curves that anyone will realistically use, and if this document is geared toward implementors, then they will appreciate being told in a careful way how to get good performance right off the bat.",
              "createdAt": "2019-05-21T04:45:47Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODIzMTk2",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T04:47:14Z",
          "updatedAt": "2019-05-21T04:47:14Z",
          "comments": [
            {
              "originalPosition": 669,
              "body": "How about we take this into a separate issue / discussion / PR? It would be good to settle on conventions throughout the document (variable names, spacing, etc.), and that's more or less orthogonal to settling on the content.",
              "createdAt": "2019-05-21T04:47:14Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODIzMjc5",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T04:47:29Z",
          "updatedAt": "2019-05-21T04:47:30Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Got it. Thanks, fixed!",
              "createdAt": "2019-05-21T04:47:29Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODI0MDA0",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T04:50:57Z",
          "updatedAt": "2019-05-21T04:50:58Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Sure, that's fine. From my perspective it's somewhat nonstandard to write out the full conference name---there's no ambiguity, certainly---but I have no particular objections.",
              "createdAt": "2019-05-21T04:50:57Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODI1NTk3",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T04:59:48Z",
          "updatedAt": "2019-05-21T04:59:48Z",
          "comments": [
            {
              "originalPosition": 1100,
              "body": "Sorry, that's not quite correct.\r\n\r\nThe reason is that the implementations described here are optimized in a way that makes non-black-box use of the sqrt function. See lines 13--16 of this algorithm description, and compare with lines 10--19 of the algorithm for p = 5 mod 8. This optimization is described in the 3rd paragraph of Section 5.5 of the Elligator paper.\r\n\r\nI think there's a higher-level issue to be discussed here, which I also mentioned in a response above: does this document want to be a general guide for these algorithms, or does it want to give specific implementation advice for curves of interest? If the latter, then these should be broken out and treated separately, because sqrt() is not just a black box here.\r\n\r\nBy the way, the same is true for Simplified SWU: one can avoid computing a second square root with non-black-box use of sqrt().\r\n\r\nOne final thought: if this document ends up describing algorithms for projective coordinates (which are better from an efficiency perspective), then there will be even more non-black-box use of sqrt to avoid taking multiplicative inverses.\r\n\r\nFrom my perspective, giving implementors the best possible implementations will make this document most useful to them. But of course there are plenty of arguments in both directions.",
              "createdAt": "2019-05-21T04:59:48Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODI2MTI1",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T05:02:46Z",
          "updatedAt": "2019-05-21T05:02:46Z",
          "comments": [
            {
              "originalPosition": 1263,
              "body": "The reason I suggest making this change is because the prior version was incredibly inefficient---it requires something like five exponentiations. This one requires at the very worst three, and that can be reduced to just one if implemented in projective coordinates.\r\n\r\nBeyond that, using the same mapping for Montgomery and Edwards means that the same implementation can be used for multiple purposes, which is a pretty clear win from a practical perspective.",
              "createdAt": "2019-05-21T05:02:46Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODI2NTY2",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T05:05:06Z",
          "updatedAt": "2019-05-21T05:05:06Z",
          "comments": [
            {
              "originalPosition": 1436,
              "body": "You're totally right---what I wrote here doesn't make any sense. Just like in the other cases, this one should set sgn0(u) == sgn0(y). I will push a fix for this.",
              "createdAt": "2019-05-21T05:05:06Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODI3MjA0",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T05:08:21Z",
          "updatedAt": "2019-05-21T05:08:22Z",
          "comments": [
            {
              "originalPosition": 2071,
              "body": "You're totally right. I added this for completeness, but it may be that this section should go.\r\n\r\nThe argument in favor of having it is that the description of applying Simplified SWU to pairing-friendly curves is maybe incomplete without something along these lines. But on the other hand, that might be OK---implementors aren't likely to be doing this kind of thing for themselves, and the document can just include the isogeny maps for the curves it covers (e.g., BLS12-381).",
              "createdAt": "2019-05-21T05:08:21Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODI3ODI5",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T05:11:28Z",
          "updatedAt": "2019-05-21T05:11:29Z",
          "comments": [
            {
              "originalPosition": 465,
              "body": "Sorry, I don't quite understand the issue here. Can you please explain?\r\n\r\nMultiplying any point by h will return a point in the subgroup of order r. Of course, it might return the identity point, but that's fine---it's also in the subgroup. So it's not obvious to me why it's necessary to talk about points having order a multiple of r.\r\n\r\nSorry if I'm not understanding...",
              "createdAt": "2019-05-21T05:11:28Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODI4MzQ0",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T05:14:15Z",
          "updatedAt": "2019-05-21T05:14:16Z",
          "comments": [
            {
              "originalPosition": 582,
              "body": "I'm aware that the definition of `sgn` returns 0 for 0, but that's not the intent here.\r\n\r\nThe reason I called this `sgn0` is, there is never a need to have a separate case for the sign of 0, nor is there a need for a separate `isNegative` function.\r\n\r\nOf course I'm happy to rename the function to `isNegative` if that seems more reasonable! The point is just that there's no need for a true signum function. The reason for `sgn0` is that it dovetails nicely with `inv0`---in both cases, the appended `0` is indicating \"this function does something slightly special with 0\".",
              "createdAt": "2019-05-21T05:14:16Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODI4NjQz",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T05:15:55Z",
          "updatedAt": "2019-05-21T05:15:56Z",
          "comments": [
            {
              "originalPosition": 585,
              "body": "Pardon, but why get rid of the reference? It seems reasonable as a way to avoid confusion here.",
              "createdAt": "2019-05-21T05:15:56Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODI4Njc2",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T05:16:09Z",
          "updatedAt": "2019-05-21T05:16:10Z",
          "comments": [
            {
              "originalPosition": 593,
              "body": "See comment above. This is not a signum function.",
              "createdAt": "2019-05-21T05:16:10Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODI5MDU1",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T05:18:14Z",
          "updatedAt": "2019-05-21T05:18:14Z",
          "comments": [
            {
              "originalPosition": 641,
              "body": "In another comment I proposed to leave questions of variable naming and other conventions to a separate issue and discussion. If that's OK, I'll make an issue for it.\r\n\r\nThe reason I suggested avoiding `m` is that this name is already used for the extension field degree, and I was hoping to avoid overloading variable names.",
              "createdAt": "2019-05-21T05:18:14Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODM1MDkx",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T05:48:24Z",
          "updatedAt": "2019-05-21T05:48:24Z",
          "comments": [
            {
              "originalPosition": 713,
              "body": "Pardon, but this comment appears to be false.\r\n\r\nThe reason is that here we are modeling H as a PRF, so the difference in collision resistance doesn't apply. And of course, concatenating two outputs of a PRF *does* give more (pseudo)randomness, which is all that's required here---the point is just to produce an element of GF(p) indistinguishable from uniformly random.\r\n\r\nExpanding a bit, obviously if we model H as a random oracle there's no practical distinction between two evaluations of SHA256 and one of SHA512. In terms of concrete security, I am not aware of any work on the concrete security of using any member of the SHA-2 family as a PRF, but in general it appears that most practical work treats SHA256 as a 256-bit-secure PRF, which is more than adequate even for Ed448, the highest-security curve mentioned anywhere in this document.\r\n\r\nAnecdotally, the consensus of the BLS signatures working group in a discussion a couple weeks ago was that using 2 evaluations of SHA256 was preferable to 1 evaluation of SHA512.",
              "createdAt": "2019-05-21T05:48:24Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODM1NzYy",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T05:51:23Z",
          "updatedAt": "2019-05-21T05:51:23Z",
          "comments": [
            {
              "originalPosition": 661,
              "body": "See my comment above. Under standard assumptions it's just not necessary to use a hash with a wide output.\r\n\r\nIn any case, this document is probably not the right place to make recommendations about which hash functions to use as PRFs, and almost certainly not a place to start recommending little-used constructions like SHAKE.",
              "createdAt": "2019-05-21T05:51:23Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODM2MjY1",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T05:53:35Z",
          "updatedAt": "2019-05-21T05:53:36Z",
          "comments": [
            {
              "originalPosition": 673,
              "body": "I agree.\r\n\r\nI've got a separate PR waiting to go that tries to make hash2base easy to implement and as generic as possible. I suggest we delay this discussion until that PR.",
              "createdAt": "2019-05-21T05:53:36Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODM3MDg5",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T05:56:59Z",
          "updatedAt": "2019-05-21T05:57:00Z",
          "comments": [
            {
              "originalPosition": 739,
              "body": "That's a good point.\r\n\r\nOn the other hand, \"clearing the cofactor\" is essentially standard terminology. It might be confusing to make up alternate terminology.",
              "createdAt": "2019-05-21T05:57:00Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODM3OTgz",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T06:00:39Z",
          "updatedAt": "2019-05-21T06:00:39Z",
          "comments": [
            {
              "originalPosition": 771,
              "body": "Great point. Are there specific reasons you think we should mention here?\r\n\r\nOff the top of my head, the logic might be:\r\n\r\n- *somewhere* need to make an arbitrary decision about how to make sqrt() a function,\r\n- can do that by specifying sqrt(), but that requires case-by-case for different field characteristics and might end up making sqrt implementations more complex / less efficient\r\n- instead, specify sign at the output, which ensures that everyone agrees while being the least prescriptive in terms of implementation\r\n\r\nIf the above reasoning seems good, I'm happy to turn it into prose.",
              "createdAt": "2019-05-21T06:00:39Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODM4NzY5",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T06:03:57Z",
          "updatedAt": "2019-05-21T06:03:57Z",
          "comments": [
            {
              "originalPosition": 816,
              "body": "I don't think it's necessary (or advisable) to change the sign of y, since the encoding is unambiguous.",
              "createdAt": "2019-05-21T06:03:57Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODQxMjIy",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T06:13:33Z",
          "updatedAt": "2019-05-21T06:13:34Z",
          "comments": [
            {
              "originalPosition": 780,
              "body": "I took a stab at clarifying and cleaning up.",
              "createdAt": "2019-05-21T06:13:33Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODQxOTIy",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T06:16:24Z",
          "updatedAt": "2019-05-21T06:16:24Z",
          "comments": [
            {
              "originalPosition": 819,
              "body": "Ah, I see your point.\r\n\r\nThe text currently in `{{map-exceptions}}` says \"we discuss the exceptional cases and show how to handle them in constant time.\"\r\n\r\nIf the preference is to get rid of the explicit discussion and just tweak the maps, that's fine. But it might be nice to make explicit the tweaks and the reasons for them, otherwise readers might wonder why the descriptions in this document differ from the published algorithms...",
              "createdAt": "2019-05-21T06:16:24Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODQyMjQx",
          "commit": {
            "abbreviatedOid": "14f7b37"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T06:17:40Z",
          "updatedAt": "2019-05-21T06:17:41Z",
          "comments": [
            {
              "originalPosition": 835,
              "body": "Happy to make this change.\r\n\r\nI was following the existing convention in the document, which was to return h * (x, y). But I think you're right that it's probably confusing to say this when most of the time it's not actually what implementors will do!",
              "createdAt": "2019-05-21T06:17:41Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5ODQ1MTg2",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T06:28:22Z",
          "updatedAt": "2019-05-21T06:28:23Z",
          "comments": [
            {
              "originalPosition": 1436,
              "body": "Done now.",
              "createdAt": "2019-05-21T06:28:23Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5OTA3MDU1",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T08:50:54Z",
          "updatedAt": "2019-05-21T08:50:54Z",
          "comments": [
            {
              "originalPosition": 465,
              "body": "In this line of the document it seems that cofactor clearing only works for points that are not in the prime-order subgroup. \r\nI was trying to be more general saying that cofactor clearing works for any point in the curve.\r\n",
              "createdAt": "2019-05-21T08:50:54Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5OTExNzQ5",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T08:59:26Z",
          "updatedAt": "2019-05-21T08:59:26Z",
          "comments": [
            {
              "originalPosition": 585,
              "body": "It was already stated how to represent elements. ",
              "createdAt": "2019-05-21T08:59:26Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5OTE0MTEw",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T09:03:44Z",
          "updatedAt": "2019-05-21T09:03:44Z",
          "comments": [
            {
              "originalPosition": 641,
              "body": "Good catch! m is used for the extension fields. Let's use another name.",
              "createdAt": "2019-05-21T09:03:44Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5OTM4MDk3",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T09:47:47Z",
          "updatedAt": "2019-05-21T09:47:48Z",
          "comments": [
            {
              "originalPosition": 739,
              "body": "We can stay with clearing the cofactor and making the observation that clearing the cofactor for pairing curves is different from a straightforward multiplication by h.",
              "createdAt": "2019-05-21T09:47:48Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5OTQ2Nzg3",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T10:04:32Z",
          "updatedAt": "2019-05-21T10:04:33Z",
          "comments": [
            {
              "originalPosition": 771,
              "body": "I am agree with that. You can also use the following ideas for using a root-selection method rather than fixed algorithms for sqrt are:\r\n1) covering all fields is complicated (as you mention this will require going case-per-case)\r\n2) there is no restriction for changing the underlying algorithm that calculates sqrt(). (I am optimistic that in the future there could be improvements on the calculation of sqrt )\r\n3) using a predicate to select a principal root can be done easily by using the sgn() function.\r\n\r\n",
              "createdAt": "2019-05-21T10:04:32Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5OTQ4NTc1",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T10:08:23Z",
          "updatedAt": "2019-05-21T10:08:24Z",
          "comments": [
            {
              "originalPosition": 816,
              "body": "My observation is that the mini-section \"Sign of y: .... \"  can be omitted, and make the desired changes in the sign of y internally in the algorithm. \r\n",
              "createdAt": "2019-05-21T10:08:23Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5OTUxODYy",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T10:15:48Z",
          "updatedAt": "2019-05-21T10:15:48Z",
          "comments": [
            {
              "originalPosition": 819,
              "body": "Ideally, the tweaks and the related discussion can be summarized in a supportive short paper, which can be released on eprint. I am happy to collaborate with that. ",
              "createdAt": "2019-05-21T10:15:48Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5OTYwODgw",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T10:34:53Z",
          "updatedAt": "2019-05-21T10:34:53Z",
          "comments": [
            {
              "originalPosition": 1100,
              "body": "One can make the distinction between algorithm and implementation.\r\nAs you can see, in the document there is a short description using black-box functions and non-constant time pseudo-code, and then, it is followed by a constant-time implementation. This short description must be enough to be used by anyone on the specified curve.\r\n\r\nAlso I am aware that by unboxing functions and working on projective coordinates allows more optimization tricks, and definitely, this is more useful for implementors. However, we need to figure out in which part of the draft to include the optimized versions.\r\n\r\n  \r\n\r\n\r\n\r\n",
              "createdAt": "2019-05-21T10:34:53Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjE4NjI1",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T18:17:37Z",
          "updatedAt": "2019-05-21T18:17:38Z",
          "comments": [
            {
              "originalPosition": 669,
              "body": "Created Issue #110.",
              "createdAt": "2019-05-21T18:17:38Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjE5Mjcz",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T18:18:54Z",
          "updatedAt": "2019-05-21T18:18:54Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "Noted in issue #105, which deals with spacing.",
              "createdAt": "2019-05-21T18:18:54Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjIxNzI5",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T18:23:32Z",
          "updatedAt": "2019-05-21T18:23:33Z",
          "comments": [
            {
              "originalPosition": 585,
              "body": "Sorry, I don't see it. Where was this stated locally? It looks like the only place that it's described is in the referenced section ({{bg-curves}}), which is why I'm proposing a crossref here---to make the document easier to read.",
              "createdAt": "2019-05-21T18:23:32Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjIyMjEz",
          "commit": {
            "abbreviatedOid": "3df4af9"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T18:24:27Z",
          "updatedAt": "2019-05-21T18:24:27Z",
          "comments": [
            {
              "originalPosition": 641,
              "body": "Cool. I created issue #110 for this.",
              "createdAt": "2019-05-21T18:24:27Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjM2ODQx",
          "commit": {
            "abbreviatedOid": "ee234bf"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T18:52:54Z",
          "updatedAt": "2019-05-21T18:52:54Z",
          "comments": [
            {
              "originalPosition": 739,
              "body": "Great, this makes sense.\r\n\r\nI've pushed a commit that I believe addresses this comment:\r\n\r\n1. it clarifies the three cases that @armfazh lists above,\r\n2. it defines a new abstract function `clear_h(x, y)` that represents cofactor clearing, and\r\n3. it replaces `Output h * (x, y)` with `clear_h(x, y)` in the descriptions of the implementations.",
              "createdAt": "2019-05-21T18:52:54Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjQwMzA5",
          "commit": {
            "abbreviatedOid": "ee234bf"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T18:59:41Z",
          "updatedAt": "2019-05-21T18:59:41Z",
          "comments": [
            {
              "originalPosition": 749,
              "body": "> Wahby and Boneh ([WB19], Section 5) describe a trick due to Scott for faster cofactor clearing on any elliptic curve for which the prime factorization of h and the number of points on the curve meet certain conditions.\r\n\r\n@kwantam  Quick question: does your method is particular to pairing-friendly curves? If so, then the paragraph should be merged.",
              "createdAt": "2019-05-21T18:59:41Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjQxNzUx",
          "commit": {
            "abbreviatedOid": "ee234bf"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T19:02:42Z",
          "updatedAt": "2019-05-21T19:02:43Z",
          "comments": [
            {
              "originalPosition": 582,
              "body": "Ok, I am agree with that. \r\nIn fact, the signum is actually computed, and at the very end it sets sgn(x)=1  if x=0.\r\n",
              "createdAt": "2019-05-21T19:02:42Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjQyNDQw",
          "commit": {
            "abbreviatedOid": "ee234bf"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T19:04:10Z",
          "updatedAt": "2019-05-21T19:04:10Z",
          "comments": [
            {
              "originalPosition": 585,
              "body": "That's fine, let's move on.",
              "createdAt": "2019-05-21T19:04:10Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjQ2MjIy",
          "commit": {
            "abbreviatedOid": "ee234bf"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T19:12:20Z",
          "updatedAt": "2019-05-21T19:12:20Z",
          "comments": [
            {
              "originalPosition": 739,
              "body": "Note that after #111 these `clear_h()` operations should be revisited.",
              "createdAt": "2019-05-21T19:12:20Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjQ3OTc3",
          "commit": {
            "abbreviatedOid": "ee234bf"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T19:16:20Z",
          "updatedAt": "2019-05-21T19:16:20Z",
          "comments": [
            {
              "originalPosition": 816,
              "body": "The high-level descriptions and straight-line procedures *do* implement the sign changes. So is the suggestion to remove the explanation here?\r\n\r\nI'm in favor of explicitly documenting decisions like this (and exceptional cases) rather than making them implicit in the algorithm, since that gives an opportunity to explain the rationale for the decision and documents departures from the algorithms described in the literature.\r\n\r\n@armfazh suggests in another comment that these decisions could be documented separately, say, on ePrint. That certainly could work! but to me it seems better to make the document self-contained to the greatest extent possible.",
              "createdAt": "2019-05-21T19:16:20Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjQ4NTY0",
          "commit": {
            "abbreviatedOid": "ee234bf"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T19:17:43Z",
          "updatedAt": "2019-05-21T19:17:44Z",
          "comments": [
            {
              "originalPosition": 819,
              "body": "(see comment above. I can see this working, but it's not clear to me why that's preferable to creating a self-contained document that explains its decisions)",
              "createdAt": "2019-05-21T19:17:44Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjQ4ODk5",
          "commit": {
            "abbreviatedOid": "ee234bf"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T19:18:28Z",
          "updatedAt": "2019-05-21T19:18:28Z",
          "comments": [
            {
              "originalPosition": 835,
              "body": "See above: pushed a commit that partially addresses this. I think it's worth revisiting this after #111 is settled.",
              "createdAt": "2019-05-21T19:18:28Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjUwNjc2",
          "commit": {
            "abbreviatedOid": "ee234bf"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T19:22:21Z",
          "updatedAt": "2019-05-21T19:22:21Z",
          "comments": [
            {
              "originalPosition": 1100,
              "body": "I agree about the distinction between algorithm and implementation. The *algorithm*, a few lines above, is fully black-box. The two *implementations* (for p = 3 mod 4 and p = 5 mod 8) make non-black-box use. So we seem to be in agreement.\r\n\r\nI agree with you that we need to make a decision about optimized versions. I created a new issue, #111, for this. I'll write a specific proposal there in the near future.",
              "createdAt": "2019-05-21T19:22:21Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjU5NDU2",
          "commit": {
            "abbreviatedOid": "8d25c6f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T19:41:15Z",
          "updatedAt": "2019-05-21T19:41:16Z",
          "comments": [
            {
              "originalPosition": 771,
              "body": "I've slightly expanded and clarified the justification here.",
              "createdAt": "2019-05-21T19:41:15Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjYyNTc1",
          "commit": {
            "abbreviatedOid": "8d25c6f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T19:47:58Z",
          "updatedAt": "2019-05-21T19:47:59Z",
          "comments": [
            {
              "originalPosition": 749,
              "body": "No, it applies to any curve meeting the (un)specified conditions. Probably it's *most useful* in the context of pairing-friendly curves, since most non-pairing-friendly curves have very small cofactors, and thus clearing the cofactor isn't particularly expensive...",
              "createdAt": "2019-05-21T19:47:58Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjYzNjIw",
          "commit": {
            "abbreviatedOid": "8d25c6f"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T19:50:16Z",
          "updatedAt": "2019-05-21T19:50:16Z",
          "comments": [
            {
              "originalPosition": 1100,
              "body": "Good work.",
              "createdAt": "2019-05-21T19:50:16Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjY4MTU2",
          "commit": {
            "abbreviatedOid": "8d25c6f"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T19:59:48Z",
          "updatedAt": "2019-05-21T19:59:49Z",
          "comments": [
            {
              "originalPosition": 771,
              "body": "LGTM",
              "createdAt": "2019-05-21T19:59:48Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjc0MzE4",
          "commit": {
            "abbreviatedOid": "8d25c6f"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T20:13:05Z",
          "updatedAt": "2019-05-21T20:13:06Z",
          "comments": [
            {
              "originalPosition": 2071,
              "body": "There is a section that is missing to be written, which is the instantiations of suites. In such a section, draft must specify all the parameters for a given curve. \r\nFor example, the suite correspondent to BLS12-381 will state which isogeny was used and all other relevant parameters.",
              "createdAt": "2019-05-21T20:13:05Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjgwMTg4",
          "commit": {
            "abbreviatedOid": "8d25c6f"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T20:24:57Z",
          "updatedAt": "2019-05-21T20:24:57Z",
          "comments": [
            {
              "originalPosition": 816,
              "body": "Let's keep the full descriptions for the cases were are required.",
              "createdAt": "2019-05-21T20:24:57Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjk0Njkx",
          "commit": {
            "abbreviatedOid": "6324739"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T20:54:37Z",
          "updatedAt": "2019-05-21T20:54:38Z",
          "comments": [
            {
              "originalPosition": 713,
              "body": "Move this topic to #99 ",
              "createdAt": "2019-05-21T20:54:37Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjk0NzMy",
          "commit": {
            "abbreviatedOid": "6324739"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T20:54:43Z",
          "updatedAt": "2019-05-21T20:54:43Z",
          "comments": [
            {
              "originalPosition": 661,
              "body": "Move this topic to #99 ",
              "createdAt": "2019-05-21T20:54:43Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjk2MTYw",
          "commit": {
            "abbreviatedOid": "6324739"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T20:57:38Z",
          "updatedAt": "2019-05-21T20:57:38Z",
          "comments": [
            {
              "originalPosition": 2071,
              "body": "Great. I made a note of this in #111. Next I'll push a commit that removes this text.",
              "createdAt": "2019-05-21T20:57:38Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjk4MjE1",
          "commit": {
            "abbreviatedOid": "fe7df96"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T21:01:55Z",
          "updatedAt": "2019-05-21T21:01:55Z",
          "comments": [
            {
              "originalPosition": 2071,
              "body": "(Done)",
              "createdAt": "2019-05-21T21:01:55Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMjk5MjEw",
          "commit": {
            "abbreviatedOid": "fe7df96"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-05-21T21:04:02Z",
          "updatedAt": "2019-05-21T21:04:02Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMzAwNDMx",
          "commit": {
            "abbreviatedOid": "fe7df96"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T21:06:33Z",
          "updatedAt": "2019-05-21T21:06:33Z",
          "comments": [
            {
              "originalPosition": 749,
              "body": "I think #111 comprehends this now. I've added a link to this conversation there.",
              "createdAt": "2019-05-21T21:06:33Z",
              "updatedAt": "2019-05-21T21:35:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 114,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgwOTU5MzQz",
      "title": "simplify / clarify sgn0 implementation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/114",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This addresses one of @chris-wood's comments on #104 which is captured in #108 \r\n\r\nNOTE: this and #115  can rebase cleanly on top of one another, so if the preference is to keep a clean history we can sequence a merge->rebase->merge for these two.\r\n\r\ncloses #108",
      "createdAt": "2019-05-21T21:39:21Z",
      "updatedAt": "2019-06-03T22:32:47Z",
      "closedAt": "2019-06-03T20:53:30Z",
      "mergedAt": "2019-06-03T20:53:30Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I've just added another commit to this PR that updates the definition of sgn0, both in the code and in the document.\r\n\r\nThe effect of this change is to reverse the order in which vector elements are considered when computing sgn0. Previously the order was from least significant to most significant; with this change, the order is from most to least. Note that this change has no effect on elements of GF(p), only on elements of GF(p^m).\r\n\r\nThe reason for this change is to bring the document into agreement with existing conventions used by deployed implementations of BLS12-381.",
          "createdAt": "2019-05-29T20:16:25Z",
          "updatedAt": "2019-05-29T20:16:25Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This LGTM -- thanks!",
          "createdAt": "2019-06-03T20:53:09Z",
          "updatedAt": "2019-06-03T20:53:09Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 115,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgwOTYwMDk4",
      "title": "split sqrt def'n by field characteristic",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/115",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This clarifies the definition of square roots as requested by @chris-wood's comment on #104 and captured in #106.\r\n\r\nSee note in #114 about sequencing merges and rebases to keep a clean commit history, if desired.\r\n\r\ncloses #106",
      "createdAt": "2019-05-21T21:42:10Z",
      "updatedAt": "2019-05-31T18:01:34Z",
      "closedAt": "2019-05-31T17:12:51Z",
      "mergedAt": "2019-05-31T17:12:51Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NDIwNTc2",
          "commit": {
            "abbreviatedOid": "b180571"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, thanks!",
          "createdAt": "2019-05-31T17:11:11Z",
          "updatedAt": "2019-05-31T17:11:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 116,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgwOTY2NDI5",
      "title": "hash2base update",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/116",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This updates hash2base to use the same method described in the Pairing WG's BLS signatures [spec-v1](https://github.com/pairingwg/bls_standard/blob/master/minutes/spec-v1.md).\r\n\r\nExecutive summary:\r\n\r\nThe idea behind this change is that it makes it possible to call hash2base multiple times (for the random oracle construction) while hashing the input message exactly once. This avoids requiring applications to specify pre-hashing and also avoids requiring implementors to make non-black-box use of a hash function (e.g., computing a \"partial\" hash of a message and then \"finishing\" the hash in two different ways to get the two different evaluations for the random oracle construction).\r\n\r\nOne potential downside of this change is that it requires adding an argument `ctr` to all of the map2curve functions, which is \"passed through\" to hash2base. (This PR makes that change.) To address this slight ugliness, this PR makes `ctr` optional and defaults it to 0 if not specified. That way, one can still sensibly refer to a value like `map2curve(alpha)`.\r\n\r\nDetails:\r\n\r\nThe reasoning is as follows. In the current hash2base, one might want to call, say,\r\n\r\n    hash2base(msg || I2OSP(1, 1))\r\n    hash2base(msg || I2OSP(2, 1))\r\n\r\nand this results in computing, inside the hash2base calls,\r\n\r\n    m_prime_1 = H(msg || I2OSP(1, 1))\r\n    m_prime_2 = H(msg || I2OSP(2, 1))\r\n\r\nIf `msg` is long, this is inefficient. One way to avoid this is, as I mentioned above, to \"partially evaluate\" H on `msg`. But requiring implementors to make non-black-box use of H is undesirable, because it constrains their implementations (for example, what happens if your crypto library doesn't let you partially evaluate H?).\r\n\r\nThe other way to avoid this is to make applications pre-hash messages. That's fine, but requiring them to do that for efficiency is a little unfriendly, because it means that if they forget to specify pre-hashing in their protocol, they have to change the protocol to fix it.\r\n\r\nThis PR gives a third option: call\r\n\r\n    hash2base(msg, 1)\r\n    hash2base(msg, 2)\r\n\r\nThis results in computing, inside the hash2base calls,\r\n\r\n    m_prime_1 = H(msg) || I2OSP(1, 1)\r\n    m_prime_2 = H(msg) || I2OSP(2, 1)\r\n\r\nSince the concatenation is outside the call to H, both invocations of hash2base can share the same evaluation of `H(msg)`. This allows seamlessly optimizing the implementation of hash2base in a way that is guaranteed to be backward compatible, which means that applications do not have to worry about breaking changes that come as a result of pre-hashing.",
      "createdAt": "2019-05-21T22:06:47Z",
      "updatedAt": "2019-06-03T18:55:44Z",
      "closedAt": "2019-06-03T12:52:32Z",
      "mergedAt": "2019-06-03T12:52:32Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "As with #114 and #115, happy to rebase this as necessary to keep the commit history clean.",
          "createdAt": "2019-05-21T22:07:31Z",
          "updatedAt": "2019-05-21T22:07:31Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I pushed an update that partially addresses [my comment in #99](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/issues/99#issuecomment-495428394) regarding collision resistance.\r\n\r\nIt's not clear to me whether specific hash function recommendations should go in Section 4, elsewhere in the document, or nowhere in the document. Thoughts?",
          "createdAt": "2019-05-24T16:14:01Z",
          "updatedAt": "2019-05-24T16:14:01Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "See my [inline comment](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/116#discussion_r289488785). At a high level, the improvement is in the sense that this version is easier to optimize for long messages.\r\n\r\nNote also that this change is motivated by \"user\" feedback: folks from the BLS signatures working group preferred this version specifically because it builds in the possibility of implementing a \"prehashed\" mode without changing application code or requiring partial evals of `H`.",
          "createdAt": "2019-05-31T17:51:44Z",
          "updatedAt": "2019-05-31T17:51:44Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I've (I think) clarified the text. I will think carefully about how to incorporate @jedisct1's feedback, too (thanks!)",
          "createdAt": "2019-05-31T19:02:50Z",
          "updatedAt": "2019-05-31T19:02:50Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> At a high level, the improvement is in the sense that this version is easier to optimize for long messages.\r\n\r\nI certainly don't disagree that it's an improvement in that sense. It's just that the description and implementation seemed not in alignment. Adopting @jedisct1 suggestion, and writing one in terms of the underlying helper, would make this more clear. ",
          "createdAt": "2019-05-31T19:10:27Z",
          "updatedAt": "2019-05-31T19:10:27Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I thought a bit more about this and have a couple questions/comments:\r\n\r\n1. Factoring H(msg) out of hash2base is strictly an optimization, and in many (probably most) cases not one that's going to make much difference in the end-to-end cost of hashing to the curve. So actually I think the common case is going to be the unoptimized version. But I'd argue it's still worthwhile to make this change: it's essentially free future proofing.\r\n\r\n2. It's not perfectly clear to me who the target audience is, but I'm guessing that for most people the optimization we're talking about here is rather trivial. If that's true, it further supports keeping the pseudocode simple: adding the optimization is probably a net loss in clarity for everyone, even people who would actually want to implement the optimization.\r\n\r\nGiven the above, my vote is to keep the simple version of the pseudocode in Section 4, and *maybe* add an appendix that makes the optimization explicit.",
          "createdAt": "2019-05-31T19:48:18Z",
          "updatedAt": "2019-05-31T19:48:18Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I consider that we must assume short-input messages for the function hash2base; this allows invoking H as many times as needed without performance issues. \r\nIn case of large messages, these messages can be pre-hashed by the caller of the cipher-suite.\r\nSee my proposal at #118 ",
          "createdAt": "2019-05-31T21:00:06Z",
          "updatedAt": "2019-05-31T21:03:51Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "![Image](https://github.com/armfazh/draft-sullivan-cfrg-hash-to-curve/blob/diagrams/drawings/desc.png)",
          "createdAt": "2019-05-31T21:02:41Z",
          "updatedAt": "2019-05-31T21:02:41Z"
        },
        {
          "author": "jedisct1",
          "authorAssociation": "NONE",
          "body": "Very useful diagram.\r\n\r\nBut `hash2field(s)` is as confusing as `hash2base(s)`. If the input is a string, the prefix of the function name shouldn't be `hash`.\r\n\r\nAlso, `hash2field(h(s))` and `hash2field_prehash(s)` produce the same output. This may be a problem if the former or the later are dynamically called according to the length of the `s`.",
          "createdAt": "2019-05-31T21:16:29Z",
          "updatedAt": "2019-05-31T21:16:49Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> But `hash2field(s)` is as confusing as `hash2base(s)`. If the input is a string, the prefix of the function name shouldn't be `hash`.\r\n\r\nWell, the function \r\n```\r\nXYZ : s -> U \r\n```\r\nconverts an string s (regardless its size) into an non-empty set of field elements U. Then, XYZ should be one-way and must behave as a random oracle in F. These two properties justify the name of hash2field. However, I am agree with any other meaningful name.\r\n \r\n\r\n\r\n",
          "createdAt": "2019-05-31T21:25:57Z",
          "updatedAt": "2019-05-31T21:25:57Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> Also, `hash2field(h(s))` and `hash2field_prehash(s)` produce the same output. This may be a problem the former or the later are dynamically called according to the length of the `s`.\r\n\r\nThey do, however, my proposal is that `hash2field_prehash(s)` should not exist in the definition of the suite. \r\n\r\nA similar strategy as the one I propose is Ed25519 and Ed25519ph. Both signatures are in essence the same (except by domain separation strings).",
          "createdAt": "2019-05-31T21:26:30Z",
          "updatedAt": "2019-05-31T21:26:30Z"
        },
        {
          "author": "jedisct1",
          "authorAssociation": "NONE",
          "body": "> except by domain separation strings\r\n\r\nThis is what is missing here. How about `s = 0 || s` (if no prehashing is done) or `s = 1 || s` (after prehashing) before calling `hash2field()`?",
          "createdAt": "2019-05-31T21:34:34Z",
          "updatedAt": "2019-05-31T21:34:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> How about s = 0 || s (if no prehashing is done) or s = 1 || s (after prehashing) before calling hash2field()?\r\n\r\nI think we ought to first agree on whether or not prehashing is something the API or the caller should implement. @armfazh suggests its the caller's responsibility, whereas @kwantam suggests it be supported by the API (IIUC). (Hand waving specificity with what I mean by \"supported by the API\" here.) I think both are viable, though I'd prefer to do without additional complexity, and therefore slightly prefer @armfazh's proposal. ",
          "createdAt": "2019-05-31T21:55:16Z",
          "updatedAt": "2019-05-31T21:55:16Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Folks,\r\n\r\nI think this conversation is getting a bit far afield here.\r\n\r\nI agree with @armfazh that the suite should **not** specify a separate prehash mode. That's up to the application layer. Specifying it here subverts the abstraction.\r\n\r\n**But**: the whole point of this PR is to point out that *a prehash mode is not needed for efficiency*!\r\nThis is great! Everyone wins!\r\n\r\nWhy is this true? Because hash2base can easily be designed in a way that allows hashing the whole message only once, with essentially no effect on cost.\r\n\r\nHere are the facts:\r\n\r\n- There is *no* overhead for changing the specification of hash2base from what's currently in the document to what's in this PR.\r\n\r\n- The cost of what is currently in the document (and likewise what is in this PR) is *at most* one H invocation beyond the cost if we assumed that all messages are short (i.e., ~50 bytes). One H invocation is *nothing* compared to the cost of evaluating any of the map functions.\r\n\r\n- For messages of a few hundred bytes and essentially any reasonable parameter setting, what's currently in the document is *cheaper* than assuming messages are short. Again, this PR does not change that.\r\n\r\n- This PR is friendlier to applications built on top of it: an application layer that uses this version of hash2base never needs to prehash for performance, because it's possible (but not necessary) to implement a simple optimization. Of course, they can if they want to! but they can already get equivalent performance for free via this PR.",
          "createdAt": "2019-05-31T22:00:59Z",
          "updatedAt": "2019-05-31T22:03:29Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Ach, one more thing.\r\n\r\nThe biggest downside of what's currently in this PR is that it means all of the `map2curve...` functions now take another parameter. But that's an artifact of the way that `map2curve` is currently specified, i.e., as `{0,1}* -> E`.\r\n\r\nWe can easily fix that by specifying all `map2curve...` functions as `F -> E`. In this case, to hash a string one calls `map2curve...(hash2base(string, ctr))`. From my perspective this is nicer anyway: it more closely matches the way that the literature describes these functions and the way that they should be implemented. As a bonus, it makes the document easier to maintain, because changes to hash2curve don't need to be propagated to all of the map2curve specifications, too.\r\n\r\nThe specific changes are:\r\n\r\n1. Update section 5.1 to reflect the new interface,\r\n\r\n2. add words to the effect that the input to map2curve... MUST come from hash2base,\r\n\r\n3. change the signatures of the map2curve... functions, and\r\n\r\n4. update section 6 in a similar way.\r\n\r\nI'm happy to update the PR to reflect the above.",
          "createdAt": "2019-05-31T22:08:32Z",
          "updatedAt": "2019-06-01T18:39:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam No disagreement with the facts! What concerns me is that this introduces another parameter without a specified use for it. Sure, implementations could make use of it when calling `hash2base(msg)` twice in `hash2curve`, yet that's not currently done or shown how to be done. At the very least, I think we ought to provide that example in appendix.",
          "createdAt": "2019-05-31T22:09:49Z",
          "updatedAt": "2019-05-31T22:09:49Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> yet that's not currently done or shown how to be done\r\n\r\nSorry, I think I'm missing something.\r\n\r\nSection 6 uses `ctr` to specify the two independent hash evaluations. Are you referring to something else?",
          "createdAt": "2019-05-31T22:21:14Z",
          "updatedAt": "2019-05-31T22:21:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Aha, I missed that! You\u2019re right, my apologies. I\u2019m fine with this as is then!",
          "createdAt": "2019-05-31T22:33:52Z",
          "updatedAt": "2019-05-31T22:33:52Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I am going do a second pass on the latest version.",
          "createdAt": "2019-05-31T22:35:38Z",
          "updatedAt": "2019-05-31T22:35:38Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\nIn order to have a simpler description, I think there is a compatible way to remove the `ctr` parameter from the hash2base function.\r\n\r\nFirst, remove this line from `hash2base` :\r\n```\r\n1. m' = H(msg) || I2OSP(ctr, 1)\r\n```\r\nupdate the signature to `hash2base(msg)` and replace `m'` -> `msg` .\r\n\r\nSecond, modify the RO-construction as follows:\r\n```\r\nhash2curve(alpha) \r\n1.  h = H(alpha)\r\n2.  return map2curve( h || I2OSP(0, 1) ) + map2curve( h || I2OSP(1, 1) )\r\n```\r\nIf I am not wrong this is equivalent to what is currently proposed. Please check this @kwantam.\r\n\r\n",
          "createdAt": "2019-05-31T23:08:41Z",
          "updatedAt": "2019-05-31T23:08:41Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I think you're right that it's equivalent for the random oracle construction, but it looks to me like the non-RO constructions would also need a similar change. We can do this, but I worry that the resulting description ends up being more complicated.\r\n\r\n@armfazh, when you refer to simpler description, can you be more specific which piece of the description you're trying to simplify? Specifically, is it hash2base, or is it map2curve? In other words, does my [suggestion above](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/116#issuecomment-497875160) also work to simplify in the way you're aiming for?",
          "createdAt": "2019-06-01T18:40:09Z",
          "updatedAt": "2019-06-01T18:42:55Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I've just pushed a new commit that changes the map2curve signature to `F -> E` as described above.\r\n\r\nTo me this is nicer, but obviously happy to revert if y'all disagree :)",
          "createdAt": "2019-06-01T19:37:16Z",
          "updatedAt": "2019-06-01T19:37:16Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> @armfazh, when you refer to simpler description, can you be more specific which piece of the description you're trying to simplify? \r\n\r\nWhen I refer simplicity am thinking on something like the following:\r\n```fortran\r\n! alpha is an arbitrary-length bit string\r\n! G is the group of interest.\r\nfunction Suite(id, alpha) -> P=(x,y) \\in G\r\n    params = SetParams(id)  \r\n    \r\n    if suite is RO\r\n        P0 = hash2curve(alpha || I2OSP(0,1) )\r\n        P1 = hash2curve(alpha || I2OSP(1,1) )\r\n        return P0 + P1\r\n\r\n    if suite is not RO\r\n        P = hash2curve(alpha)\r\n        return P\r\n\r\nfunction hash2curve(alpha) -> P=(x,y) \\in G\r\n    u = hash2base(alpha)\r\n    Q = map2curve(u)\r\n    P = clearCofactor(Q)\r\n    return P\r\n    \r\nhash2base     : {0,1}* -> F     ! Section 4   (or renamed to hash2field) \r\nmap2curve     :    F   -> E(F)  ! Section 5\r\nclearCofactor :   E(F) -> G     ! Section 5.3 (or a new Section 6)\r\n```\r\n\r\nBy simplicity, also consider that functions have only one purpose and the less number of parameters as possible. \r\n\r\nI think we must add a new section (e.g. after Section 2) at the beginning that gives a road map on how do hash2curve in a high level, and then entering into the details. #119 \r\n*Notice that the lack of this section causes confusion on how to assemble all the parts.\r\n\r\n",
          "createdAt": "2019-06-01T21:26:47Z",
          "updatedAt": "2019-06-02T00:32:23Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "The random oracle construction requires the output of two different hash functions H0 and H1. As noted in the FFSTV paper this can be done using 1 hash function H as follows:\r\n```rust\r\n// FFSTV\r\nH0(x) := H( x || 0 )\r\nH1(x) := H( x || 1 )\r\nhash2curve(alpha) \r\n1.  h = H(alpha)\r\n2.  return map2curve( H0(alpha) ) + map2curve( H1(alpha) )\r\n```\r\nI am not sure whether doing this\r\n```rust\r\nhash2curve(alpha) \r\n1.  h = H(alpha)\r\n2.  return map2curve( h || I2OSP(0, 1) ) + map2curve( h || I2OSP(1, 1) )\r\n```\r\nbe as secure as it is proposed in the paper. \r\n\r\nI suggest to follow the recommendation (and proof) given in the FFSTV paper. This implies that two hash evaluations are needed for the RO construction.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2019-06-01T21:37:30Z",
          "updatedAt": "2019-06-01T21:37:30Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh: I've pushed changes to address the typo and wording comments. See my comments above for the other cases.\r\n\r\nAs far as [your](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/117#discussion_r289619477) [comments](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/116#issuecomment-497979394) on the random oracle construction go: you're right that we have to make sure that the new construction meets the security requirements from FFSTV13. It's always good to be careful.\r\n\r\nBut please note that this:\r\n\r\n>    ```\r\n>    h = H(alpha)\r\n>    return map2curve(h || I2OSP(0, 1)) + map2curve(h || I2OSP(1, 1))\r\n>    ```\r\n\r\nis **not what is proposed in this PR**.\r\n\r\nSo let's think through what *is* proposed.\r\n\r\nFor security, we need H0 and H1 such that H0 and H1 are independent random oracles. Here, independence means that the probability distributions of H0's and H1's outputs are independent. To model H0 and H1 as random oracles, it suffices to show that their outputs are indistinguishable from a random function. It's easy to prove all of this, so let's just write it down.\r\n\r\nFirst, let's simplify our task a bit by assuming (WLOG) that the hash2base parameter W = 2 and that m = 1. Further, let's ignore the final reduction mod p in line 6 of hash2base, since it's easy to show that reducing a uniformly random (W * b)-bit integer mod p gives a field element with negligible statistical distance from random as long as W is chosen correctly. Finally, as always we will model the underlying hash function H as a random oracle.\r\n\r\nSo in sum, our goal is to show that the following two functions give outputs indistinguishable from a random oracle:\r\n\r\n```\r\nfn H0(msg):\r\n    m_0 = H(msg) || I2OSP(0, 1)\r\n    h1_0 = H(m_0 || I2OSP(1, 1) || I2OSP(1, 1))\r\n    h2_0 = H(m_0 || I2OSP(1, 1) || I2OSP(2, 1))\r\n    return h1_0 || h2_0\r\n\r\nfn H1(msg):\r\n    m_1 = H(msg) || I2OSP(1, 1)     // NOTE: the difference from H0 is in this line\r\n    h1_1 = H(m_1 || I2OSP(1, 1) || I2OSP(1, 1))\r\n    h2_1 = H(m_1 || I2OSP(1, 1) || I2OSP(2, 1))\r\n    return h1_1 || h2_1\r\n```\r\n\r\nand further that their output distributions are independent. Independence is by inspection: h1_0, h1_1, h2_0, and h2_1 are all the results of distjoint queries to H, and thus their distributions are independent by the definition of a random oracle.\r\n\r\nFor indistinguishability, it suffices to show that H0 is indistinguishable; the same argument applies for H1. Consider the following game between a challenger C and an adversary A on a function Htest: {0,1}* -> {0,1}^ell.\r\n\r\n**RO security game** \r\n\r\n1. **Setup**: C chooses b <-$- {0,1}. If b == 1, C initializes an empty table T with two columns, i={0,1}* and o={0,1}^ell.\r\n\r\n2. **Query** (repeated any number of times): A sends msg_j to C, and C responds as follows.\r\n    - If b == 0, C computes and returns Htest(msg_i) to A.\r\n    - If b == 1, C checks whether any entry in table T has i=msg_j. If so, C returns the corresponding o. Otherwise, C samples a random value out_j <-$- {0,1}^ell, records the pair (i=msg_j, o=out_j) in table T, and returns out_j to A.\r\n\r\n3. **Guess**: A outputs a bit b*, winning if b* == b.\r\n\r\n\r\n**Definition** *(RO security)*: a function Htest is indistinguishable from a random oracle if, for all PPT adversaries A, A's probability of winning the RO security game on Htest is negligibly different from 1/2.\r\n\r\n\r\n**Theorem** *(H0 security)*: the function H0 defined above is indistinguishable from a random oracle if the underlying hash function H is modeled as a random oracle.\r\n\r\n\r\n**Proof**. Supposing that an adversary A* can distinguish H0 from a random oracle, we use A* to construct an adversary that wins the RO security game against the underlying hash H.  Since H is modeled as a random oracle, this is a contradiction. Thus, A* cannot distinguish H0 from a random oracle.\r\n\r\nOur algorithm Ctest proceeds as follows:\r\n\r\n1. Initiate the random oracle security game on H0, where A* is the adversary and Ctest is the challenger.\r\n\r\n2. Initiate the random oracle security game on H, where Ctest is the adversary and Ch is the challenger.\r\n\r\n3. For each of A*'s queries in the H0 game, Ctest evaluates the function H0 by making oracle queries to Ch. In particular, for query msg_j,\r\n    - h_msg_j is the result of querying Ch on msg_j\r\n    - m' := h_msg_j || I2OSP(0, 1)\r\n    - h1_msg_j is the result of querying Ch on m' || I2OSP(1, 1) || I2OSP(1, 1)\r\n    - h2_msg_j is the result of querying Ch on m' || I2OSP(1, 1) || I2OSP(2, 1)\r\n    - Ctest returns h1_msg_j || h2_msg_j\r\n\r\n4. When A* outputs bit b*, Ctest outputs the same bit to Ch.\r\n\r\nBy inspection, A*'s view of the game with Ctest is indistinguishable from its view of a game with a challenger in the RO security game. Thus, A*'s probability of winning against Ctest is negligibly different from its probability of winning the RO security game.  Moreover, Ctest wins against Ch just when A* would have won in the RO security game, by the definition of H0. (To see why both of these are true, note that with overwhelming probability all of Ctest's queries to Ch are fresh whenever A* sends a fresh query msg_j, which means that Ctest uses Ch to indistinguishably simulate the challenger to A*.) Thus, Ctest wins the RO security game on H with non-negligible probability, \u2a33. \u25a1",
          "createdAt": "2019-06-02T19:18:41Z",
          "updatedAt": "2019-06-02T20:17:17Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> When I refer simplicity am thinking on something like the following:\r\n\r\nThe roadmap in #119 is a great idea!\r\n\r\nAs far as the proposed function `Suite`, it seems like it's a nice way of tying everything together, which is great. But it seems like it would be fully redundant with the \"roadmap\" section. Also, I don't think it's really in scope for this pull request, which is just about how to define hash2base.\r\n\r\nBut my biggest concern with `Suite` is that, as far as I can tell, it doesn't reflect how people will actually use this standard. In particular, to first order no one is going to implement ten different suites and then select one on-the-fly. Rather, for any given protocol that needs to hash to a curve, other considerations will drive the decision on which curve to use, what hash function to use, whether to hash indifferentiably, etc. Once these decisions are made, the protocol only needs one hash-to-curve implementation, at which point the Suite function doesn't do anything useful.\r\n\r\nBut to reiterate: even if I'm wrong about the above (which I may well be!), it's irrelevant from the point of view of this PR, which is solely focused on getting hash2curve right.",
          "createdAt": "2019-06-02T19:40:01Z",
          "updatedAt": "2019-06-02T19:40:01Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for giving a full proof of your proposal. \r\nIn the pseudo-code from the previous comment, it's obvious the suite is not implemented as is. \r\nWhat I want to show is that hash2curve can be used for having a non-RO mapping (calling directly) and a RO mapping (using the FFSTV construction).\r\n",
          "createdAt": "2019-06-02T21:13:12Z",
          "updatedAt": "2019-06-02T21:13:12Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh I changed ctr=0 to MUST from SHOULD.\r\n\r\nRegarding the use of hash2base, now I think I understand the reasoning. Thanks for explaining it. Does this PR's version of \"Interface\" (under {{encodings}}) and {{rom}} achieve this? Perhaps the roadmap section of #119 can also help to clarify this point.",
          "createdAt": "2019-06-02T22:58:09Z",
          "updatedAt": "2019-06-02T22:59:23Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I consider this PR has achieved its main purpose which is to define the internals of hash2base.\r\nIt has my approval for merging, the discussion about the interfaces can be done in #119 or in another PR. \r\n\r\n\r\n\r\n",
          "createdAt": "2019-06-03T00:18:03Z",
          "updatedAt": "2019-06-03T00:18:03Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood I've removed the `(+)`.\r\n\r\nI'm not sure which changes (if any) your review is still requesting, but happy to fix them asap.",
          "createdAt": "2019-06-03T03:52:11Z",
          "updatedAt": "2019-06-03T03:52:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0MzQ4Mjk3",
          "commit": {
            "abbreviatedOid": "9e5403e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Technically, this PR is fine, I'm just not sure it's an improvement for implementers. @armfazh @grittygrease, please have a look!",
          "createdAt": "2019-05-31T14:44:31Z",
          "updatedAt": "2019-05-31T14:45:51Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Hmm... How would we make use of this in the actual implementation of `hash2base`? Since the benefit comes from invoking `hash2base` with the same `msg` yet different suffixes, it seems that `hash2base` must necessarily  be stateful so as to not recompute `H(msg)` twice. Is this an improvement? I'm not sure. I think, absent a proposed implementation story there, we ought not to add this complexity.",
              "createdAt": "2019-05-31T14:44:31Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            },
            {
              "originalPosition": 144,
              "body": "\ud83d\udc4d ",
              "createdAt": "2019-05-31T14:45:05Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NDM2ODIy",
          "commit": {
            "abbreviatedOid": "9e5403e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-31T17:45:59Z",
          "updatedAt": "2019-05-31T17:46:00Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "You're absolutely right that the current pseudocode for hash2base doesn't take advantage of the fact that H(msg) can be shared among invocations. The reason for this is that I thought it made the pseudocode simpler.\r\n\r\nBut given the specification of hash2base, one can implement a helper like the following:\r\n\r\n    hash2base_prehashed(msg_hashed, ctr):\r\n        msg' = msg_hashed || I2OSP(ctr, 1)\r\n        ...\r\n\r\nThen, when evaluating hash2base multiple times for different `ctr` values, one can first compute `msg_hashed = H(msg)` and then call the above helper function instead.\r\n\r\nThis isn't to say that people will immediately implement the prehash version of hash2base; the point is, they can easily refactor their implementation in a way that is compatible with the spec yet doesn't require, say, partial evaluation of `H` (which isn't always an option in existing crypto libraries).",
              "createdAt": "2019-05-31T17:45:59Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NDQwNDYx",
          "commit": {
            "abbreviatedOid": "9e5403e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-31T17:53:47Z",
          "updatedAt": "2019-05-31T17:53:48Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Probably I can make the above clearer with some edits to the text. Let me think about this a bit.",
              "createdAt": "2019-05-31T17:53:48Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NDQ4Njk5",
          "commit": {
            "abbreviatedOid": "3dba1f7"
          },
          "author": "jedisct1",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-31T18:11:26Z",
          "updatedAt": "2019-05-31T18:11:27Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "For clarity, `hash2base()` could be renamed to `msg2base()` and `hash2base_prehashed()` could be renamed `hash2base()`.\r\n\r\nIndeed, the actual hash to base operation is going to be a very common case, so we should document how to do it (for an actual implementation, the libsodium documentation has an [example](https://download.libsodium.org/doc/advanced/point-arithmetic#note)).\r\n\r\nHowever, in the proposed `hash2base_prehashed()` function above, we lack context separation with the non-prehashed version.",
              "createdAt": "2019-05-31T18:11:26Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjAyMzY2",
          "commit": {
            "abbreviatedOid": "05bd283"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-01T21:47:45Z",
          "updatedAt": "2019-06-01T21:47:45Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "> uniform random element of H requires\r\n\r\nuniform random element of F requires",
              "createdAt": "2019-06-01T21:47:45Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjAyNTkw",
          "commit": {
            "abbreviatedOid": "05bd283"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-01T21:56:43Z",
          "updatedAt": "2019-06-01T21:56:43Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "\r\n\r\nRegarding the second issue: \r\nI am not sure whether this proposal maintains or modifies the security properties required by the RO construction. \r\n\r\n\r\n",
              "createdAt": "2019-06-01T21:56:43Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjAyNjUw",
          "commit": {
            "abbreviatedOid": "05bd283"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-01T21:59:05Z",
          "updatedAt": "2019-06-01T21:59:05Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "This section can be blended with the next section (Notation)",
              "createdAt": "2019-06-01T21:59:05Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjAyNjg1",
          "commit": {
            "abbreviatedOid": "05bd283"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-01T22:00:19Z",
          "updatedAt": "2019-06-01T22:00:20Z",
          "comments": [
            {
              "originalPosition": 184,
              "body": ">  The only exceptional case is u == 0.\r\n\r\n The only exceptional case is u = 0.\r\n",
              "createdAt": "2019-06-01T22:00:20Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjAyNzUw",
          "commit": {
            "abbreviatedOid": "05bd283"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-01T22:03:12Z",
          "updatedAt": "2019-06-01T22:03:13Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Note that implementors SHOULD NOT use a rejection sampling procedure to get a uniform random element from F. The reason ...",
              "createdAt": "2019-06-01T22:03:13Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjAyODQw",
          "commit": {
            "abbreviatedOid": "05bd283"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-01T22:06:57Z",
          "updatedAt": "2019-06-01T22:06:57Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "> The argument ctr to hash2base SHOULD be 0, except as described in Section 6.\r\n\r\nI prefer not to have by-default values.",
              "createdAt": "2019-06-01T22:06:57Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjM2NjAy",
          "commit": {
            "abbreviatedOid": "05bd283"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-02T18:07:11Z",
          "updatedAt": "2019-06-02T18:07:11Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "That's possible, but I don't see the advantage. Notation is \"what do these symbols in the code mean?\", Interface is \"how do I use this thing?\". To me, it is clearer to keep them separate.",
              "createdAt": "2019-06-02T18:07:11Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjM2NjYz",
          "commit": {
            "abbreviatedOid": "05bd283"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-02T18:09:39Z",
          "updatedAt": "2019-06-02T18:09:39Z",
          "comments": [
            {
              "originalPosition": 184,
              "body": "This is a pervasive style question in the document. Pushed to #105.",
              "createdAt": "2019-06-02T18:09:39Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjM2Nzg5",
          "commit": {
            "abbreviatedOid": "05bd283"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-02T18:13:38Z",
          "updatedAt": "2019-06-02T18:13:38Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "Sorry, I don't understand this comment.\r\n\r\nIt seems pretty clear that everyone should choose the same value of `ctr`. I'm happy to change the definition of `hash2base` so that `ctr` is an integer in {0,1} rather than in [0, 256), but barring that change there must be an agreed-upon value in order for implementations to interoperate.",
              "createdAt": "2019-06-02T18:13:38Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjM4ODcw",
          "commit": {
            "abbreviatedOid": "c406a58"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-02T19:19:22Z",
          "updatedAt": "2019-06-02T19:19:23Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "See [my comment](https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve/pull/116#issuecomment-498057883), below.",
              "createdAt": "2019-06-02T19:19:22Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjQyNDM1",
          "commit": {
            "abbreviatedOid": "c406a58"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-02T21:06:14Z",
          "updatedAt": "2019-06-02T21:06:15Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "I was not clear in this comment, please disregard it. \r\nHowever, narrowing the value of the counter to {0,1} seems to me is a good idea. \r\nThe non-RO must fix the ctr value to 0. ",
              "createdAt": "2019-06-02T21:06:15Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjQzMzcy",
          "commit": {
            "abbreviatedOid": "c406a58"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-02T21:37:11Z",
          "updatedAt": "2019-06-02T21:37:12Z",
          "comments": [
            {
              "originalPosition": 910,
              "body": "(+)  -> +  \r\n(remove parenthesis of plus)",
              "createdAt": "2019-06-02T21:37:11Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjQ1OTc3",
          "commit": {
            "abbreviatedOid": "1ecabef"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-02T22:56:37Z",
          "updatedAt": "2019-06-02T22:56:38Z",
          "comments": [
            {
              "originalPosition": 910,
              "body": "I was thinking it might be clearer to avoid overloading the `+` operator for point addition, since `+` appears in a lot of the pseudocode and has a different meaning there.\r\n\r\nI'm happy to remove it, but it seems like it might improve clarity to use a different symbol here.",
              "createdAt": "2019-06-02T22:56:37Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjQ4ODM4",
          "commit": {
            "abbreviatedOid": "1ecabef"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-03T00:03:46Z",
          "updatedAt": "2019-06-03T00:03:46Z",
          "comments": [
            {
              "originalPosition": 910,
              "body": "> map2curve(u0) (+) map2curve(u1)\r\n> where map2curve is the chosen encoding and the (+) operation is elliptic curve point addition.\r\n\r\nThe note following the equation alerts the reader about performing point addition. So I will go for using a simple plus symbol.\r\n",
              "createdAt": "2019-06-03T00:03:46Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjQ5NTAx",
          "commit": {
            "abbreviatedOid": "1ecabef"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-03T00:15:44Z",
          "updatedAt": "2019-06-03T00:15:44Z",
          "comments": [
            {
              "originalPosition": 910,
              "body": "That makes sense, and it's true that the reader *should* be able to figure it out. On the other hand, it seems like using different notation draws attention to the fact that this isn't normal addition, which might make it easier on the reader.\r\n\r\nI just checked, and it looks like RFC8032 (EdDSA) uses just `+`. So maybe it makes sense to do the same.\r\n\r\nBefore I change it back, @chris-wood, @grittygrease, @jedisct1, any further thoughts?",
              "createdAt": "2019-06-03T00:15:44Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjQ5NzY5",
          "commit": {
            "abbreviatedOid": "1ecabef"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-03T00:19:55Z",
          "updatedAt": "2019-06-03T00:19:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjQ5ODUz",
          "commit": {
            "abbreviatedOid": "1ecabef"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-03T00:21:32Z",
          "updatedAt": "2019-06-03T00:21:32Z",
          "comments": [
            {
              "originalPosition": 910,
              "body": "I think simply `+` is fine, though maybe in the future we should consider separate notation to separate point from integer arithmetic.",
              "createdAt": "2019-06-03T00:21:32Z",
              "updatedAt": "2019-06-03T03:51:17Z"
            }
          ]
        }
      ]
    },
    {
      "number": 118,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg0MTkwOTcy",
      "title": "Including one diagram",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/118",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "FWIW, this diagram would help to overview the suites recommended in this draft.\r\n\r\nSome considerations:\r\n - Rely always on hash evaluations over short-length strings.\r\n - Large input strings can be pre-hashed, but this is external to the suite.\r\n - Curves not addressed by means of a named-suite must follow the recommendations given in the draft.\r\n\r\nSources of the diagram are included (xml file) in case something needs to be fixed.\r\n",
      "createdAt": "2019-05-31T20:57:22Z",
      "updatedAt": "2020-03-13T22:18:35Z",
      "closedAt": "2020-03-13T22:18:35Z",
      "mergedAt": "2020-03-13T22:18:35Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Diagram is great, and in general super useful.\r\n\r\nMight be worthwhile to wait until after #116 since this would change dramatically if #116 is accepted.\r\n\r\nAlso, is there a better way to describe what's going on in the RO mode than duplicating the boxes? The issue is, if you don't already know what the difference is between the top and bottom sequence, it's *really* hard to tell from the diagram!",
          "createdAt": "2019-05-31T22:25:41Z",
          "updatedAt": "2019-05-31T22:25:41Z"
        },
        {
          "author": "jedisct1",
          "authorAssociation": "NONE",
          "body": "Maybe two diagrams would improve clarity over a single diagram with branches for the RO mode.",
          "createdAt": "2019-05-31T23:10:53Z",
          "updatedAt": "2019-05-31T23:10:53Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "A couple other small comments:\r\n\r\n- the line marked `msg = S0` merges into a line marked `msg = s` in a way that is unclear. Does this mean that `S0` gets replaced by `s`? (I know the answer to this; the point is, the reader doesn't, otherwise they wouldn't need the diagram.)\r\n\r\n- in the ROM case, the cofactor clearing operation should happen **after** the points are added together, not before. Clearing the cofactor commutes with point addition, so the result is the same either way, but clearing the cofactor is, in the general case, expensive, so it should not be repeated unnecessarily.",
          "createdAt": "2019-06-02T20:41:38Z",
          "updatedAt": "2019-06-02T20:41:38Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to gradually update this PR following the evolution of the draft. \r\n\r\nThis is a secondary material. The priority is on the main doc.",
          "createdAt": "2019-06-13T09:28:35Z",
          "updatedAt": "2019-06-13T09:28:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh as the document is stabilizing (?), can we update this before the draft deadline?",
          "createdAt": "2020-03-05T22:11:25Z",
          "updatedAt": "2020-03-05T22:11:25Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh this looks good, modulo one nit: we use `msg` instead of `alpha` as the `hash_to_curve` and `encode_to_curve` input parameter. ",
          "createdAt": "2020-03-09T19:05:33Z",
          "updatedAt": "2020-03-09T19:05:33Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed now. ",
          "createdAt": "2020-03-09T19:14:02Z",
          "updatedAt": "2020-03-09T19:14:02Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "A couple small comments:\r\n\r\n- Hash2Field : should this be HashToField? MapToCurve says `To`, not `2`.\r\n\r\n    Really, both of these are inconsistent with the notation in the document, which uses snake rather than camel case. It might be worthwhile to use the function names from Section 3, which are\r\n    - hash_to_field\r\n    - map_to_curve\r\n    - clear_cofactor\r\n\r\n- Does it make sense to show the DST as being an input to Hash2Field? I'm not sure if this matters so much, but it might be nice to show people where domain separation comes from.\r\n\r\n    On the other hand, maybe simplicity is better for this diagram.\r\n\r\n- HashToField's outputs should be explicitly described as being in F, maybe in the same way as in the MapToCurve box (i.e., `u \\in F`).\r\n\r\n- A lot of the parameters in the lower-right box in the diagram aren't used in the diagram. Maybe we should simplify by removing them?\r\n\r\n    - p, q, and m aren't used\r\n    - n isn't used\r\n    - r, h, h' aren't used\r\n    - H and b aren't used\r\n\r\n    I'm strongly in favor of removing all of them---and especially H and b, because it will be confusing to talk about a hash function on a slide that's supposed to be defining a different kind of hash function.\r\n\r\n- In Section 3, we say `R = Q0 + Q1`, not `Q`. Probably would be good to be consistent here so that people don't get confused when cross-referencing.",
          "createdAt": "2020-03-09T19:19:16Z",
          "updatedAt": "2020-03-09T19:19:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam if this looks good to you, shall we merge and then submit?",
          "createdAt": "2020-03-09T19:19:21Z",
          "updatedAt": "2020-03-09T19:19:21Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we could submit without merging this, right? (It doesn't change the document, just the repo.)",
          "createdAt": "2020-03-09T19:20:35Z",
          "updatedAt": "2020-03-09T19:20:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think we could submit without merging this, right? (It doesn't change the document, just the repo.)\r\n\r\nYep!",
          "createdAt": "2020-03-09T19:21:47Z",
          "updatedAt": "2020-03-09T19:21:47Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, one more comment: `Start` vs `END` is inconsistent.",
          "createdAt": "2020-03-09T19:22:37Z",
          "updatedAt": "2020-03-09T19:22:37Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh! And: `U` should be lower-case to match Section 3.",
          "createdAt": "2020-03-09T19:23:23Z",
          "updatedAt": "2020-03-09T19:23:23Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed @kwantam comments.",
          "createdAt": "2020-03-09T20:55:00Z",
          "updatedAt": "2020-03-09T20:55:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Addressed @kwantam comments.\r\n\r\nThanks! It looks like all but the DST comment were addressed. I'm fine with omitting that for now. @kwantam, are you OK with the latest diagram?",
          "createdAt": "2020-03-09T21:40:53Z",
          "updatedAt": "2020-03-09T21:40:53Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good to me!\r\n\r\nI guess one tiny little nit---not clear whether `Q = (x, y)` and `R = (x, y)` on the arrows going into clear_cofactor are communicating any information. Would it be OK if the labels just said `Q` and `R`?\r\n\r\nI'm fine leaving out the DST. Probably too low-level for this diagram anyway.",
          "createdAt": "2020-03-09T22:29:31Z",
          "updatedAt": "2020-03-09T22:29:31Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm fine leaving out the DST. Probably too low-level for this diagram anyway.\r\n\r\nThe API for `encode_to_curve` and `hash_to_curve` only take `msg` as input. The DST is defined per-invocation of the encoding. It is difficult to express this property in a high-level diagram.\r\n",
          "createdAt": "2020-03-13T19:28:16Z",
          "updatedAt": "2020-03-13T19:28:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NTM3MjAy",
          "commit": {
            "abbreviatedOid": "a838f58"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Awesome! I love this diagram. Only a couple comments before merging. \r\n\r\n- The input `s` should ideally match the notation we use in the document as input to `map2curve` and `hash2curve`. \r\n- Can we also draw boxes around the `map2curve` steps (flows where `msg = s`) and label it accordingly? Maybe even rewrite it so that we have a `map2curve` blackbox that is fed input `msg=s` and `msg=S_1`? That will remove redundant text and should simplify things.",
          "createdAt": "2019-05-31T22:01:44Z",
          "updatedAt": "2019-05-31T22:01:44Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1MTU1MDUx",
          "commit": {
            "abbreviatedOid": "a838f58"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Comments on drawing. Many of these are to align the diagram with the result of #116.\r\n\r\n1. No need for \"long string?\" or \"prehash\" boxes because of #116.\r\n\r\n2. As @chris-wood said, the input `s` should match the notation in the document. Section 5.1 calls this `alpha`. The diagram, the \"Interface\" section, and the new roadmap section in #119 should all agree here.\r\n\r\n3. RO and non-RO probably need to be clarified. I'm not exactly sure how to do this. @jedisct1's suggestion to split them is pretty good. I wonder if there's anything better? I might play with this offline and return with a suggestion.\r\n\r\n4. The `msg=s`, `msg=S0`, and `msg=S1` labels are confusing in their placement. Probably the solution to this depends on the solution to the immediately preceding point.\r\n\r\n5. `S0` and `S1` are defined incorrectly, and in fact don't need to be defined at all---`hash2base(msg, 0)` and `hash2base(msg, 1)`, suffice.\r\n\r\n6. `Hash2Field` should be `hash2base`. But maybe we should instead consider changing this notation in the document, because I think `hash2field` is clearer. Thoughts?\r\n\r\n7. The output of `Hash2Field` is incorrect. If `F` is the finite field, then the output of `Hash2Field` is exactly one element of `F`. Right now, the notation implies that the output of `Hash2Field` is some number `i > 0` of elements of `F`. Also, `{ }` is usually used to mean unordered sets, whereas `( )` is used to mean (ordered) tuples---but neither should be necessary here, because `U` is one element of `F`, so it's just `u = hash2base(msg, 0) \\in F` (for example). Also, `U` should be `u` to match the document's notation.\r\n\r\n8. `Encoding` should be `map2curve`.\r\n\r\n9. The RO case should compute `P = clear(Q1 + Q2)` rather than `P = clear(Q1) + clear(Q2)`. This is the topic of #120. It might be better to fix the document in a different PR (maybe #119, or I'm happy to make one), but this diagram may as well anticipate that change.\r\n\r\n10. `q`, `p`, and `m` are only used in the definition of `F`, so they probably should not appear in the diagram at all, since they introduce pointless notation. It's clearer for the diagram to refer to `F` in abstract terms everywhere.\r\n\r\n11. The same is true of `n`, `r`, and `h`---`n` is only used in the definitions of `h` and `r`, and the latter two are never used anywhere in the diagram! I would just get rid of them and keep `clear()` totally abstract.\r\n\r\n12. `clear()` should be `clear_h()` to match the text of the document.\r\n\r\n13. `hash2base`, `map2curve`, and `clear_h` should probably be defined in the \"parameters\" block. Right now they're not defined except implicitly when used, which is confusing.\r\n\r\n14. `b` is not used anywhere in the diagram except in the definition of H. As above, probably `H` is better left abstract; the extra detail does not make the diagram any clearer.\r\n\r\n15. I know that #119 adds the `E(F)` and `G` notation, but I'm still not at all sold on it either there or here. The issue is, it's not obvious how it clarifies the document: more notation makes it harder to understand for a non-expert, and expert readers do not need the notation to grok the diagram or the document.\r\n\r\n16. Is it necessary to reference the \"suite\" jargon in this diagram? Why not just say: \"the document specifies algorithms and parameters for well-known elliptic curves, and makes recommendations for curves that are not specifically covered.\" That conveys the same information without requiring the reader to learn the meaning of \"suite\" in this context.\r\n\r\n17. Is the URL the right one? Would it be better to refer readers to the github repo for now, since presumably the diagram will disagree with the content of the current draft?\r\n\r\n18. `Start` is initial caps, but `END` is all caps.\r\n\r\n19. The title of the draft is \"Hashing to Elliptic Curves\", but the title of this diagram is \"Hashing to Elliptic Curve Points.\" The diagram should match the document.\r\n\r\n20. The ASCII arrow `-->` in `f: {0, 1}* --> G` looks hackey given all the nice arrows everywhere else in the diagram. Also, what is the purpose of this piece of text? It repeats information presented more clearly elsewhere in the diagram, and it introduces new notation (`f`) that's never used anywhere else and is inconsistent with what is in the document. My suggestion is to just delete it.\r\n\r\n21. Why does the arrow coming out of the green box say `Q = (x, y)` rather than just `Q`? The arrow coming out of the purple box doesn't say `U = Hash2Field(msg)`, which would be analogous. Beyond being inconsistent, it's not necessary: the yellow box doesn't use `(x, y)`, only `Q`. And having the duplicated notation makes it more likely that a future edit introduces a new inconsistency.",
          "createdAt": "2019-06-03T22:25:56Z",
          "updatedAt": "2019-06-03T22:29:58Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0NTc1NDQ3",
          "commit": {
            "abbreviatedOid": "845d355"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-13T20:02:16Z",
          "updatedAt": "2020-03-13T20:02:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 119,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg0MzA2MTAx",
      "title": "Adds a roadmap section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/119",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Changes:\r\n - Gives a brief description about hash curve looks like.\r\n - Promotes clear cofactor as a section.\r\n - Introduces the notion of G, a group/subgroup of interest.\r\n - ~~Updates ROM to be consistent with hash2curve.~~\r\n - ~~Sketches the suite section (here more work is needed).~~",
      "createdAt": "2019-06-02T00:11:52Z",
      "updatedAt": "2019-06-04T20:26:34Z",
      "closedAt": "2019-06-04T20:26:34Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "High-level comments:\r\n\r\n- The roadmap section seems like a good idea.\r\n\r\n- It's not obvious to me that adding more notation (E(F), G, etc) improves the clarity of the document. It's also not obvious that it worsens clarity! My point is just to caution against adding notation for its own sake.\r\n\r\n- `hash2curveROM` seems redundant in terms of distinguishing uniform random from not: non-RO is `map2curve`, RO is `hash2curve`. Note also that `hash2curve` used to be `hash2curveRO` and that was changed because it seemed unnecessary.\r\n\r\n- The changes in the random oracle section conflict with #116, and some of the changes here are already comprehended there. Probably that PR should be resolved before these changes are considered.\r\n\r\n- The question of suite recommendations seems orthogonal to the roadmap section, and it also needs a bunch of discussion and hammering out. It doesn't seem to make sense to do a partial edit in this commit.\r\n\r\nI'm happy to do a line-by-line review of this PR once the disposition of #116 is finalized and any resulting conflicts are resolved.",
          "createdAt": "2019-06-02T20:51:31Z",
          "updatedAt": "2019-06-02T20:52:14Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased with master, includes changes only for the roadmap section.\r\n\r\nHowever, a major update of the roadmap section is WIP: #121  .\r\n",
          "createdAt": "2019-06-03T23:34:40Z",
          "updatedAt": "2019-06-03T23:35:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh is this PR superseded by #121?",
          "createdAt": "2019-06-04T15:55:59Z",
          "updatedAt": "2019-06-04T15:55:59Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> @armfazh is this PR superseded by #121?\r\n\r\nYes, this one can be closed. \r\n\r\n",
          "createdAt": "2019-06-04T20:25:24Z",
          "updatedAt": "2019-06-04T20:25:24Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 121,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg0NzY2NjA2",
      "title": "Extended roadmap section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/121",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Changes:\r\n - Roadmap section is expanded to introduce 2 types of functions\r\n   to be supported. Injective Encodings and Random Oracles. (the\r\n   names can be changed accordingly).\r\n - The Random oracle section was merged in Section 2.2.3. in which\r\n   only alerts the reader how to construct a random oracle using\r\n   FFSTV.\r\n - For efficiency, clear cofactor is performed once. #120.\r\n\r\nTBD:\r\n - In the random oracle, hash2base is hashing twice the input, this\r\n   can be fixed by removing the call to the hash function from\r\n   hash2base.\r\n - As always, names of functions and variables can be changed to\r\n   something meaningful.\r\n",
      "createdAt": "2019-06-03T23:35:15Z",
      "updatedAt": "2019-06-18T19:58:05Z",
      "closedAt": "2019-06-18T19:58:05Z",
      "mergedAt": "2019-06-18T19:58:05Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a WIP pull-request.  \r\nIt is expected that this PR serve as a starting point for giving feedback.\r\n",
          "createdAt": "2019-06-03T23:48:05Z",
          "updatedAt": "2019-06-03T23:48:05Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding the first TODO: I know I've expressed this elsewhere, but I don't think it's a problem that the high-level description of the RO construction based on hash2base calls H(msg) twice. As long as the document points out the optimization, implementors will be able to take advantage of it. It's quite trivial.\r\n\r\nIn my mind, the argument against making the optimization explicit is that doing so makes the description more complicated, with no benefit. Since the optimization is trivial, my sense is that the document should optimize for clarity instead.\r\n\r\nIn contrast, other optimizations that are not trivial probably should be included. For example, it's possible to save an inversion in most of the mappings by combining the inversion and sqrt computations and returning a projective point. In contrast to the above, this is likely to be non-obvious, so here my sense is that the document *should* describe the optimization (specifically, in the low-level implementation descriptions).",
          "createdAt": "2019-06-04T01:08:48Z",
          "updatedAt": "2019-06-04T01:16:02Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry for the delay reviewing. I'll have time this afternoon.",
          "createdAt": "2019-06-10T16:36:42Z",
          "updatedAt": "2019-06-10T16:36:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh will you have time to respond to @kwantam's comments? If not, would you like me to apply a patch to this PR (or a branch with the changes in a separate PR)?",
          "createdAt": "2019-06-12T15:51:54Z",
          "updatedAt": "2019-06-12T15:51:54Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I am preparing an update addressing the comments.\n\n\n>\n",
          "createdAt": "2019-06-12T16:46:07Z",
          "updatedAt": "2019-06-12T16:46:07Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I addressed most of the comments from your reviews. If I omitted something, let me know.\r\n\r\n",
          "createdAt": "2019-06-13T09:26:22Z",
          "updatedAt": "2019-06-13T09:26:22Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh can you please resolve conflicts?",
          "createdAt": "2019-06-17T18:09:46Z",
          "updatedAt": "2019-06-17T18:09:46Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@grittygrease @samscott89 @kwantam we should aim to land this PR sometime this week \u2014 please let me know if you won\u2019t have time to do a review!",
          "createdAt": "2019-06-17T18:10:46Z",
          "updatedAt": "2019-06-17T18:10:46Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry for the delay again. I'll review this afternoon / evening.",
          "createdAt": "2019-06-17T18:42:07Z",
          "updatedAt": "2019-06-17T18:42:07Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I updated addressing latest review (rebased with master)",
          "createdAt": "2019-06-18T04:36:55Z",
          "updatedAt": "2019-06-18T04:36:55Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks great :+1:\r\n\r\n~~Just one more quick change, please: change `G` to `P` in 5 spots in Related Work.~~",
          "createdAt": "2019-06-18T16:26:44Z",
          "updatedAt": "2019-06-18T18:00:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ2MDM5NDcw",
          "commit": {
            "abbreviatedOid": "343f888"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Good start! I left some comments regarding name choices and other editorial nits.",
          "createdAt": "2019-06-05T14:21:42Z",
          "updatedAt": "2019-06-05T14:36:33Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "nit: no trailing period needed",
              "createdAt": "2019-06-05T14:21:42Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 63,
              "body": "nit: `h>=1` -> `h >= 1`",
              "createdAt": "2019-06-05T14:22:22Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 113,
              "body": "I don't think the name should be prefixed with `h2c`, since it lacks the uniform property. Maybe `encode2curve`, or something similar? ",
              "createdAt": "2019-06-05T14:24:18Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 121,
              "body": "Naming related: this should probably be `clear_cofactor` to be consistent with other symbol names.",
              "createdAt": "2019-06-05T14:25:25Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 116,
              "body": "Do we need to specify the point representation? Or should we leave a comment saying that the representation depends on the implementation of the internal `map2curve` function?",
              "createdAt": "2019-06-05T14:25:56Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 129,
              "body": "I think this should just be `hash2curve`. No need to include \"RandomOracle\" in the name.",
              "createdAt": "2019-06-05T14:26:39Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 107,
              "body": "We should expand on this a bit and more clearly highlight the differences between encoding and hashing to the curve. Perhaps:\r\n\r\n```\r\nA mapping can either yield a uniform distribution over the range of points on the curve or not. A mapping that does not yield a uniform distribution is an injective encoding. Example algorithms include Elligator2, wherein the algorithm maps input strings to approximately half of the points on the curve. A mapping that yields a uniform distribution is, effectively, a random oracle from strings to points on the curve. Where appropriate, we use the terms random oracle and hash functions for such mappings interchangeably.```",
              "createdAt": "2019-06-05T14:31:55Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 152,
              "body": "```suggestion\r\n{{suites}} of this document provides a list of suites for hash2curve algorithms.\r\n```",
              "createdAt": "2019-06-05T14:34:13Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 153,
              "body": "It occurs to me that there are no suites for injective encodings. Should we add some?",
              "createdAt": "2019-06-05T14:35:57Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ3OTM5MTc2",
          "commit": {
            "abbreviatedOid": "03f8e51"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Adding this new section is a great idea!\r\n\r\nI've commented pretty heavily, but I hope not to the point of being discouraging :)\r\n\r\nThe high-level ideas are great, there are just a few issues with clarity and consistency that I'm sure we will solve quickly.",
          "createdAt": "2019-06-11T03:42:00Z",
          "updatedAt": "2019-06-11T05:52:09Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "The `E(F)` notation, while certainly correct, seems both unnecessary and potentially confusing to (some) readers.\r\n\r\nSpecifically:\r\n\r\n- this notation is not resolving ambiguity, because any time we talk about points on the curve it's clear from the context what curve and what field we mean. Beyond that, even when using `E(F)` the reader *still* has to rely on context to know what curve and field we mean!\r\n\r\n- it's also not saving space: it's only used a few times in this pull request, and the equivalent concept written in words is short enough to be used instead.\r\n\r\n- on the other hand, its use forces readers to learn a new piece of terminology, which actually makes the document *less* clear and harder to read.\r\n\r\nSo: I'd suggest removing all uses of E(F), and instead just using words. Concretely, I suggest simply removing \", denoted as E(F),\" here. I'll add notes to suggest other updates.",
              "createdAt": "2019-06-11T03:42:00Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 37,
              "body": "`G` is used elsewhere in the document (in the relwork appendix, at least) to mean a point, so this is now overloaded notation.\r\n\r\nSame question as above: why introduce extra notation here? The old text was, to my eyes, just as clear.",
              "createdAt": "2019-06-11T03:55:34Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 39,
              "body": "For our purposes, `G` is *always* a subgroup of prime order. No need to hedge (\"usually taken as\") here.",
              "createdAt": "2019-06-11T03:56:16Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 40,
              "body": "\"known as\" -> \"called\"",
              "createdAt": "2019-06-11T03:56:41Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 59,
              "body": "Suggest removing this line.",
              "createdAt": "2019-06-11T03:58:01Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 60,
              "body": "\"Number of points in the group of points on the elliptic curve E.\"\r\n\r\nthe `#E(F)` terminology is also unnecessary.\r\n\r\nAlso, \"n = h * r\" (the old \"relevance\" entry) is much more informative than \"This value can be prime or composite,\" which doesn't provide any new information. I suggest \"n = h * r, for h and r defined below.\"",
              "createdAt": "2019-06-11T04:02:11Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 61,
              "body": "Suggest removing this line.",
              "createdAt": "2019-06-11T04:02:18Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 62,
              "body": "I suggest:\r\n\r\n- Meaning: \"The order of the prime subgroup to which bitstrings are mapped.\"\r\n\r\n- Relevance: \"r is the largest prime factor of n.\"",
              "createdAt": "2019-06-11T04:06:24Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 63,
              "body": "\"integer number\" -> \"integer\"",
              "createdAt": "2019-06-11T04:06:49Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 152,
              "body": "Also, probably just remove \"of this document \".",
              "createdAt": "2019-06-11T04:15:44Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 153,
              "body": "Also, \"can be considered as\" -> \"is\". No need to hedge.",
              "createdAt": "2019-06-11T04:16:18Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 146,
              "body": "This section defines `clear_h`, which every encoding in Deterministic Encodings uses. So moving it here causes a use-before-def.\r\n\r\nBut probably given the new roadmap section we should *remove* `clear_h` from the encodings, in which case this can be later in the document as long as there's a clear forward ref to it from the roadmap.",
              "createdAt": "2019-06-11T04:21:45Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 148,
              "body": "\"of this section\" is no longer correct, since this is now its own section rather than a subsection of \"Deterministic Encodings.\" Perhaps\r\n\r\n    The encodings of {{encodings}} always",
              "createdAt": "2019-06-11T04:22:32Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 93,
              "body": "\"In other words:\" and the next 9 lines should be removed and replaced by \"We describe this construction in {{roadmap}}.\"\r\n\r\nDefining the random oracle construction redundantly with incompatible terminology will confuse readers (why are they different? how do I implement H0? etc.).",
              "createdAt": "2019-06-11T04:35:43Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 104,
              "body": "Just \"Roadmap.\" It's a top-level section of the document; there's no ambiguity about what it's a roadmap for.",
              "createdAt": "2019-06-11T04:38:14Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 107,
              "body": "Note that some of this is defined in the prior section. Probably this shouldn't repeat; maybe reference?",
              "createdAt": "2019-06-11T04:39:07Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 121,
              "body": "In the rest of the document this function is called `clear_h`. Whatever we decide on needs to be consistent.",
              "createdAt": "2019-06-11T04:39:40Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 107,
              "body": "\"prime group G\" -> \"points on an elliptic curve E\". The first sentence of the section does not need this level of detail, and having too much detail here makes it hard to understand.",
              "createdAt": "2019-06-11T04:45:25Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 107,
              "body": "Also, to Chris's point: the first paragraph of the section should introduce (or re-introduce) the high-level concepts before jumping into the low-level details.\r\n\r\nMaybe the right way to do this is to add a new paragraph before what's currently here that tells the reader what's ahead:\r\n\r\n- high level: three pieces (hash2base, map2curve, clear_h)\r\n- the following sections define each piece in detail\r\n- {{term-rom}} discussed two possibilities: injective mapping vs random oracle\r\n\r\netc",
              "createdAt": "2019-06-11T05:18:21Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 116,
              "body": "I'd say not in this section. High-level concepts here, low-level details elsewhere. But probably a forward ref to such discussion would be useful.",
              "createdAt": "2019-06-11T05:19:15Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 120,
              "body": "suggest \"E(F)\" -> \"point on E\"",
              "createdAt": "2019-06-11T05:20:35Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 121,
              "body": "suggest \"G\" -> \"point on E in prime-order subgroup\"",
              "createdAt": "2019-06-11T05:21:12Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 139,
              "body": "suggest (prior three lines):\r\n\r\n\"E(F) x E(F)\" -> \"two points on E\". Cartesian product notation isn't necessarily familiar to all readers.\r\n\r\n\"E(F)\" -> \"point on E\"",
              "createdAt": "2019-06-11T05:22:02Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 140,
              "body": "suggest: as above",
              "createdAt": "2019-06-11T05:22:18Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 122,
              "body": "\"Output\" -> \"return\" (used everywhere else; note case)",
              "createdAt": "2019-06-11T05:22:51Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 135,
              "body": "`{0,1}*` is written everywhere else as `{0, 1}^*` (note space between comma and 1, \"^\" symbol)\r\n\r\nSame comment applies on the next line, and in step 1 of the prior function",
              "createdAt": "2019-06-11T05:25:05Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 111,
              "body": "The two functions below use a bunch of notation that's not defined (hash2base? map2curve? etc). Readers will be confused by use-before-def.\r\n\r\nThere should be a sentence here introducing these function names and forward reffing to the sections that describe each.",
              "createdAt": "2019-06-11T05:26:58Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 145,
              "body": "The first sentence of this paragraph is confusing because it makes the reader feel like they're missing something (what properties?). I would get rid of it.\r\n\r\nThe rest of this paragraph should go *above* the function definitions (I left another comment there) so that hash2base etc are not used before def.",
              "createdAt": "2019-06-11T05:30:44Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 151,
              "body": "Comments on the above paragraph:\r\n\r\n- Each sentence should name a function (hash2base, etc) and give a brief idea of what that function does, then forward ref to the correct section.\r\n\r\n- The sentence that starts \"Due to the diversity...\" isn't necessary here, and \"Some possible choices\" hedges too much and simultaneously makes the reader feel nervous that they're going to have to make a bunch of decisions.\r\nInstead, maybe something like\r\n\r\n    The map2curve function depends on the target elliptic curve. {{encodings}} describes mappings for a range of curve families.\r\n\r\n- Maybe: \"The function clear_h maps any point on E to a point in the subgroup of prime order r ({{bg-curves}}); it is described in {{cofactor-clearing}}.\" (No need for G.)",
              "createdAt": "2019-06-11T05:45:23Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 152,
              "body": "Also, \"provides a list of\" -> \"defines\"",
              "createdAt": "2019-06-11T05:46:37Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 154,
              "body": "\"required to instantiate ... of interest\" -> \"for standard elliptic curves.\"",
              "createdAt": "2019-06-11T05:48:18Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ4ODUyOTI5",
          "commit": {
            "abbreviatedOid": "343f888"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-12T15:44:44Z",
          "updatedAt": "2019-06-12T15:44:45Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "Agreed!",
              "createdAt": "2019-06-12T15:44:44Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ4ODUzOTUw",
          "commit": {
            "abbreviatedOid": "343f888"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-12T15:46:12Z",
          "updatedAt": "2019-06-12T15:46:13Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "+1 to this proposal.",
              "createdAt": "2019-06-12T15:46:13Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ4ODU0NTU5",
          "commit": {
            "abbreviatedOid": "343f888"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-12T15:47:05Z",
          "updatedAt": "2019-06-12T15:47:06Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "@kwantam does it refer to the generator in the related work? If so, perhaps we could unify around `P` (or whatever we use in the rest of the document) for the generator?",
              "createdAt": "2019-06-12T15:47:05Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ4ODU1NTc1",
          "commit": {
            "abbreviatedOid": "343f888"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-12T15:48:40Z",
          "updatedAt": "2019-06-12T15:48:40Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Or perhaps replace `A subgroup of E(F).` with `A prime-order subgroup of the curve`?",
              "createdAt": "2019-06-12T15:48:40Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ5MjIwMTIw",
          "commit": {
            "abbreviatedOid": "1de5f6e"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-13T09:11:58Z",
          "updatedAt": "2019-06-13T09:11:58Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "My reasoning to introduce G is because for a suite for pairing curves will refer to the same curve but different subgroups, say G1 and G2. \r\n\r\nI ack that, In some cases, it is more convenient to use only one character, and in others, a verbose text is better. However, G is a general letter used for groups, and we are proposing a way to hashing into a group. \r\n\r\nFinally, G also clashes with generator of curves, but in this draft no generators are used.\r\n",
              "createdAt": "2019-06-13T09:11:58Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ5MjIxMzk3",
          "commit": {
            "abbreviatedOid": "1de5f6e"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-13T09:14:26Z",
          "updatedAt": "2019-06-13T09:14:26Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "I am not entirely sure if r always matches with the largest subgroup. It seems to be true. But let's double check in the case of pairing curves.",
              "createdAt": "2019-06-13T09:14:26Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ5MjI0MDU2",
          "commit": {
            "abbreviatedOid": "1de5f6e"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-13T09:19:09Z",
          "updatedAt": "2019-06-13T09:19:09Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "The arrow notation must be used between sets.\r\n\r\nIndeed, I tried all of these suggestions, but the text looked ugly. I decided to remove those comments and included the arrow notation in the description of the functions. Hope be more legible now.\r\n",
              "createdAt": "2019-06-13T09:19:09Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ5MjI0Mzc1",
          "commit": {
            "abbreviatedOid": "1de5f6e"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-13T09:19:47Z",
          "updatedAt": "2019-06-13T09:19:47Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "I like this change.",
              "createdAt": "2019-06-13T09:19:47Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ5MjI1MjQ5",
          "commit": {
            "abbreviatedOid": "1de5f6e"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-13T09:21:29Z",
          "updatedAt": "2019-06-13T09:21:29Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "I did not  understand entirely your comment, but let me know if the new version improves what you was pointing out.",
              "createdAt": "2019-06-13T09:21:29Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ5NDYxNjI1",
          "commit": {
            "abbreviatedOid": "1de5f6e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The latest changes look mostly good to me. Approving for now, since we can address some of the nits in follow up PRs. Thanks for making this change, @armfazh, and for the thorough and thoughtful review, @kwantam!",
          "createdAt": "2019-06-13T16:21:13Z",
          "updatedAt": "2019-06-17T18:09:25Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I'd drop \"since they lead to the more difficult...\" suffix of this sentence.",
              "createdAt": "2019-06-13T16:21:13Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 22,
              "body": "nit: s/to an elliptic/an elliptic",
              "createdAt": "2019-06-13T16:22:26Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 132,
              "body": "I think @kwantam's point was that this sentence doesn't add much value, since it doesn't describe what the properties are and just points below. I vote for removing it too!",
              "createdAt": "2019-06-13T16:23:18Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 140,
              "body": "nit: \"On the other hand, the second\" -> \"The second\"",
              "createdAt": "2019-06-13T16:24:01Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwNzgwODUx",
          "commit": {
            "abbreviatedOid": "42a852e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-17T22:37:01Z",
          "updatedAt": "2019-06-17T22:37:01Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "Stashed a note about injective encodings suites in #126.",
              "createdAt": "2019-06-17T22:37:01Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwNzg0MDA0",
          "commit": {
            "abbreviatedOid": "42a852e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-17T22:48:03Z",
          "updatedAt": "2019-06-17T22:48:04Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "You're right, it does make sense to use G, G1, G2 as you describe. :+1:\r\n\r\nThere is one conflicting use of `G` as a generator in the relwork section on the master branch. Also, the commit 1de5f6ebba134de9584e0d2fe8954ecd88a0e4ab introduced a conflict with the master branch, because it edits the \"Try-And-Increment\" appendix, which #122 removed.\r\n\r\nIt should be a quick fix to remove that piece of the commit (it's the very last line of the diff). @armfazh, when you fix the conflict, can you please at the same time rebase onto master and rename `G` to `P` in the relwork section? The only occurrence is in the second-last paragraph (the one that starts \"Brier et al. ...\")",
              "createdAt": "2019-06-17T22:48:03Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwNzg1Nzg4",
          "commit": {
            "abbreviatedOid": "42a852e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-17T22:54:24Z",
          "updatedAt": "2019-06-17T22:54:24Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "Great point! You're totally right that for the \"big\" group on pairing-friendly curves, r isn't necessarily the largest prime factor. Nice catch :+1:",
              "createdAt": "2019-06-17T22:54:24Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwNzg2Njcy",
          "commit": {
            "abbreviatedOid": "42a852e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-17T22:57:33Z",
          "updatedAt": "2019-06-17T22:57:33Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Yes, these edits almost totally take care of my concerns :+1: ",
              "createdAt": "2019-06-17T22:57:33Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwNzg3NDA4",
          "commit": {
            "abbreviatedOid": "42a852e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "@armfazh great edits! A few very small nits and then things look great to me.",
          "createdAt": "2019-06-17T23:00:11Z",
          "updatedAt": "2019-06-17T23:31:02Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "nit: no need for comma before \"whose\"",
              "createdAt": "2019-06-17T23:00:11Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 42,
              "body": "nit: comma splice. I suggest either changing the comma to semicolon, or changing to a period and making \"This operation...\" a new sentence.",
              "createdAt": "2019-06-17T23:05:17Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 95,
              "body": "Nit: passive voice in first sentence. Maybe:\r\n\r\nThis section presents a general framework for mapping bit strings into points on an elliptic curve. To construct these mappings, we rely on three basic functions:",
              "createdAt": "2019-06-17T23:12:36Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 97,
              "body": "tiny nit: escape * with backslash (\"*\" => \"\\*\"). Otherwise there is ambiguity about whether this * starts an italicized section.",
              "createdAt": "2019-06-17T23:15:40Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 112,
              "body": "nit: called *an* injective encoding",
              "createdAt": "2019-06-17T23:19:43Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 114,
              "body": "Here I think \"hash function\" is confusing, because not all hash functions can be modeled as random oracles. Certainly collision resistance doesn't imply usability as a PRF, for example.\r\n\r\nMaybe \"behaves as a random oracle, since its output\" instead?",
              "createdAt": "2019-06-17T23:21:08Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 136,
              "body": "If we're going to use the terminology this way, the above sentence should appear earlier. But my preference would be to remove this sentence and just be careful to say \"random oracle\" in the text.",
              "createdAt": "2019-06-17T23:23:17Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 117,
              "body": "\"encodings\" -> \"encoding\"\r\n\r\nAlso, suggest active voice in the next sentence: \"This function maps bit strings to points in G. Note that the distribution of the output is not uniform.\"",
              "createdAt": "2019-06-17T23:24:17Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 134,
              "body": "I'd make this sentence mirror the one above: \"This function maps bit strings to points in G that are indistinguishable from uniformly random.\"\r\n\r\n\"Can be used as a random oracle\" is redundant with the immediately preceding label, \"Random Oracle,\" so I think it should be removed.",
              "createdAt": "2019-06-17T23:25:53Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 507,
              "body": "nit: \"Output\" -> \"return\" for consistency?",
              "createdAt": "2019-06-17T23:28:43Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 686,
              "body": "NOTE: this edit is causing the conflict with master. I suggest removing this edit and then rebasing onto master.",
              "createdAt": "2019-06-17T23:29:59Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            },
            {
              "originalPosition": 686,
              "body": "Also, ~20 lines above this point is where `G` is used as a point, and probably should be changed to `P`.",
              "createdAt": "2019-06-17T23:30:35Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwODU1ODE5",
          "commit": {
            "abbreviatedOid": "50425ec"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-18T04:35:32Z",
          "updatedAt": "2019-06-18T04:35:33Z",
          "comments": [
            {
              "originalPosition": 507,
              "body": "good catch",
              "createdAt": "2019-06-18T04:35:33Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxMjE1MTcz",
          "commit": {
            "abbreviatedOid": "50425ec"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-18T16:25:56Z",
          "updatedAt": "2019-06-18T16:25:57Z",
          "comments": [
            {
              "originalPosition": 686,
              "body": "This is the only remaining issue: in the Related Work appendix, there are 5 uses of the symbol `G` to mean a point that generates a prime-order subgroup. I suggest changing these to `P`.",
              "createdAt": "2019-06-18T16:25:56Z",
              "updatedAt": "2019-06-18T17:50:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxMjY2NzQ5",
          "commit": {
            "abbreviatedOid": "d512754"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-18T18:01:09Z",
          "updatedAt": "2019-06-18T18:01:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 122,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg0NzgwMTY5",
      "title": "pass over relwork",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/122",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This commit passes over the relwork, making it a bit more compact and improving coverage, including map-to-bitstring. Closes #113.\r\n\r\nThis commit also removes the appendix section that gives details on the Try-and-Increment method:\r\nsince try-and-increment is not recommended for any curve, there is no need to provide pseudocode, and doing so may have the unfortunate effect of encouraging its use. And since that section sans pseudocode is redundant with the description of MapToGroup from BLS01 in relwork, there's no need to include it. Of course, interested readers can follow the BLS01 cite.",
      "createdAt": "2019-06-04T01:03:13Z",
      "updatedAt": "2019-06-05T19:22:49Z",
      "closedAt": "2019-06-04T21:16:53Z",
      "mergedAt": "2019-06-04T21:16:53Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Great catches, thanks! Fixed now.",
          "createdAt": "2019-06-04T20:57:42Z",
          "updatedAt": "2019-06-04T20:57:42Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1NTQwMzky",
          "commit": {
            "abbreviatedOid": "972e632"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is a nice reduction in text without losing content. Interested readers can follow references for  more information should they want or need it. Thanks for the change!\r\n\r\n@armfazh, please have a look when you can.",
          "createdAt": "2019-06-04T15:51:00Z",
          "updatedAt": "2019-06-04T15:52:34Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1Njg2ODg5",
          "commit": {
            "abbreviatedOid": "972e632"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Small nits only.",
          "createdAt": "2019-06-04T20:32:36Z",
          "updatedAt": "2019-06-04T20:35:05Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "the characteristic is p",
              "createdAt": "2019-06-04T20:32:36Z",
              "updatedAt": "2019-06-04T20:57:09Z"
            },
            {
              "originalPosition": 206,
              "body": " q -> p",
              "createdAt": "2019-06-04T20:33:05Z",
              "updatedAt": "2019-06-04T20:57:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 123,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg1NDE3Mjc4",
      "title": "Clarify hash2base requirements for H.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/123",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@kwantam, please have a look!",
      "createdAt": "2019-06-05T15:02:53Z",
      "updatedAt": "2019-06-05T20:09:26Z",
      "closedAt": "2019-06-05T20:09:26Z",
      "mergedAt": "2019-06-05T20:09:26Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam thanks for the comments! I think I've resolved both.",
          "createdAt": "2019-06-05T18:49:22Z",
          "updatedAt": "2019-06-05T18:49:22Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ2MTcwMTk4",
          "commit": {
            "abbreviatedOid": "14c49c8"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Nice, this PR does a great job clarifying.\r\n\r\nMaybe just a couple small tweaks, what do you think?",
          "createdAt": "2019-06-05T18:05:19Z",
          "updatedAt": "2019-06-05T18:29:38Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "It might be slightly more accurate to say\r\n\r\n> H is modeled as a random oracle, so its output must be indistinguishable from a uniformly random bit string.\r\n\r\nbecause of course SHA doesn't *really* output a uniformly random bit string... :)\r\n\r\nAlso, maybe it would be good to pull the \"For example\" sentence below point (2), to make clear that SHA-256 satisfies both requirements.",
              "createdAt": "2019-06-05T18:21:42Z",
              "updatedAt": "2019-06-05T18:59:59Z"
            },
            {
              "originalPosition": 20,
              "body": "\"as is generally assumed (in other words...\"\r\n\r\nis redundant with the new point (2). Probably can just cut from \", as is\" to the end of the sentence.",
              "createdAt": "2019-06-05T18:23:02Z",
              "updatedAt": "2019-06-05T18:59:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ2MTkxNjk0",
          "commit": {
            "abbreviatedOid": "14c49c8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-05T18:47:08Z",
          "updatedAt": "2019-06-05T18:47:08Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Agreed -- fixed!",
              "createdAt": "2019-06-05T18:47:08Z",
              "updatedAt": "2019-06-05T18:59:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ2MTkyMTQz",
          "commit": {
            "abbreviatedOid": "14c49c8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-05T18:48:03Z",
          "updatedAt": "2019-06-05T18:48:04Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Yep, dropped!",
              "createdAt": "2019-06-05T18:48:04Z",
              "updatedAt": "2019-06-05T18:59:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ2MTk3ODcw",
          "commit": {
            "abbreviatedOid": "42f4075"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-05T18:59:25Z",
          "updatedAt": "2019-06-05T18:59:25Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Uh, oops. I'll revert this.",
              "createdAt": "2019-06-05T18:59:25Z",
              "updatedAt": "2019-06-05T18:59:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ2MjA2NDc4",
          "commit": {
            "abbreviatedOid": "84ceebb"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-05T19:17:44Z",
          "updatedAt": "2019-06-05T19:17:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 125,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg2MDA2MDkw",
      "title": "Remove hacspec code and reference the GitHub repository for more info.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/125",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-06-06T23:41:58Z",
      "updatedAt": "2019-06-07T23:31:25Z",
      "closedAt": "2019-06-07T23:31:24Z",
      "mergedAt": "2019-06-07T23:31:24Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": ":+1:",
          "createdAt": "2019-06-07T00:53:36Z",
          "updatedAt": "2019-06-07T00:53:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ2ODc4MDU4",
          "commit": {
            "abbreviatedOid": "87a6b1c"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-07T00:52:44Z",
          "updatedAt": "2019-06-07T00:52:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 127,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg5ODQ2MTUw",
      "title": "clarifications and formatting fixes in the early part of the document",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/127",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR doesn't make major content changes, it just clarifies and simplifies the text.\r\n\r\nWhat's changed:\r\n\r\n- kramdown-rfc2629 seems to produce broken HTML output from fenced code inside bulleted lists. The first commit pulls the fenced code back to the left margin, which fixes the issue.\r\n\r\n- I reworked and streamlined the terminology section. It had been growing organically for a little while and needed some pruning and harmonizing with the terminology in the rest of the document\r\n\r\n- I renamed \"injective encoding\" to \"nonuniform encoding,\" because I realized that the term \"injective\" is not correct: by a simple counting argument, hash2base must produce collisions for some inputs, so composing hash2base with map2curve cannot produce an injective function. **I'm not fixed on \"nonuniform\"**---does anyone have a better suggestion?\r\n\r\n- bibliography cleanup: moved most cites to \"informative\" from \"normative\" bib, added a couple general cites for further reading on elliptic curves, corrected a couple labels, and got rid of redundant entries.\r\n\r\n- Some very small edits in roadmap for clarity.",
      "createdAt": "2019-06-19T19:23:18Z",
      "updatedAt": "2019-06-26T17:04:03Z",
      "closedAt": "2019-06-26T17:04:03Z",
      "mergedAt": "2019-06-26T17:04:03Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "> I renamed \"injective encoding\" to \"nonuniform encoding,\" because I realized that the term \"injective\" is not correct: by a simple counting argument, hash2base must produce collisions for some inputs, so composing hash2base with map2curve cannot produce an injective function. I'm not fixed on \"nonuniform\"---does anyone have a better suggestion?\r\n\r\nPerhaps \"subset encoding\" or \"encoding to subset\"?\r\n\r\nAdditionally, perhaps we should specify that these are required to be \"well-distributed\", as specified by Farasahi et al., which is what permits their use in hash2curve. Which can be understood intuitively as meaning they are close to uniform over the target subset.",
          "createdAt": "2019-06-21T15:04:53Z",
          "updatedAt": "2019-06-21T15:04:53Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Perhaps \"subset encoding\" or \"encoding to subset\"?\r\n\r\nThis could work, but I have a couple concerns:\r\n\r\n- The way the encodings are described, the RO encodings are *also* encodings to subsets (namely, `G`), so this might be confusing.\r\n\r\n- \"Nonuniform\" emphasizes the important difference compared to ROs, which may be more helpful for implementors trying to choose the correct encoding for their application.\r\n\r\n> Additionally, perhaps we should specify that these are required to be \"well-distributed\", as specified by Farasahi et al., which is what permits their use in hash2curve. Which can be understood intuitively as meaning they are close to uniform over the target subset.\r\n\r\nThat's true for the `map2curve` functions---they are all well-distributed encodings---but the \"encodings\" as described here can't be, because their definitions are incommensurate. Specifically, for a function *f* to be well distributed, its type signature must be `F -> E(F)` [FFSTV, Def. 1]. (And this isn't a superficial syntactic distinction: the definition of a well-distributed encoding involves a character sum over F.)\r\n\r\nBut the above ties into [your other comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/127#discussion_r296278246): it may be worth clarifying (perhaps in ~~the map2curve section~~ an appendix---#128) that the mapping functions are (in general) invertible, well distributed, etc. Thoughts?",
          "createdAt": "2019-06-22T01:51:12Z",
          "updatedAt": "2019-06-23T14:10:46Z"
        },
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, that all makes sense. Apologies for the mixing of language, in my head encoding still refers to map2curve, and hashing for hash2curve :) \r\n\r\n> The way the encodings are described, the RO encodings are also encodings to subsets (namely, G), so this might be confusing.\r\n\r\n> \"Nonuniform\" emphasizes the important difference compared to ROs, which may be more helpful for implementors trying to choose the correct encoding for their application.\r\n\r\nCounter-point: the RO constructions aren't uniform either, just indifferentiable from one :) Also, defining something in terms of the absence of a feature seems slightly odd.\r\n\r\nAlthough, I suppose describing the encodings as non-uniform is slightly more intuitive than thinking about hashing to \"the whole group\" vs a \"subset of the group\", and what that means for security. Non-uniform sounds scarier and thus hopefully causes implementors to pause before using.",
          "createdAt": "2019-06-24T00:55:57Z",
          "updatedAt": "2019-06-24T00:55:57Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": " > Counter-point: the RO constructions aren't uniform either, just indifferentiable from one :)\r\n\r\nHah! true :+1:\r\n\r\n> Also, defining something in terms of the absence of a feature seems slightly odd.\r\n>\r\n> Although, I suppose describing the encodings as non-uniform is slightly more intuitive than thinking about hashing to \"the whole group\" vs a \"subset of the group\", and what that means for security. Non-uniform sounds scarier and thus hopefully causes implementors to pause before using.\r\n\r\nAs you say, the hope is to make sure that people *know* they're not getting a (pseudo)random element. I don't want to *scare* anyone per se, but I'll be happy if everyone who reads \"nonuniform\" pauses and thinks \"hmm, is that OK?\"",
          "createdAt": "2019-06-24T17:06:29Z",
          "updatedAt": "2019-06-24T17:06:29Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I've thought more about this and I believe I have a solution that closes #128 and addresses both @armfazh's and @samscott89's concerns about the above.\r\n\r\nAlso, @samscott89's comment above made me realize that the document isn't yet consistent on the use of \"encoding\" vs \"mapping.\" I'll address that, too.\r\n\r\nSo: I'm going to push an update tonight.",
          "createdAt": "2019-06-24T17:10:57Z",
          "updatedAt": "2019-06-24T17:10:57Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, the changes I'm about to push are slightly more extensive than I'd anticipated. But I believe they address the concerns about precision with respect to discussing invertibility, injectivity, etc., and should close #128. Comments very much appreciated.",
          "createdAt": "2019-06-25T05:32:06Z",
          "updatedAt": "2019-06-25T05:32:20Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I am currently reviewing the document, let me do a pass on it to match with the latest changes (9180fc1)",
          "createdAt": "2019-06-25T21:46:52Z",
          "updatedAt": "2019-06-25T21:46:52Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, rebased onto master. Should be good to go now.",
          "createdAt": "2019-06-26T17:02:32Z",
          "updatedAt": "2019-06-26T17:02:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUyMTQ2OTg2",
          "commit": {
            "abbreviatedOid": "e91688d"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-20T08:09:11Z",
          "updatedAt": "2019-06-20T08:38:48Z",
          "comments": [
            {
              "originalPosition": 227,
              "body": "This paragraph is correct but difficult to read. \r\nSuggestion or something similar to\r\n> Encodings may be invertible, thus there is an efficient method that recovers the bit strings from the points produced by the encoding.",
              "createdAt": "2019-06-20T08:09:11Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 227,
              "body": "we cover invertible encodings, but it must be stated that this property is not relevant for hash to curve.",
              "createdAt": "2019-06-20T08:11:52Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUyNDA5NjU5",
          "commit": {
            "abbreviatedOid": "e91688d"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-20T16:48:46Z",
          "updatedAt": "2019-06-20T16:48:47Z",
          "comments": [
            {
              "originalPosition": 227,
              "body": "The `map2curve` functions are generally invertible, but since we're using \"encoding\" to refer to the whole pipeline (`hash2base \u2218 map2curve \u2218 clear_cofactor`), isn't it the case that the \"encodings\" in this document are not invertible (since `hash2base` isn't)?",
              "createdAt": "2019-06-20T16:48:47Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUyODgwMjk2",
          "commit": {
            "abbreviatedOid": "35981e1"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-21T15:11:12Z",
          "updatedAt": "2019-06-21T15:11:12Z",
          "comments": [
            {
              "originalPosition": 227,
              "body": "Perhaps it's worth making that clarification somewhere: properties like injectivity/invertability of the encoding would apply to the inner `map2curve` definition, and are not of relevance for the outer `hash2curve` and `encode2curve` definitions. Probably good to be clear, since in the future other docs might want to reference the same `map2curve` definitions and think about those properties.",
              "createdAt": "2019-06-21T15:11:12Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUzMDc3NjYz",
          "commit": {
            "abbreviatedOid": "35981e1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-22T02:00:34Z",
          "updatedAt": "2019-06-22T02:00:34Z",
          "comments": [
            {
              "originalPosition": 227,
              "body": "Perhaps it would be useful to do this in the map2curve section. (See also my comment below.)\r\n\r\nThe reason I suggest leaving it until that section is that, at this point in the document, the three pieces of an encoding (hash2base, map2curve, clear_cofactor) have not yet been defined.",
              "createdAt": "2019-06-22T02:00:34Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUzMTM0NjE4",
          "commit": {
            "abbreviatedOid": "35981e1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-23T14:10:22Z",
          "updatedAt": "2019-06-23T14:10:23Z",
          "comments": [
            {
              "originalPosition": 227,
              "body": "I've created #128 to capture this issue; let's discuss further there.",
              "createdAt": "2019-06-23T14:10:22Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUzNTQ3Mzg3",
          "commit": {
            "abbreviatedOid": "35981e1"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-24T17:17:38Z",
          "updatedAt": "2019-06-24T17:17:38Z",
          "comments": [
            {
              "originalPosition": 227,
              "body": "heads up on the use of variables, `msg` and `x` do not match.",
              "createdAt": "2019-06-24T17:17:38Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUzNTYzNzc1",
          "commit": {
            "abbreviatedOid": "35981e1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-24T17:50:10Z",
          "updatedAt": "2019-06-24T17:50:10Z",
          "comments": [
            {
              "originalPosition": 227,
              "body": "Thanks! I'll hit this tonight, too :)",
              "createdAt": "2019-06-24T17:50:10Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUzNzY3NTE2",
          "commit": {
            "abbreviatedOid": "35981e1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good! I only have a couple small comments. Otherwise, it\u2019s good to go.",
          "createdAt": "2019-06-25T04:40:52Z",
          "updatedAt": "2019-06-25T04:48:13Z",
          "comments": [
            {
              "originalPosition": 222,
              "body": "As written, this is a bit confusing, since `2^L < n` is a case where `2^L != n`. Perhaps the former sentence should explicitly say that the encoding cannot be bijective on all points on the curve? ",
              "createdAt": "2019-06-25T04:40:52Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 230,
              "body": "This last sentence seems to imply that encodings have properties akin to cryptographic hash functions, which isn\u2019t true, right? I\u2019d trim everything after \u201cdoes not discuss inversion algorithms;\u201d",
              "createdAt": "2019-06-25T04:42:21Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 246,
              "body": "Nit: random-oracle or random oracle?",
              "createdAt": "2019-06-25T04:43:21Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUzNzc3NTc2",
          "commit": {
            "abbreviatedOid": "35981e1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-25T05:31:07Z",
          "updatedAt": "2019-06-25T05:31:07Z",
          "comments": [
            {
              "originalPosition": 246,
              "body": "The grammer-nerdiest answer is, both! If \"random oracle\" is a noun, no hyphen, if it's an adjective, hyphen (per Chicago manual of style).\r\n\r\nBut this can get annoying. If we decide we want to go with just one or the other, I'd vote no hyphen.",
              "createdAt": "2019-06-25T05:31:07Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0MDk1MzU0",
          "commit": {
            "abbreviatedOid": "7e2a332"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Latest changes look good!",
          "createdAt": "2019-06-25T15:39:20Z",
          "updatedAt": "2019-06-25T15:46:15Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "Perhaps clarify that this is because collisions are possible?",
              "createdAt": "2019-06-25T15:39:20Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 118,
              "body": "Should we be explicit about what invertible encodings, similar to what we do for mappings above? That is, something similar to:\r\n\r\n```\r\nAn encoding is said to be invertible if, for any point P output by the encoding, there is an efficient algorithm to recover a bit string s such that encoding s yields P. Since the hash function(s) H used by encodings in this document are not invertible, all specified encodings are also not invertible.\r\n```",
              "createdAt": "2019-06-25T15:40:11Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0Mjg3ODA2",
          "commit": {
            "abbreviatedOid": "9180fc1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-25T21:46:55Z",
          "updatedAt": "2019-06-25T21:46:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0MjY2MTUx",
          "commit": {
            "abbreviatedOid": "7e2a332"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I request minimal changes and made suggestions. It might be possible that some of them were already addressed in the latest commit. ",
          "createdAt": "2019-06-25T20:58:03Z",
          "updatedAt": "2019-06-25T22:18:30Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "> Sample code for each algorithm is presented in {{samplecode}}.\r\n\r\nThis reference is too early in this part. Some concepts (curves, encodings, RO, etc) must be understood first before jump in source code.",
              "createdAt": "2019-06-25T20:58:03Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 148,
              "body": "I suggest to reordering these two paragraphs to something like this:\r\n\r\n> This document aims to bridge this gap by providing a thorough set of recommended hashing algorithms for a range of curve types. Each algorithm conforms to a common interface: it takes as input an arbitrary-length bit string and produces as output a point on an elliptic curve.  Additionally, we describe the security rationale behind each recommendation, and give guidance for elliptic curves that are not explicitly covered.\r\n\r\nAfter that, it might be worth to have a sentence that points to Background, terminology and Roadmap sections.",
              "createdAt": "2019-06-25T21:02:13Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 168,
              "body": "\r\n```suggestion\r\nFor further reference about elliptic curves, consult {{CFADLNV05}} or {{W08}}.\r\n```",
              "createdAt": "2019-06-25T21:04:13Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 168,
              "body": "Regarding the following paragraph, \r\n\r\n> The curve E forms an algebraic group whose elements are the\r\npoints (x, y) satisfying the curve equation, where x and y are elements of F.\r\nThis group has order n, meaning that there are n distinct points.\r\n\r\nFirst suggestion is to change to `an additive group`. it is clear that `additive` and `algebraic` terms refer to different things, but including `additive` reminds the reader that points can be added.\r\n\r\nSecond suggestion is to change to \r\n```\r\n  whose elements are the points P=(x, y) with coordinates satisfying the curve equation. Each coordinate is an element of F.\r\n```\r\n",
              "createdAt": "2019-06-25T21:18:49Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 168,
              "body": "> An elliptic curve E is specified by a cubic equation in two variables and a finite field F. An elliptic curve equation takes one of several standard forms, including (but not limited to) Weierstrass, Montgomery, and Edwards.\r\n\r\nAlthough all elliptic curves can be put in Weierstrass form (which is a cubic equation), sometimes we use the non-cubic version of the curve (e.g. Edwards curve).",
              "createdAt": "2019-06-25T21:26:14Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 229,
              "body": "```suggestion\r\nIn general, a mapping may produce only a subset of the points on an elliptic curve\r\n```",
              "createdAt": "2019-06-25T21:31:48Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 232,
              "body": "```suggestion\r\nIn addition, a mapping may produce the same point for distinct inputs\r\n```",
              "createdAt": "2019-06-25T21:33:42Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 239,
              "body": "which word fits better? outputted, produced, or calculated ",
              "createdAt": "2019-06-25T21:36:28Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 242,
              "body": "In connection with this [comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/127/files#r297256934), and according to this new categorization between mappings and encodings. \r\nWe _do_ work with invertible mappings. But a proper sentence for the document should say that we _do not_work with invertible encodings (as pointed in the link).",
              "createdAt": "2019-06-25T21:44:11Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 725,
              "body": "This implementation is optimized for the case that q = 3 (mod 4), which applies to P-256\r\nThis implementation is optimized for the case that q = 3 (mod 4). ~~which applies to P-256~~",
              "createdAt": "2019-06-25T22:07:45Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            },
            {
              "originalPosition": 752,
              "body": "Here it is not clear which of the previous methods is referred by `this`.",
              "createdAt": "2019-06-25T22:11:07Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0MzA3MTUz",
          "commit": {
            "abbreviatedOid": "9180fc1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-25T22:43:05Z",
          "updatedAt": "2019-06-25T22:43:05Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "I'd prefer it be near the top rather than hidden at the end of the section.",
              "createdAt": "2019-06-25T22:43:05Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0MzA3NTA5",
          "commit": {
            "abbreviatedOid": "9180fc1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-25T22:44:16Z",
          "updatedAt": "2019-06-25T22:44:16Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "I vote for `output`.",
              "createdAt": "2019-06-25T22:44:16Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NDAzMzk0",
          "commit": {
            "abbreviatedOid": "9180fc1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-26T06:29:11Z",
          "updatedAt": "2019-06-26T06:29:12Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "For now I removed the forward ref.\r\n\r\nWe could bring it back, but it seems unnecessary to have the stereotypical \"this document is organized as follows...\" paragraph as long as the section titles are descriptive, since there's an autogenerated table of contents.",
              "createdAt": "2019-06-26T06:29:11Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NDAzODQz",
          "commit": {
            "abbreviatedOid": "9180fc1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-26T06:30:30Z",
          "updatedAt": "2019-06-26T06:30:30Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "Regarding the middle comment: I made some changes that are close but not exactly what you asked for. The changes I made are slightly more verbose (for clarity) but I think respond to the spirit of the suggestion.",
              "createdAt": "2019-06-26T06:30:30Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NDA0NTM3",
          "commit": {
            "abbreviatedOid": "9180fc1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-26T06:32:52Z",
          "updatedAt": "2019-06-26T06:32:52Z",
          "comments": [
            {
              "originalPosition": 229,
              "body": "I made a change along the lines of what you're suggesting, but not exactly the one above.\r\n\r\nThe reason is, it's important to be clear that we're talking about the image of the mapping, and not its output on a given execution. Said another way, the mapping produces one point when executed, so saying that it produces a subset without specifying \"over all possible inputs\" could confuse readers.",
              "createdAt": "2019-06-26T06:32:52Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NDA0NjM0",
          "commit": {
            "abbreviatedOid": "9180fc1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-26T06:33:06Z",
          "updatedAt": "2019-06-26T06:33:07Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "Ditto, \"output\" is my preference, too.",
              "createdAt": "2019-06-26T06:33:07Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NDA0ODI4",
          "commit": {
            "abbreviatedOid": "9180fc1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-26T06:33:43Z",
          "updatedAt": "2019-06-26T06:33:43Z",
          "comments": [
            {
              "originalPosition": 242,
              "body": "I've clarified this, I think. Does it look OK now?",
              "createdAt": "2019-06-26T06:33:43Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NDA1Mjgz",
          "commit": {
            "abbreviatedOid": "9180fc1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-26T06:35:00Z",
          "updatedAt": "2019-06-26T06:35:00Z",
          "comments": [
            {
              "originalPosition": 725,
              "body": "Can we leave this alone until we go back through and do curve-specific reference code, then update all of these examples? The reason is that there are similar examples given in other mappings, so it would be better to make this change systematically.",
              "createdAt": "2019-06-26T06:35:00Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NDA4MzE4",
          "commit": {
            "abbreviatedOid": "3b5f939"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-26T06:44:10Z",
          "updatedAt": "2019-06-26T06:44:11Z",
          "comments": [
            {
              "originalPosition": 725,
              "body": "Added a note in #111 so that we don't lose this.",
              "createdAt": "2019-06-26T06:44:11Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NDE2MDk3",
          "commit": {
            "abbreviatedOid": "3b5f939"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-26T07:05:39Z",
          "updatedAt": "2019-06-26T07:05:39Z",
          "comments": [
            {
              "originalPosition": 229,
              "body": "Now it is clearer.",
              "createdAt": "2019-06-26T07:05:39Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NDE3MjM2",
          "commit": {
            "abbreviatedOid": "3b5f939"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-26T07:08:30Z",
          "updatedAt": "2019-06-26T07:08:30Z",
          "comments": [
            {
              "originalPosition": 242,
              "body": "it is 0K.",
              "createdAt": "2019-06-26T07:08:30Z",
              "updatedAt": "2019-06-26T17:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NDE4MTg1",
          "commit": {
            "abbreviatedOid": "3b5f939"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-26T07:10:51Z",
          "updatedAt": "2019-06-26T07:10:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 130,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkxNzYzMzQ4",
      "title": "Replace foo2bar with foo_to_bar, and add Riad as an author.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/130",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-06-25T23:08:25Z",
      "updatedAt": "2019-06-26T12:55:18Z",
      "closedAt": "2019-06-26T12:55:18Z",
      "mergedAt": "2019-06-26T12:55:18Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks like you got all the x2y occurrences I can find, other than inside some of the links/anchors. But those are still consistent (`#hash2base-{impl,perf,repo,sec}`).",
          "createdAt": "2019-06-26T01:20:04Z",
          "updatedAt": "2019-06-26T01:20:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0MzQzNjMw",
          "commit": {
            "abbreviatedOid": "72da9f5"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me. Made suggestions for the links if it you think it's worthwhile.",
          "createdAt": "2019-06-26T01:28:12Z",
          "updatedAt": "2019-06-26T01:37:54Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "```suggestion\r\n## Security considerations {#hashtobase-sec}\r\n```",
              "createdAt": "2019-06-26T01:28:12Z",
              "updatedAt": "2019-06-26T01:43:12Z"
            },
            {
              "originalPosition": 107,
              "body": "```suggestion\r\n{{hashtobase-impl}} details the hash\\_to\\_base procedure.\r\n```",
              "createdAt": "2019-06-26T01:28:28Z",
              "updatedAt": "2019-06-26T01:43:12Z"
            },
            {
              "originalPosition": 113,
              "body": "```suggestion\r\n## Performance considerations {#hashtobase-perf}\r\n```",
              "createdAt": "2019-06-26T01:28:44Z",
              "updatedAt": "2019-06-26T01:43:12Z"
            },
            {
              "originalPosition": 116,
              "body": "```suggestion\r\nSince hash\\_to\\_base may invoke H multiple times ({{hashtobase-sec}}), its\r\n```",
              "createdAt": "2019-06-26T01:28:56Z",
              "updatedAt": "2019-06-26T01:43:12Z"
            },
            {
              "originalPosition": 137,
              "body": "```suggestion\r\n## Implementation {#hashtobase-impl}\r\n```",
              "createdAt": "2019-06-26T01:29:09Z",
              "updatedAt": "2019-06-26T01:43:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NDA2NzI0",
          "commit": {
            "abbreviatedOid": "d52c95a"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Changes look good to me. Thanks!",
          "createdAt": "2019-06-26T06:39:21Z",
          "updatedAt": "2019-06-26T06:39:21Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NDEzMTg5",
          "commit": {
            "abbreviatedOid": "d52c95a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2019-06-26T06:57:53Z",
          "updatedAt": "2019-06-26T06:57:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 131,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkyMDgzMzQ1",
      "title": "section 6, missed a few instances of 'encoding'",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/131",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Oops. This is minor, just missed a few words. Sorry @chris-wood, spoke too soon when I said \"good to go.\"",
      "createdAt": "2019-06-26T17:13:32Z",
      "updatedAt": "2019-06-26T17:14:29Z",
      "closedAt": "2019-06-26T17:14:29Z",
      "mergedAt": "2019-06-26T17:14:29Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NzU3Mzg2",
          "commit": {
            "abbreviatedOid": "190c875"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-26T17:14:24Z",
          "updatedAt": "2019-06-26T17:14:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 132,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkyMTkyNTI3",
      "title": "update description of Edwards map",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/132",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This commit separates the description of the birational map from Montgomery to Edwards from the description of the Edwards mapping.\r\n\r\nIt also clarifies that the correct birational map to use for existing standardized curves is the one from the standard, which addresses a stashed TODO from #107.\r\n\r\nThis addresses one of the outstanding issues w.r.t. VRF inclusion.",
      "createdAt": "2019-06-26T23:16:06Z",
      "updatedAt": "2019-07-02T20:13:15Z",
      "closedAt": "2019-07-02T16:01:35Z",
      "mergedAt": "2019-07-02T16:01:35Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "~~Let's hold this up a tiny bit longer: I'm going to push a commit that makes @armfazh's suggested clarification from #134.~~\r\n\r\nOK, made the clarification.",
          "createdAt": "2019-06-29T02:13:04Z",
          "updatedAt": "2019-06-29T03:14:03Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0OTU5NTE0",
          "commit": {
            "abbreviatedOid": "96e0542"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Nice refactor and cleanups! This LGTM. ",
          "createdAt": "2019-06-27T01:32:35Z",
          "updatedAt": "2019-06-27T01:41:56Z",
          "comments": [
            {
              "originalPosition": 200,
              "body": "naming: can we spell out elligator2, i.e., `map_to_curve_elligator2_edwards`?",
              "createdAt": "2019-06-27T01:32:35Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            },
            {
              "originalPosition": 90,
              "body": "Should we note that `sqrt` in those implementations MUST be chosen from the set we recommend in this document? (That is, must be constant time.)",
              "createdAt": "2019-06-27T01:34:58Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            },
            {
              "originalPosition": 90,
              "body": "Should we also specify that new Edwards curves SHOULD/MUST specify a corresponding Montgomery form and birational map?",
              "createdAt": "2019-06-27T01:36:05Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            },
            {
              "originalPosition": 89,
              "body": "Should we cite the sections, too? (4.1 and 4.2)",
              "createdAt": "2019-06-27T01:38:10Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            },
            {
              "originalPosition": 96,
              "body": "nit: this only derives one of the maps, right? (it seems left as an exercise for the reader to describe the reverse mapping)",
              "createdAt": "2019-06-27T01:40:46Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0OTcyNzcy",
          "commit": {
            "abbreviatedOid": "96e0542"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T02:32:04Z",
          "updatedAt": "2019-06-27T02:32:05Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "This is a great catch.\r\n\r\nSince those square roots are constants, I would guess that most people will just hard code a constant in their implementation.\r\n\r\nBut: the sign of the square root isn't specified, so the sign of the resulting point is ambiguous!\r\n\r\nTo me, the best way to fix this is to do what we've done everywhere else: specify that the sign of the Edwards point should be equal to the sign of the input `u`, since this is both unambiguous and insensitive to whether future standards manage to find other ways to ambiguously specify rational maps.",
              "createdAt": "2019-06-27T02:32:04Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0OTcyOTEz",
          "commit": {
            "abbreviatedOid": "96e0542"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T02:32:53Z",
          "updatedAt": "2019-06-27T02:32:53Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "Not a bad idea, though I wonder if people might complain that trying to require this would be mission creep for this standard... thoughts?\r\n\r\n(But I suppose that's what SHOULD is for!)",
              "createdAt": "2019-06-27T02:32:53Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0OTczNDM2",
          "commit": {
            "abbreviatedOid": "96e0542"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T02:35:53Z",
          "updatedAt": "2019-06-27T02:35:53Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "Since we don't need the inverse map for this hash, I wasn't going to bother with it.\r\n\r\nBut it's pretty short to specify the inverse, and could make life easier in the future. I'll add it.",
              "createdAt": "2019-06-27T02:35:53Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0OTc1MTcx",
          "commit": {
            "abbreviatedOid": "96e0542"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T02:45:21Z",
          "updatedAt": "2019-06-27T02:45:21Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "Yeah, I'm leaning towards SHOULD. :-)",
              "createdAt": "2019-06-27T02:45:21Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0OTc1MTg5",
          "commit": {
            "abbreviatedOid": "96e0542"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T02:45:27Z",
          "updatedAt": "2019-06-27T02:45:27Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "That sounds good!",
              "createdAt": "2019-06-27T02:45:27Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0OTc1MjM3",
          "commit": {
            "abbreviatedOid": "96e0542"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T02:45:46Z",
          "updatedAt": "2019-06-27T02:45:46Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "I'm OK with either, so this works for me.",
              "createdAt": "2019-06-27T02:45:46Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1MDIxMTI5",
          "commit": {
            "abbreviatedOid": "6546717"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T06:07:48Z",
          "updatedAt": "2019-06-27T06:07:48Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "Argh, as I'm thinking about this more, I'm not super happy with this solution. But I'm not sure whether there's any other solution that's better.\r\n\r\nThe reason I'm not super happy is, if we don't tell folks how to resolve the ambiguity in RFC7748, then it may still break things in annoying ways. Specifically, I'm worried about a case where someone wants to interoperate between curve25519 and edwards25519, and wants to be able to hash to both of them.\r\n\r\nAs currently written, there's no guarantee that a conforming hash-to-Montgomery and a conforming hash-to-Edwards will give the same result, because the maps could disagree on sign. It gets worse in the case of the random oracle construction: since the maps may disagree on sign sometimes and agree on sign other times, there are 4 possible outputs:\r\n\r\n- P + Q\r\n- P - Q\r\n- -P + Q\r\n- -P - Q\r\n\r\nwhere P and Q are the first and second map evaluations, respectively.\r\n\r\nThis is bad! I think we want the curve25519 and edwards25519 hash functions to give exactly the same result, and I think for that purpose the only thing we can do is specify the sign of the birational map.\r\n\r\nI'm going to push a revert for the sign commit and push another commit with this solution. This will let us easily change from one to the other once we've decided.\r\n\r\nI think I favor resolving the ambiguity by telling implementors to use the positive branch for sqrt(-486664) rather than by fixing the sign of the x-coordinate after evaluating the map, for the reasons above. But I'll think about it some more.",
              "createdAt": "2019-06-27T06:07:48Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1Mzg4NTcz",
          "commit": {
            "abbreviatedOid": "f29f284"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T17:58:48Z",
          "updatedAt": "2019-06-27T17:58:49Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "To be sure I understand, the invariant you're after is:\r\n\r\n```\r\nphi(HM(x)) == HE(x)\r\n```\r\n\r\nwhere `HM`, `HE`, and `phi` are the hash-to-Montgomery, hash-to-Edwards, and Montgomery-to-Edwards functions, respectively. By asserting that each map uses positive constants, the goal is that `phi` would not change the point sign. Is that right? (I need to think through this more.)",
              "createdAt": "2019-06-27T17:58:48Z",
              "updatedAt": "2019-07-01T20:31:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1MzkyMDcy",
          "commit": {
            "abbreviatedOid": "f29f284"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Other than the thread on the sign, this looks good to me",
          "createdAt": "2019-06-27T18:05:24Z",
          "updatedAt": "2019-06-27T18:22:34Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\nThe coordinates (x, y) specify a point on an elliptic curve defined over F.\r\n```",
              "createdAt": "2019-06-27T18:05:25Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NDE3MzUw",
          "commit": {
            "abbreviatedOid": "59b343c"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T18:53:54Z",
          "updatedAt": "2019-06-27T18:53:55Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "The goal of fixing the sign of the constants is just to make sure that everyone uses exactly the same definition of phi(), so that different implementations will interoperate. In the case of edwards25519, we'll have test vectors in the standard, so everything should be fine. The remaining concern is that future standardization efforts for Edwards curves will have the same ambiguity. Resolving all ambiguously-signed constants in one direction should suffice to prevent this.\r\n\r\nBut yeah, as long as everyone uses the same phi and phi-inverse, then Montgomery and Edwards implementations can totally interoperate. For example, you could imagine someone writing (say) a PAKE library based on Curve25519 that does all curve operations in Edwards coordinates to take advantage of the constant-time, exception-free addition formulas. It would be great if that implementation could interoperate with another one that uses the Montgomery ladder for better performance. Making sure that the Edwards and Montgomery hashes always give equivalent results helps with this kind of compatibility, because it means that the Edwards PAKE library could use any conforming hash-to-Edwards implementation.\r\n\r\nBy the way, positive constants don't guarantee that the sign is unchanged, because \"sign\" acts a little weird here: the product of two positive numbers can be negative, for example. (As a simple example, consider the integers mod 13. By our definition, both 2 and 6 are positive, but their product is negative.) But it's enough that phi() and phi-inverse() are actually inverses (which they are as long as they use the same sign for the constants), and that everyone's definition of phi() is exactly the same, including sign.",
              "createdAt": "2019-06-27T18:53:54Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NDI4ODAw",
          "commit": {
            "abbreviatedOid": "59b343c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T19:17:41Z",
          "updatedAt": "2019-06-27T19:17:41Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "I was playing fast and loose with my words -- ensuring that everyone's phi implementation is the same is what I was after. I agree with the conclusion that fixing the sign ensures compatibility now and in the future.",
              "createdAt": "2019-06-27T19:17:41Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NDM1ODky",
          "commit": {
            "abbreviatedOid": "59b343c"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T19:32:48Z",
          "updatedAt": "2019-06-27T19:32:48Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": ":+1: sorry to be pedantic, just wanted to be sure we were on the same page. :)",
              "createdAt": "2019-06-27T19:32:48Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NDYxMzIz",
          "commit": {
            "abbreviatedOid": "59b343c"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T20:26:29Z",
          "updatedAt": "2019-06-27T20:26:29Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "Why it was removed 'twisted'?\r\nTwisted Edwards are more generic than Edwards curves. ",
              "createdAt": "2019-06-27T20:26:29Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NDYyOTAz",
          "commit": {
            "abbreviatedOid": "59b343c"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T20:29:36Z",
          "updatedAt": "2019-06-27T20:29:37Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "here is an inaccuracy.\r\nthe `bi` prefix on birationality refers to the fact that there are two maps one from X -> Y and another from Y -> X .\r\nand the 'bi' prefix is not related to the dimension of the varieties (the number of coordinates to represent a point).",
              "createdAt": "2019-06-27T20:29:36Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NDgyMDg3",
          "commit": {
            "abbreviatedOid": "59b343c"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T21:09:43Z",
          "updatedAt": "2019-06-27T21:09:44Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "You're absolutely right, I was sloppy. Thanks for catching!",
              "createdAt": "2019-06-27T21:09:44Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NDg3MjE3",
          "commit": {
            "abbreviatedOid": "59b343c"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T21:21:39Z",
          "updatedAt": "2019-06-27T21:21:39Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "You're right, the wording is confusing here. I'll fix.\r\n\r\nJust to make sure we're on the same page: X -> Y is a birational map just if it's a rational map *and* if the inverse map Y -> X also exists and is rational. In other words, it is correct to call the map M -> E birational.\r\n\r\nSo the objection here is that the wording seems to imply that \"bi\" and dimensionality are related, which of course as you say is not true.",
              "createdAt": "2019-06-27T21:21:39Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NDkwNzQz",
          "commit": {
            "abbreviatedOid": "59b343c"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T21:29:56Z",
          "updatedAt": "2019-06-27T21:29:56Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "> Just to make sure we're on the same page: X -> Y is a birational map just if it's a rational map and if the inverse map Y -> X also exists and is rational. In other words, it is correct to call the map M -> E birational.\r\n\r\n^ This is true.\r\n\r\nYes, the objection is in this part: \r\n\r\n> by evaluating **a pair** of rational functions called a birational map\r\n\r\nIn fact, we only evaluate **one** rational map, the one that goes from M -> E.\r\n\r\n\r\n",
              "createdAt": "2019-06-27T21:29:56Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NDkzMTc1",
          "commit": {
            "abbreviatedOid": "f8f81f0"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T21:36:13Z",
          "updatedAt": "2019-06-27T21:36:13Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "To address this, I added a parenthetical clarifying that we say \"Edwards\" to mean both twisted (a != 1) and untwisted (a = 1).\r\n\r\nThis isn't a perfect solution, because Bernstein et al. (in the paper that introduced Twisted Edwards Curves, BBJLP08) use \"Edwards curve\" to mean \"a = 1\" (i.e., untwisted), and \"twisted Edwards curve\" to refer to the more general case that a may not be equal to 1.\r\n\r\nThe alternative, which is strictly correct but probably much more annoying to read, is to use the term \"twisted Edwards curve\" everywhere in the document. To me, this likely *reduces* clarity. (One reason for this is that, in general, adjectives like \"twisted\" intuitively appear to *restrict* rather than to *generalize* the word that they modify. While this isn't a hard-and-fast rule, most readers will assume this is true without even realizing they're doing it.)\r\n\r\nI'd rather annoy the small handful of people who both understand and care about the above distinction than confuse the much larger number of people who don't, but I understand the argument either way.",
              "createdAt": "2019-06-27T21:36:13Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NDk2MzIw",
          "commit": {
            "abbreviatedOid": "f8f81f0"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T21:44:27Z",
          "updatedAt": "2019-06-27T21:44:28Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "I prefer to name curves by their canonical name. As you can see in RFC7748 and RFC8032, the full name `twisted Edwards curves` is used without confusion.\r\n\r\nWhen referring to a twisted Edwards curve, they are also included the Edwards curves (a=1). So, no distinction must be done, since the birational map applies generally.\r\n\r\n",
              "createdAt": "2019-06-27T21:44:28Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NDk5Mzk1",
          "commit": {
            "abbreviatedOid": "62faefb"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T21:52:54Z",
          "updatedAt": "2019-06-27T21:52:55Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "OK, I just pushed a commit that writes \"twisted Edwards\" everywhere.\r\n\r\nI suggest that each of us compares the clarity with and without this commit. If it's clearer to slightly abuse terminology, is that extra clarity worth the abuse? Alternatively, maybe my thoughts on clarity above are a bit alarmist, and we should just use the correct terminology.\r\n\r\nI'm happy to go with whichever one people like.",
              "createdAt": "2019-06-27T21:52:54Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTIzNTcz",
          "commit": {
            "abbreviatedOid": "62faefb"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T23:14:03Z",
          "updatedAt": "2019-06-27T23:14:03Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "This paragraph can be omitted or be in another place. Montgomery's trick is a well-known technique. The pseudo-code below already contain the trick.",
              "createdAt": "2019-06-27T23:14:03Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTI0NTIy",
          "commit": {
            "abbreviatedOid": "62faefb"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T23:17:59Z",
          "updatedAt": "2019-06-27T23:18:00Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "Consider to refactor as follows:\r\n```\r\nmap_to_curve_elligator2_edwards(u)\r\nInput: u, an element of F.\r\nOutput: (x, y), a point on E.\r\n\r\n1. (x1, y1) = map_to_curve_elligator2(u)    // (x1, y1) is on M\r\n2. t1 = y1 * B'\r\n3. t2 = x1 + 1\r\n4. t3 = t1 * t2\r\n5. t3 = inv0(t3)\r\n6.  x = t2 * t3\r\n7.  x = x * x1\r\n8.  y = x1 - 1\r\n9.  y = y * t3\r\n10.  y = y * t1\r\n11. e = y == 0\r\n12. y = CMOV(y, 1, e)\r\n13. return (x, y)\r\n```",
              "createdAt": "2019-06-27T23:17:59Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTI2MDM1",
          "commit": {
            "abbreviatedOid": "62faefb"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T23:24:41Z",
          "updatedAt": "2019-06-27T23:24:42Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "```\r\nphi(HM(x)) == HE(x)\r\n```\r\nI am not sure whether we can get this equation working at the hashing-to-curve level. The main reason is that both hashing methods are prefixed with different strings, which includes the name of curve in the prefix.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
              "createdAt": "2019-06-27T23:24:41Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTI4MDM4",
          "commit": {
            "abbreviatedOid": "62faefb"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T23:33:28Z",
          "updatedAt": "2019-06-27T23:33:28Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "> Making sure that the Edwards and Montgomery hashes always give equivalent results helps with this kind of compatibility, because it means that the Edwards PAKE library could use any conforming hash-to-Edwards implementation.\r\n\r\nIt is not clear to me, why to recommend two different hashes HE(x) and HM(x) that map to the \"same\" equivalent point (under certain birational mapping).\r\n\r\nWhat we need is 1 hash that covers any Montgomery curve and 1 hash that covers any Twisted Edwards curve.\r\n\r\nThe relation between curve25519 and edwards25519 is different to \r\nthe relation between curve448 and edwards448. These are special cases.\r\n\r\nI do not understand why the hash to curve method must carry with these relations. \r\n\r\n\r\n",
              "createdAt": "2019-06-27T23:33:28Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTMwMTMy",
          "commit": {
            "abbreviatedOid": "62faefb"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T23:42:46Z",
          "updatedAt": "2019-06-27T23:42:46Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "I think I don't get it. The point of this PR is to break apart the definition of `birational_map` from the definition of `map_to_curve_elligator2_edwards`, and the above suggestion puts them back together. This is a problem because `birational_map` for existing curves is *not* the above map---see the map for Curve25519 from RFC7748, for example.",
              "createdAt": "2019-06-27T23:42:46Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTMwODgy",
          "commit": {
            "abbreviatedOid": "a8747c1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T23:45:56Z",
          "updatedAt": "2019-06-27T23:45:57Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "Makes sense.",
              "createdAt": "2019-06-27T23:45:57Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTMxNDY5",
          "commit": {
            "abbreviatedOid": "a8747c1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T23:48:28Z",
          "updatedAt": "2019-06-27T23:48:28Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "Or is the suggestion changing x' -> x1, and y' -> y1?",
              "createdAt": "2019-06-27T23:48:28Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTMyNjAx",
          "commit": {
            "abbreviatedOid": "a8747c1"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T23:53:42Z",
          "updatedAt": "2019-06-27T23:53:43Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "I want to understand all of this.\r\n\r\nFollowing the description of the document. It says that curve25519 and curve448 have special birational mappings and an implementor must follow them. Then, the document says that for all other cases, it should follow the `bitarional_map` you gave. \r\n\r\nSo let me rephrase in pseudo-code:\r\n```\r\nmap_to_curve_elligator2_edwards(u)\r\n(x1,y1) = elligator2(u)\r\n if curve == {edwards25519, edwards448}\r\n    use map \\phi from RFC7748\r\nelse\r\n   use map \\phi explicitly given as .....\r\nreturn (x,y) = \\phi(x1,y1)\r\n```\r\nIs this the recommendation given?",
              "createdAt": "2019-06-27T23:53:42Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTM0ODcx",
          "commit": {
            "abbreviatedOid": "a8747c1"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-28T00:04:07Z",
          "updatedAt": "2019-06-28T00:04:07Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "Question: how did you get B and B'? _or equivalently _ how do you convert between \r\n```\r\ny^2 = x^3 + A * x^2 + C * x\r\n```\r\nand\r\n```\r\nB y^2 = x^3 + A * x^2 +  x\r\n```\r\n?",
              "createdAt": "2019-06-28T00:04:07Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTM1OTg2",
          "commit": {
            "abbreviatedOid": "a8747c1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-28T00:10:01Z",
          "updatedAt": "2019-06-28T00:10:01Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "> I am not sure whether we can get this equation working at the hashing-to-curve level. The main reason is that both hashing methods are prefixed with different strings, which includes the name of curve in the prefix.\r\n\r\nThis is true *only* if hash-to-curve includes a ciphersuite tag. Right now it seems like most of the opinions expressed in #124 are against having a ciphersuite tag at the hash-to-curve level, so it's at least reasonable to believe that this could be made to work. But it's a good point that it's not clear that we're \"doing enough\" here.\r\n\r\n> It is not clear to me, why to recommend two different hashes HE(x) and HM(x) that map to the \"same\" equivalent point (under certain birational mapping).\r\n\r\nThe reason is that *in practice* people care about being able to use the Montgomery and Edwards forms of a curve interchangeably, so we should try to make sure that this standard accommodates this use-case.\r\n\r\nFor example, this issue came up as described in a comment in #107: initially the document suggested using a different birational map than the one in RFC7748, and we got pushback against this. So this is not just a hypothetical concern.",
              "createdAt": "2019-06-28T00:10:01Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTM4MTk4",
          "commit": {
            "abbreviatedOid": "a8747c1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-28T00:21:37Z",
          "updatedAt": "2019-06-28T00:21:37Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "See c56449fc41f0e0fdebfa3bd4e8e7e83cb6027a80",
              "createdAt": "2019-06-28T00:21:37Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTM4NTE3",
          "commit": {
            "abbreviatedOid": "a8747c1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-28T00:23:16Z",
          "updatedAt": "2019-06-28T00:23:16Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "Not quite. The document says that *any* curve that already has a birational map specified in a standard should use that map. The examples we give are '25519 and '448, but it seems extremely likely that any Montgomery curve that gets standardized will end up standardizing an Edwards curve, too: if a curve is good enough for key exchange, it's good enough for EdDSA.\r\n\r\nSo the point is, if there's already a standardized birational map, use that one so that you get \"free\" compatibility between the Edwards and the Montgomery hashing. (As you pointed out above, this might break if we add a ciphersuite string---to me, this is all the more reason not to add one.)",
              "createdAt": "2019-06-28T00:23:16Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTQ0Nzg2",
          "commit": {
            "abbreviatedOid": "6820aea"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-28T00:59:26Z",
          "updatedAt": "2019-06-28T00:59:26Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "OK, maybe I had too much caffeine earlier. Happy to stick with \"twisted\" everywhere :)",
              "createdAt": "2019-06-28T00:59:26Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTQ1MTc0",
          "commit": {
            "abbreviatedOid": "6820aea"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-28T01:01:55Z",
          "updatedAt": "2019-06-28T01:01:55Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "Also note: I implemented the described birational map for edwards448 in the `poc` directory. The map correctly transports points between edwards448 and an equivalent Montgomery curve (though not the one specified in RFC7748; that's a TODO for code update)",
              "createdAt": "2019-06-28T01:01:55Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTg0MTg5",
          "commit": {
            "abbreviatedOid": "6820aea"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-28T04:56:17Z",
          "updatedAt": "2019-06-28T04:56:18Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "FWIW, I was assuming we removed the ciphersuite string from this document, as @kwantam states above.",
              "createdAt": "2019-06-28T04:56:17Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2MDE5Njg1",
          "commit": {
            "abbreviatedOid": "6820aea"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-29T02:11:59Z",
          "updatedAt": "2019-06-29T02:11:59Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "I think the conversation in #134 covers this now, right @armfazh?",
              "createdAt": "2019-06-29T02:11:59Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2MDM4OTQ1",
          "commit": {
            "abbreviatedOid": "12194f7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2019-06-29T14:24:43Z",
          "updatedAt": "2019-06-29T14:24:49Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "\ud83d\udc4d thanks for adding the citation!",
              "createdAt": "2019-06-29T14:24:43Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2NDg4MjQ3",
          "commit": {
            "abbreviatedOid": "d09fde5"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "It looks good, only few comments, but ready to move forward.",
          "createdAt": "2019-07-01T18:11:56Z",
          "updatedAt": "2019-07-01T18:39:07Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "When both `B` and `B'` are equal to 1, to avoid the case when `B' = -1`.",
              "createdAt": "2019-07-01T18:11:56Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            },
            {
              "originalPosition": 71,
              "body": "I am not sure where this restriction comes from \r\n```\r\nA^2 - 4 * B is non-square in F\r\n```\r\n",
              "createdAt": "2019-07-01T18:19:28Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            },
            {
              "originalPosition": 121,
              "body": "```suggestion\r\n(a class of curves that includes Edwards curves)\r\n```",
              "createdAt": "2019-07-01T18:26:49Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            },
            {
              "originalPosition": 231,
              "body": "the input of `rational_map` function is always a point in Weierstrass form, so M cannot be in Montgomery form.",
              "createdAt": "2019-07-01T18:36:43Z",
              "updatedAt": "2019-07-01T20:31:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2NTQ1Mzk5",
          "commit": {
            "abbreviatedOid": "d09fde5"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-01T20:27:05Z",
          "updatedAt": "2019-07-01T20:27:05Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "It comes from Section 5.2 of the Elligator paper. This stipulation is necessary to ensure\r\n\r\n    v^3 + A * v^2 + B * v != 0\r\n\r\nwhich handles one exceptional case.\r\n\r\nNote that unlike Section 5.2 of Elligator, we do *not* stipulate that q = 1 mod 4, which means that it is possible for\r\n\r\n    1 + u * r^2 == 0\r\n\r\nThis is the remaining exceptional case for the mapping, and it is handled explicitly.",
              "createdAt": "2019-07-01T20:27:05Z",
              "updatedAt": "2019-07-01T20:37:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2NTQ3MzA4",
          "commit": {
            "abbreviatedOid": "5ad2439"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-01T20:31:45Z",
          "updatedAt": "2019-07-01T20:31:45Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Yes, I realized its purpose during the last part of my review, but I didn't remove this comment.",
              "createdAt": "2019-07-01T20:31:45Z",
              "updatedAt": "2019-07-01T20:31:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2NTQ5MzEx",
          "commit": {
            "abbreviatedOid": "5ad2439"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-01T20:36:28Z",
          "updatedAt": "2019-07-01T20:36:29Z",
          "comments": [
            {
              "originalPosition": 231,
              "body": "This isn't quite true: when using a standardized rational map (as in curve25519 or curve448), the rational map is from Montgomery to Edwards, not from Weierstrass to Edwards.\r\n\r\nBut: I've simplified the sentence in a way that (I think) addresses your concern.",
              "createdAt": "2019-07-01T20:36:28Z",
              "updatedAt": "2019-07-01T20:36:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 136,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzODk5MjIy",
      "title": "spacing around = and ==",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/136",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is minor. Just fixes some spacing issues in response to #105.",
      "createdAt": "2019-07-02T20:14:14Z",
      "updatedAt": "2019-07-02T21:08:53Z",
      "closedAt": "2019-07-02T20:20:44Z",
      "mergedAt": "2019-07-02T20:20:44Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MTI3Njgz",
          "commit": {
            "abbreviatedOid": "66e1bbd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-02T20:20:38Z",
          "updatedAt": "2019-07-02T20:20:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 138,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzOTU5OTI4",
      "title": "ciphersuite table update",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/138",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This commit is intended to address #95, #96, and #126.\r\n\r\n~~I'm pushing an early cut as @armfazh suggested in #129. I'll get the rest of the info into the document in the next couple hours, then we can talk about the formatting.~~",
      "createdAt": "2019-07-03T00:22:47Z",
      "updatedAt": "2019-08-14T01:36:35Z",
      "closedAt": "2019-07-08T18:47:39Z",
      "mergedAt": "2019-07-08T18:47:39Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I've added the curves from my list in #126.\r\n\r\nThe last commit in this PR *removes* \"SIKEp503\" and \"SS132\" from the suites, though I'm not certain that we *must* do this. Why?\r\n\r\n- As far as I can tell (@armfazh, please correct me if I'm wrong, I know you've got lots of experience with SIDH/SIKE), the curve labeled SIKEp503 does not appear to be the curve in the SIKE proposal using the p503 parameters. Is this curve used somewhere else?\r\n   \r\n   The impl in poc/ell2supers.sage hashes to the curve y^2 = x^3 + 1 over F(2^250 * 3^159 - 1), but in general the SIKE curves appear to be over GF(p^2), not over GF(p).\r\n   \r\n   It also doesn't appear to be a curve specified for use with CSIDH (which *does* work over GF(p)). Maybe we can instead use the example y^2 = x^3 + x over the field defined by CSIDH/p511 (4 * 587 * k - 1), where k is the product of the first 73 odd primes, instead?\r\n\r\n- SS132 is pretty dismal security-wise, to the point where no one would ever use it... Maybe we can hash to y^2 = x^3 + 1 over the same p511 as above? This is also a supersingular curve that would work with the Boneh-Franklin method.\r\n\r\nOr: for now we can just leave both of the above out of the ciphersuites and concentrate on the others?",
          "createdAt": "2019-07-03T02:59:33Z",
          "updatedAt": "2019-07-03T03:31:49Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Another thought with regard to the supersingular curves: maybe we can give optimized example code in the appendices for the two curves over CSIDH-p511 that I gave above, but not put them in the ciphersuites list. I realize that seems a bit strange, but I think it would be really nice to have at least one worked example for each mapping...",
          "createdAt": "2019-07-03T18:36:46Z",
          "updatedAt": "2019-07-03T18:36:46Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> Or: for now we can just leave both of the above out of the ciphersuites and concentrate on the others?\r\nWe can stay with standardized curves for now. \r\n\r\n> Another thought with regard to the supersingular curves: maybe we can give optimized example code in the appendices for the two curves over CSIDH-p511 that I gave above, but not put them in the ciphersuites list. I realize that seems a bit strange, but I think it would be really nice to have at least one worked example for each mapping...\r\n\r\nI also agree that every mapping should have at least one curve example. Let's find well-known curves before creating artificial ones. \r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2019-07-03T18:41:28Z",
          "updatedAt": "2019-07-03T18:41:28Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> It would be also great to have a list of suite string identifiers.\r\n\r\nIs the idea to put these in Section 8, maybe below the table that maps curve -> section?",
          "createdAt": "2019-07-03T22:05:46Z",
          "updatedAt": "2019-07-03T22:05:46Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh do the latest changes more or less address your concerns?\r\n\r\nI'd love if we could land this tomorrow so that we have time for some sanity-check passes before Monday (the deadline)!",
          "createdAt": "2019-07-07T05:37:01Z",
          "updatedAt": "2019-07-07T05:37:26Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NDgwMDA5",
          "commit": {
            "abbreviatedOid": "dd3aefc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is a great refactor! I quite like the new format. The suite parameters look good to me (I didn't check the NIST or pairing-friendly curve constants -- only curve25519 and curve448), and parsing them seems straightforward. ",
          "createdAt": "2019-07-03T13:19:20Z",
          "updatedAt": "2019-07-03T13:23:42Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "Should we also explicitly note that \"-NU\" suites are for encodings?",
              "createdAt": "2019-07-03T13:19:20Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            },
            {
              "originalPosition": 239,
              "body": "Question: should we port these definitions to an appendix in this document to make things self contained (in IETF documents)? ",
              "createdAt": "2019-07-03T13:20:36Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            },
            {
              "originalPosition": 95,
              "body": "Should we leave a note that newly standardized curves SHOULD provide similar suites?",
              "createdAt": "2019-07-03T13:22:01Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NjY4NzE2",
          "commit": {
            "abbreviatedOid": "dd3aefc"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T18:32:52Z",
          "updatedAt": "2019-07-03T18:32:53Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "Yes, this is a great idea. I'll add them.",
              "createdAt": "2019-07-03T18:32:52Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzE1ODk3",
          "commit": {
            "abbreviatedOid": "e7b4fb9"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T20:19:56Z",
          "updatedAt": "2019-07-03T20:19:56Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "Done!",
              "createdAt": "2019-07-03T20:19:56Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzIxNjI4",
          "commit": {
            "abbreviatedOid": "a588965"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "It would be also great to have a list of suite string identifiers.\r\n\r\n",
          "createdAt": "2019-07-03T20:33:30Z",
          "updatedAt": "2019-07-03T20:53:18Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "```suggestion\r\n- A: 486662\r\n- B: 1\r\n```",
              "createdAt": "2019-07-03T20:33:30Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            },
            {
              "originalPosition": 173,
              "body": "```suggestion\r\n - a = -1\r\n - d = 0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3\r\n```",
              "createdAt": "2019-07-03T20:33:59Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            },
            {
              "originalPosition": 195,
              "body": "```suggestion\r\n- A = 156326\r\n- B = 1\r\n- f: Elligator 2 method, {{elligator2}}\r\n```",
              "createdAt": "2019-07-03T20:35:32Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            },
            {
              "originalPosition": 234,
              "body": "```suggestion\r\nThe suites BLS12381G1-SHA256-SSWU-RO and BLS12381G1-SHA256-SSWU-NU\r\n```",
              "createdAt": "2019-07-03T20:38:06Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            },
            {
              "originalPosition": 234,
              "body": "This is the same pattern used previously in P-256 curve. The (-) symbol was removed.",
              "createdAt": "2019-07-03T20:39:16Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            },
            {
              "originalPosition": 240,
              "body": "the curve equation of `E'` must be stated explicitly.",
              "createdAt": "2019-07-03T20:42:28Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            },
            {
              "originalPosition": 244,
              "body": "```suggestion\r\nThe suites BLS12381G2-SHA256-SSWU-RO and BLS12381G2-SHA256-SSWU-NU\r\n```",
              "createdAt": "2019-07-03T20:43:08Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            },
            {
              "originalPosition": 250,
              "body": "I didn't check whether `Z` was generated using the method described above.",
              "createdAt": "2019-07-03T20:44:02Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            },
            {
              "originalPosition": 247,
              "body": "I think it is better to define the extension field and its irreducible polynomial before introduce curve parameters",
              "createdAt": "2019-07-03T20:45:15Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            },
            {
              "originalPosition": 83,
              "body": "what is the meaning of the `eff` part?\r\n`h` is simpler.\r\nEven tough, the distinction between `h` and `h_eff` only differs for pairing curves on the specific case of G2.\r\n",
              "createdAt": "2019-07-03T20:51:04Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzUyODY2",
          "commit": {
            "abbreviatedOid": "a588965"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T21:57:10Z",
          "updatedAt": "2019-07-03T21:57:11Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "\"eff\" is for \"effective,\" because in some cases h_eff != h. I'm trying to avoid overloading h, which we use elsewhere to mean the integer such that n = h * r.\r\n\r\nDo you think there's a better alternative that doesn't overlap with h? maybe `h'`?",
              "createdAt": "2019-07-03T21:57:11Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzUzMTQ2",
          "commit": {
            "abbreviatedOid": "a588965"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T21:58:05Z",
          "updatedAt": "2019-07-03T21:58:06Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "Right now it's in the appendix. Do you prefer to pull it inline here, and only have the isogeny maps in the appendix?",
              "createdAt": "2019-07-03T21:58:06Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzU3MDY1",
          "commit": {
            "abbreviatedOid": "ae7aa38"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T22:12:02Z",
          "updatedAt": "2019-07-03T22:12:02Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "rolled this into another edit",
              "createdAt": "2019-07-03T22:12:02Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzU3MDk2",
          "commit": {
            "abbreviatedOid": "ae7aa38"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T22:12:10Z",
          "updatedAt": "2019-07-03T22:12:10Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "rolled this into another edit",
              "createdAt": "2019-07-03T22:12:10Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzU3MTQx",
          "commit": {
            "abbreviatedOid": "ae7aa38"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T22:12:18Z",
          "updatedAt": "2019-07-03T22:12:18Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "rolled this into another edit",
              "createdAt": "2019-07-03T22:12:18Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzU3Mjc5",
          "commit": {
            "abbreviatedOid": "ae7aa38"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T22:12:47Z",
          "updatedAt": "2019-07-03T22:12:48Z",
          "comments": [
            {
              "originalPosition": 247,
              "body": "Better now?",
              "createdAt": "2019-07-03T22:12:47Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzYxMjQ1",
          "commit": {
            "abbreviatedOid": "b27d8a5"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T22:28:18Z",
          "updatedAt": "2019-07-03T22:28:18Z",
          "comments": [
            {
              "originalPosition": 247,
              "body": "Yes, it is.",
              "createdAt": "2019-07-03T22:28:18Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzYxOTg5",
          "commit": {
            "abbreviatedOid": "b27d8a5"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T22:31:18Z",
          "updatedAt": "2019-07-03T22:31:19Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "For any suite for which `h=h_eff`, list only `h`.\r\nFor the special cases, you can list both constants: the cofactor, (e.g. `h=4`) and the effective cofactor (e.g. `h_eff = h * 10 = 40`) ",
              "createdAt": "2019-07-03T22:31:18Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzcwODg0",
          "commit": {
            "abbreviatedOid": "b27d8a5"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T23:09:47Z",
          "updatedAt": "2019-07-03T23:09:48Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "I prefer to have suite descriptions as explicit as possible.\r\nFor the case of the 11-isogeny, you can list only the point generator of the kernel, and cite to Vel\u00fa formulas for calculating the isogeny, which I assume is the method followed by the Sage script you provide in the paper.",
              "createdAt": "2019-07-03T23:09:47Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzcwOTAz",
          "commit": {
            "abbreviatedOid": "b27d8a5"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T23:09:53Z",
          "updatedAt": "2019-07-03T23:09:53Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "```suggestion\r\n- H: SHA-256\r\n- iso\\_map: the isogeny map to E' from {{WB19}}; see {{appx-bls12381-g1}}\r\n```",
              "createdAt": "2019-07-03T23:09:53Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzkxMTgw",
          "commit": {
            "abbreviatedOid": "b27d8a5"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T01:08:36Z",
          "updatedAt": "2019-07-04T01:08:36Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "It seems like specifying the isogeny via the kernel could work, but I have a couple concerns:\r\n\r\n- the target audience is implementors, who may not be familiar with Velu's formulas. My guess is that most would prefer being given the rational map explicitly rather than a more compact description that takes a lot more work to turn into code, and thus is more likely to cause errors.\r\n\r\n- specifying the kernel of the isogeny only specifies the rational map up to sign: negating the sign of the y-coordinate map must give an isogeny with the same kernel (because an isogeny is a group homomorphism, negating the point at infinity yields the point at infinity, and negating any other point does not).\r\n\r\nI suppose we could specify both the kernel and the rational map, but it's not obvious that the extra information is particularly useful: if someone *really* wants the kernel, they can easily compute it from E, E', and the degree of the isogeny, or they can just go look in the paper...",
              "createdAt": "2019-07-04T01:08:36Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzkxNTU0",
          "commit": {
            "abbreviatedOid": "b27d8a5"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T01:11:11Z",
          "updatedAt": "2019-07-04T01:11:11Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "> I prefer to have suite descriptions as explicit as possible.\r\n\r\nE' is given in an appendix of *this document* (see e7b4fb9), which seems to me to be no less explicit than putting it in this section. But I think it's totally reasonable to put the description of E' here, if you think that's better.",
              "createdAt": "2019-07-04T01:11:11Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzkzNTU2",
          "commit": {
            "abbreviatedOid": "b27d8a5"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T01:24:47Z",
          "updatedAt": "2019-07-04T01:24:48Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "I think I didn't make my rationale clear (which probably means the text needs to be improved!):\r\n\r\n- `h` is *not* an explicit part of the description of a suite (though it's implicit in E and F, of course). This is intentional: it would be redundant to include it, and it would cause confusion in the case that `h_eff` != `h`.\r\n\r\n- In contrast, `h_eff` is not (always) implicitly defined by the other suite parameters, because some curves admit faster cofactor clearing methods.\r\n\r\n- The purpose of specifying `h_eff` is to ensure that all users of a suite clear the cofactor in a compatible way without demanding that everyone use the most optimal implementation. The reason to specify the cofactor clearing method as a scalar is that this is the \"least common denominator\": it seems reasonable to assume that anyone who can hash to the curve can also do scalar multiplication.\r\n\r\nSo: I think it would be both unnecessary and confusing to include `h` in any suite, and as a result I really don't like the idea of specifying `h_eff` in terms of `h`.\r\n\r\nI will make some edits, both here and potentially in {{cofactor-clearing}}, to make all of the above clearer.",
              "createdAt": "2019-07-04T01:24:48Z",
              "updatedAt": "2019-07-04T02:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3Nzk1MjQ1",
          "commit": {
            "abbreviatedOid": "b27d8a5"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T01:35:15Z",
          "updatedAt": "2019-07-04T01:35:15Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "I think I don't understand this edit: `H` is common to G1 and G2, so it's specified in the \"common parameters,\" below.",
              "createdAt": "2019-07-04T01:35:15Z",
              "updatedAt": "2019-07-04T23:53:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3ODA3MTUx",
          "commit": {
            "abbreviatedOid": "adce053"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T02:46:47Z",
          "updatedAt": "2019-07-04T02:46:48Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "I pushed some edits that I hope clarifies and addresses this concern.",
              "createdAt": "2019-07-04T02:46:47Z",
              "updatedAt": "2019-07-04T02:46:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3ODA3MjM5",
          "commit": {
            "abbreviatedOid": "adce053"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T02:47:21Z",
          "updatedAt": "2019-07-04T02:47:21Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "I pushed a commit that pulls E' definitions inline and only refers to the appx for the iso_map definitions.",
              "createdAt": "2019-07-04T02:47:21Z",
              "updatedAt": "2019-07-04T02:47:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4Njk4NTIx",
          "commit": {
            "abbreviatedOid": "adce053"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T05:58:01Z",
          "updatedAt": "2019-07-08T05:58:01Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "Ok, disregard the suggestion.",
              "createdAt": "2019-07-08T05:58:01Z",
              "updatedAt": "2019-07-08T05:58:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4Njk4OTY3",
          "commit": {
            "abbreviatedOid": "adce053"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-08T06:00:05Z",
          "updatedAt": "2019-07-08T06:00:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NzAwMTI1",
          "commit": {
            "abbreviatedOid": "adce053"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T06:05:23Z",
          "updatedAt": "2019-07-08T06:05:24Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "it looks good",
              "createdAt": "2019-07-08T06:05:23Z",
              "updatedAt": "2019-07-08T06:05:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 139,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0MDIxMTUw",
      "title": "domain separation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/139",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This essentially captures what's in #124:\r\n\r\n- add \"HASH-TO-CURVE\" literal in hash_to_base for H() separation\r\n\r\n- change ctr argument in encode_to_curve for free separation from hash_to_curve\r\n\r\n- add a new section in roadmap with requirements for domain separation\r\n\r\n- add a new definition for domain separation\r\n\r\nNote that this does *not* comprehend #137. I think we can treat that as a separate question for now.",
      "createdAt": "2019-07-03T06:30:39Z",
      "updatedAt": "2019-07-04T23:58:22Z",
      "closedAt": "2019-07-04T21:18:53Z",
      "mergedAt": "2019-07-04T21:18:53Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NDQ5MTg0",
          "commit": {
            "abbreviatedOid": "2cdba98"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T12:23:42Z",
          "updatedAt": "2019-07-03T12:23:43Z",
          "comments": [
            {
              "originalPosition": 101,
              "body": "Would we consider making HASH-TO-CURVE shorter (e..g \"H2C\"/ \"HTC\"), and potentially truncating H(msg) such that we can fit m' into a single block in the loop below?\r\n\r\nE.g. the input to the hash in the loop becomes `\"H2C\" || H(msg)[..len(H) - 6] || I2OSP(ctr, 1)  || I2OSP(i, 1) || I2OSP(j, 1)`?",
              "createdAt": "2019-07-03T12:23:42Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NDg0MzI0",
          "commit": {
            "abbreviatedOid": "2cdba98"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The initial text looks good to me. I think some more clarity and examples would help drive the point home, so approving for now. Thanks, @kwantam!",
          "createdAt": "2019-07-03T13:26:08Z",
          "updatedAt": "2019-07-03T13:50:04Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nCryptographic protocols that use random oracles are often analyzed\r\n```",
              "createdAt": "2019-07-03T13:26:09Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            },
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nunder the assumption that random oracles answer only queries generated\r\n```",
              "createdAt": "2019-07-03T13:28:21Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            },
            {
              "originalPosition": 11,
              "body": "Perhaps add:\r\n\r\n```\r\nThat is, let R() be a random oracle used by protocols P1 and P2. If P1 and P2 ever query R with the same value x, the assumption above is violated.\r\n```\r\n\r\nAnd maybe then show how P1 and P2 would use R1 and R2 (as defined below) to address this?",
              "createdAt": "2019-07-03T13:36:07Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            },
            {
              "originalPosition": 24,
              "body": "```suggestion\r\nBecause of these domain separation tags, queries to R1 and R2 cannot yield identical queries to R.\r\n```",
              "createdAt": "2019-07-03T13:37:18Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            },
            {
              "originalPosition": 46,
              "body": "```suggestion\r\nWhen invoking hash\\_to\\_curve in a higher-level protocol, implementors MUST use domain separation\r\n```",
              "createdAt": "2019-07-03T13:37:54Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            },
            {
              "originalPosition": 54,
              "body": "```suggestion\r\nif possible, though it is not required in this case.\r\n```",
              "createdAt": "2019-07-03T13:38:25Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            },
            {
              "originalPosition": 50,
              "body": "Is the expectation that if one had two hash-to-curve functions H1 and H2 targeting the *same* curve, then H1 = H2? ",
              "createdAt": "2019-07-03T13:43:14Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            },
            {
              "originalPosition": 50,
              "body": "It'd be good to clarify why this requirement is needed. (That is, to avoid overlapping hash2base output IIUC.)",
              "createdAt": "2019-07-03T13:43:39Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            },
            {
              "originalPosition": 77,
              "body": "Would it help to give an example of a protocol that needs domain separation internally, too?",
              "createdAt": "2019-07-03T13:47:21Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            },
            {
              "originalPosition": 36,
              "body": "\ud83d\udc4d ",
              "createdAt": "2019-07-03T13:48:54Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            },
            {
              "originalPosition": 101,
              "body": "Perhaps in a separate issue?",
              "createdAt": "2019-07-03T13:49:29Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NjY3NDA1",
          "commit": {
            "abbreviatedOid": "2cdba98"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, ",
          "createdAt": "2019-07-03T18:30:19Z",
          "updatedAt": "2019-07-03T18:30:19Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzIzODg0",
          "commit": {
            "abbreviatedOid": "2cdba98"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T20:38:53Z",
          "updatedAt": "2019-07-03T20:38:53Z",
          "comments": [
            {
              "originalPosition": 101,
              "body": "we'd have to truncate a reasonable amount to avoid going past one block, because SHA-256 adds at least 65 bits of padding to the end of the message. Specifically, the padding is\r\n\r\n- append a single '1' bit\r\n- append k '0' bits where 0 <= k < 512 and bitlen(msg) + 1 + k + 64 is divisible by 512\r\n- append a 64-bit representation of bitlen(msg)\r\n\r\nso it would have to be something like H(msg)[..len(H) - 15], which is pretty extreme.\r\n\r\nAlso, we might want to resolve #137 first, since that would moot this discussion.",
              "createdAt": "2019-07-03T20:38:53Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzI4MDcw",
          "commit": {
            "abbreviatedOid": "1387d77"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T20:48:49Z",
          "updatedAt": "2019-07-03T20:48:49Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Yes, unless they're explicitly separated. I suppose I should clarify this point.",
              "createdAt": "2019-07-03T20:48:49Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzQwMTcx",
          "commit": {
            "abbreviatedOid": "c4ee7eb"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T21:19:17Z",
          "updatedAt": "2019-07-03T21:19:17Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Yeah, I think the first paragraph is unclear in a couple ways. I'll try to address and incorporate the above.",
              "createdAt": "2019-07-03T21:19:17Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzUxMTM0",
          "commit": {
            "abbreviatedOid": "0400920"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T21:51:28Z",
          "updatedAt": "2019-07-03T21:51:29Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "I pushed an edit to address this.",
              "createdAt": "2019-07-03T21:51:29Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzUxMTcx",
          "commit": {
            "abbreviatedOid": "0400920"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T21:51:36Z",
          "updatedAt": "2019-07-03T21:51:36Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "I pushed an edit to address this.",
              "createdAt": "2019-07-03T21:51:36Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzUxMjEx",
          "commit": {
            "abbreviatedOid": "0400920"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T21:51:43Z",
          "updatedAt": "2019-07-03T21:51:43Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "I pushed an edit to address this.",
              "createdAt": "2019-07-03T21:51:43Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzUxMzI3",
          "commit": {
            "abbreviatedOid": "0400920"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T21:52:09Z",
          "updatedAt": "2019-07-03T21:52:10Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Done, I think.",
              "createdAt": "2019-07-03T21:52:09Z",
              "updatedAt": "2019-07-03T21:53:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 141,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0NjMyMTIw",
      "title": "Replace hash_to_base PRG with HKDF-Expand.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/141",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #137.",
      "createdAt": "2019-07-04T15:49:15Z",
      "updatedAt": "2019-07-06T13:28:05Z",
      "closedAt": "2019-07-06T13:27:44Z",
      "mergedAt": "2019-07-06T13:27:44Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "An alternative suggestion:\r\n\r\nWhat if we did\r\n\r\n```\r\nm' = H(msg)\r\nfor i in (1, ..., m):\r\n  info = \"H2C\" || I2OSP(ctr, 1) || I2OSP(i, 1)\r\n  t = HKDF-Expand-H(m', info, L)\r\n  e_i = OS2IP(t) mod p\r\nreturn u = (e_1, ..., e_m)\r\n```\r\n\r\nThis guarantees that the HMAC key (`m'`) is shorter than the block length. Moreover, the `info` argument to HKDF-Expand is 5 bytes, which guarantees the minimum possible number of H invocations in HKDF-Expand (4 per iteration, because of HMAC) for the major hash functions I'm aware of (see below).\r\n\r\nAlso, aesthetically this is slightly nicer, since it moves all of the hash-to-curve--specific domain separation pieces (\"H2C\", ctr, i) into one place.\r\n\r\nFinally, this change sort of anticipates the suggestion in my next comment.\r\n\r\n---\r\n\r\nLet's check to make sure that HMAC uses the minimum number of H invocations in all cases.\r\n\r\nRecall that `HMAC(k, msg) = H( (k XOR OPAD) || H( (k XOR IPAD) || msg ) )`. For simplicity, I'm assuming that k is one block long (in reality, it's always padded or hashed-and-padded to that length, so this is a reasonable simplification).\r\n\r\nHKDF-Expand(k, info, L) in the worst case invokes\r\n\r\n    HMAC(k, H(something) || info || b)\r\n\r\nwhere b is 1 byte long. So what we need to check is that `H(something) || info || b` is short enough for each hash function of interest.\r\n\r\n- **SHA-2** adds at least 9 bytes (rounding up) of padding to its argument, so when H is a SHA-2 function, the argument to the inner invocation of H in the HMAC invocation in HKDF-Expand is block_len + hash_len + len(info) + 1 + 9 bytes long, and we want this value to be at most 2 * block_len. Worst case is SHA2-256, which has block_len = 64, hash_len = 32. In this case, len(info) must be at most 64 - 32 - 10 = 22 bytes. :heavy_check_mark:\r\n\r\n- **SHA-3** adds at least 1 byte (rounding up) of padding to its argument, so when H is a SHA-3 function, the argument to the inner H invocation is block_len + hash_len + len(info) + 1 + 1 bytes long. Worst case is SHA3-512, which has block_len = 72, hash_len = 64. In this case, len(info) must be at most 72 - 64 - 2 = 6 bytes :heavy_check_mark:\r\n\r\n- **BLAKE2** doesn't force padding, so when H is a BLAKE function, the argument to the inner H invocation is block_len + hash_len + len(info) + 1 bytes long. Worst case is BLAKE2s256, which has block_len = 64, hash_len = 32. In this case, len(info) must be at most 64 - 32 - 1 = 31 bytes :heavy_check_mark:\r\n\r\nSo it looks like \"H2C\" is preferred if we want to avoid another compression function invocation in the absolute worst case, which is SHA3-512.",
          "createdAt": "2019-07-04T23:03:15Z",
          "updatedAt": "2019-07-04T23:52:46Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Another question to consider: should we use HKDF-Extract to compute `m'`?\r\n\r\n(Just spitballing here, not sure whether I like it or not. Also, I'm going to assume for concreteness that we're going with the suggested change in [my prior comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/141#issuecomment-508588103). This could work either way, though.)\r\n\r\nHKDF-Extract takes two arguments, `salt` and `msg`. In the spirit of @hoeteck's suggestion in #124 (and a suggestion from Dan out-of-band), we might require higher-level protocols to set the value for `salt` based on their domain separation string.\r\n\r\n~~~\r\nhash_to_base(msg, ctr)\r\n\r\nParameters:\r\n- DSS, a domain separation string chosen according to the\r\n  guidelines given in {{domain-separation}}.\r\n- H, a cryptographic hash function.\r\n- F, a finite field of characteristic p and order q = p^m.\r\n- L = ceil((ceil(log2(p)) + k) / 8), where k is the security parameter\r\n  of the cryptosystem (e.g., k = 128).\r\n- HKDF-Extract-H is the HKDF-Extract function of RFC5869\r\n  instantiated with hash function H.\r\n- HKDF-Expand-H is the HKDF-Expand function of RFC5869\r\n  instantiated with hash function H.\r\n\r\nInputs:\r\n- msg is the message to hash.\r\n- ctr is 0, 1, or 2.\r\n  This is used to efficiently create independent\r\n  instances of hash_to_base (see discussion above).\r\n\r\nOutput:\r\n- u, an element in F.\r\n\r\nSteps:\r\n1. m' = HKDF-Extract-H(H(DSS), msg)\r\n2. for i in (1, ..., m):\r\n3.   info = \"H2CURVE\" || I2OSP(ctr, 1) || I2OSP(i, 1)\r\n4.   t = HKDF-Expand-H(m', info, L)\r\n5.   e_i = OS2IP(t) mod p\r\n6. return u = (e_1, ..., e_m)\r\n~~~\r\n\r\nIf DSS is fixed, H(DSS) can be precomputed to save one invocation of H. Also, this lets people use domain separation strings of arbitrary length with effectively no performance penalty.",
          "createdAt": "2019-07-04T23:18:10Z",
          "updatedAt": "2019-07-04T23:55:24Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "As an aside, [STROBE](https://strobe.sourceforge.io/) would handle this role fairly cleanly too.",
          "createdAt": "2019-07-04T23:29:18Z",
          "updatedAt": "2019-07-04T23:29:18Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> As an aside, [STROBE](https://strobe.sourceforge.io/) would handle this role fairly cleanly too.\r\n\r\nGreat! Since this is a very general framework, is there a specific STROBE-related hash function that you have in mind here?\r\n\r\n(My guess is that our initial ciphersuite specs will all use hashes in the SHA2 family, but I'm certain that other people will eventually want to use, e.g., BLAKE. So probably the action item with respect to STROBE is just to make sure that we're not accidentally specifying something that's incredibly inefficient.)",
          "createdAt": "2019-07-04T23:49:34Z",
          "updatedAt": "2019-07-04T23:50:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> STROBE would handle this role fairly cleanly too.\r\n\r\nThat is good to know, though I don't think we could adopt it so easily at the moment.",
          "createdAt": "2019-07-05T03:51:22Z",
          "updatedAt": "2019-07-05T03:51:22Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Another question to consider: should we use HKDF-Extract to compute `m'`?\r\n>\r\n> (Just spitballing here, not sure whether I like it or not. Also, I'm going to assume for concreteness that we're going with the suggested change in [my prior comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/141#issuecomment-508588103). This could work either way, though.)\r\n> \r\n> HKDF-Extract takes two arguments, `salt` and `msg`. In the spirit of @hoeteck's suggestion in #124 (and a suggestion from Dan out-of-band), we might require higher-level protocols to set the value for `salt` based on their domain separation string.\r\n\r\nI'm fine with this change, though I think I'd remove the initial hash computation of DSS. My reasoning being that HKDF will compute this hash anyway if |DSS| > H's output size anyway. Thanks for the suggestion!\r\n\r\n> \r\n> ```\r\n> hash_to_base(msg, ctr)\r\n> \r\n> Parameters:\r\n> - DSS, a domain separation string chosen according to the\r\n>   guidelines given in {{domain-separation}}.\r\n> - H, a cryptographic hash function.\r\n> - F, a finite field of characteristic p and order q = p^m.\r\n> - L = ceil((ceil(log2(p)) + k) / 8), where k is the security parameter\r\n>   of the cryptosystem (e.g., k = 128).\r\n> - HKDF-Extract-H is the HKDF-Extract function of RFC5869\r\n>   instantiated with hash function H.\r\n> - HKDF-Expand-H is the HKDF-Expand function of RFC5869\r\n>   instantiated with hash function H.\r\n> \r\n> Inputs:\r\n> - msg is the message to hash.\r\n> - ctr is 0, 1, or 2.\r\n>   This is used to efficiently create independent\r\n>   instances of hash_to_base (see discussion above).\r\n> \r\n> Output:\r\n> - u, an element in F.\r\n> \r\n> Steps:\r\n> 1. m' = HKDF-Extract-H(H(DSS), msg)\r\n> 2. for i in (1, ..., m):\r\n> 3.   info = \"H2CURVE\" || I2OSP(ctr, 1) || I2OSP(i, 1)\r\n> 4.   t = HKDF-Expand-H(m', info, L)\r\n> 5.   e_i = OS2IP(t) mod p\r\n> 6. return u = (e_1, ..., e_m)\r\n> ```\r\n> \r\n> If DSS is fixed, H(DSS) can be precomputed to save one invocation of H. Also, this lets people use domain separation strings of arbitrary length with effectively no performance penalty.\r\n",
          "createdAt": "2019-07-05T04:04:41Z",
          "updatedAt": "2019-07-05T04:04:41Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> It wasn't clear to me that it would be quite this easy to invoke HKDF, because I was thinking that the size of the PRK argument to HKDF was restricted to the output length of H, rather than the block size of H. But as far as I can tell, this mostly works for the hash functions we'd expect people to use (but see below).\r\n\r\nThis seems to resolve itself by just using Extract() before Expand(). :-)",
          "createdAt": "2019-07-05T04:07:13Z",
          "updatedAt": "2019-07-05T04:07:13Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "I think only the keccak-f(1600) based STROBE variant has any implementations right now.  \r\n\r\n@chris-wood  Are you saying the hash-to-field functions call extract in a tree like way?  It's true STROBE does not add so much for trees where you'd clone the state all the time.  You'd need to impose an ordering on the extractions to exploit STROBE optimally.  And doing so encurages constraints on the order in which developers extract field elements.  \r\n\r\nIt's actually common to clone STROBE states, which may still save some stack space over HKDF, but not much, and maybe worse with hand optimizations.  I suppose the most efficient scheme for extracting a tree is to simply use ChaCha20, assigning nonces in a tree-like way using \"heap addressing\".\r\n\r\nAll this is moot because BLS is really for consensus protocols, not \"accounts\", so nobody will ever run BLS on ridiculously constrained devices anyways, like say a Ledger device. ",
          "createdAt": "2019-07-05T07:33:07Z",
          "updatedAt": "2019-07-05T07:33:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> @chris-wood Are you saying the hash-to-field functions call extract in a tree like way? It's true STROBE does not add so much for trees where you'd clone the state all the time. You'd need to impose an ordering on the extractions to exploit STROBE optimally. And doing so encurages constraints on the order in which developers extract field elements.\r\n\r\nNo, sadly, my comment was more reflective about IETF than it was about anything technical. (We'd need to fully specify STROBE here or elsewhere prior to adopting it.)",
          "createdAt": "2019-07-05T13:30:21Z",
          "updatedAt": "2019-07-05T13:30:21Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "Right, I'm actually not convinced STROBE is optimal anyways.  I'd think the `meta_ad` used for domain separation could probably safely xor into another part of the state in parallel to the main data xor, thus reducing keccak invocations.  Also you'd want some fast input command analogous to kangarootwelve.  And some ChaCha based variant.  Anyways sorry for the derail..",
          "createdAt": "2019-07-05T17:31:56Z",
          "updatedAt": "2019-07-05T17:31:56Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Awesome!\r\n\r\nI just realized there's one more bit of inconsistency that this PR should fix: the description in {{hashtobase-perf}}. I opened #143 against the PR branch because suggested edits can't yet do multiline as far as I can tell.",
          "createdAt": "2019-07-05T18:27:49Z",
          "updatedAt": "2019-07-05T18:27:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Nice! Just one tiny annoyance, sorry...\r\n\r\nNits are always appreciated! No need to apologize.",
          "createdAt": "2019-07-06T13:28:05Z",
          "updatedAt": "2019-07-06T13:28:05Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4MTc1NTk0",
          "commit": {
            "abbreviatedOid": "e58ee2b"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "This is great.\r\n\r\nIt wasn't clear to me that it would be quite this easy to invoke HKDF, because I was thinking that the size of the `PRK` argument to HKDF was restricted to the *output* length of H, rather than the block size of H. But as far as I can tell, this mostly works for the hash functions we'd expect people to use (but see below).\r\n\r\n~~We will have to stage this and #139 because the definition of `m'` changes in that PR. (EDIT: #139 is now merged, so we'll have to do some conflict resolution here.)~~\r\n\r\nAssuming we go with the string \"HASH-TO-CURVE\" as in #139, the length of `m'` is 14 + H_output_len bytes. Just for sanity, let's see whether this works with the hash functions we might care to use:\r\n\r\n- 224-bit hashes: len(`m'`) = 42 bytes\r\n  - SHA2-224 block size = 64 bytes :heavy_check_mark:\r\n  - SHA3-224 block size = 144 bytes :heavy_check_mark:\r\n  - BLAKE2s224 block size = 64 bytes :heavy_check_mark:\r\n- 256-bit hashes: len(`m'`) = 46 bytes\r\n  - SHA2-256 block size = 64 bytes :heavy_check_mark:\r\n  - SHA3-256 block size = 136 bytes :heavy_check_mark:\r\n  - BLAKE2s256 block size = 64 bytes :heavy_check_mark:\r\n  - BLAKE2b256 block size = 128 bytes :heavy_check_mark:\r\n- 384-bit hashes: len(`m'`) = 62 bytes\r\n  - SHA2-384 block size = 128 bytes :heavy_check_mark:\r\n  - SHA3-384 block size = 104 bytes :heavy_check_mark:\r\n  - BLAKE2b384 block size = 128 bytes :heavy_check_mark:\r\n- 512-bit hashes: len(`m'`) = 78 bytes\r\n  - SHA2-512 block size = 128 bytes :heavy_check_mark:\r\n  - SHA3-512 block size = 72 bytes :x:    hmmmm\r\n  - BLAKE2b512 block size = 128 bytes :heavy_check_mark:\r\n\r\nSo the only one that's a little weird is SHA3-512. Maybe we should consider replacing \"HASH-TO-CURVE\" with \"H2CURVE\", which is 6 bytes shorter and thus works with SHA3-512, or even just \"H2C\" as @samscott89 has suggested elsewhere.\r\n\r\n(Note that len(`m'`) > block size isn't fatal---it just requires, per RFC2104, hashing `m'` *again* to give an HMAC key that is shorter than the block length. We should probably avoid this.)",
          "createdAt": "2019-07-04T21:55:59Z",
          "updatedAt": "2019-07-05T17:56:32Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I think mentioning the counter here distracts from the point (security) and sort of breaks the organization of the section (`ctr` isn't actually introduced until ~25 lines down, so the reader wonders \"wait, did I miss something? what counter???\").\r\n\r\nAlso, I think it would be nice to retain the example.\r\n\r\nMaybe:\r\n\r\n```\r\nTo obtain such an integer, HKDF {{RFC5869}} is used to expand the input msg\r\nto a L-byte string, where L = ceil((ceil(log2(p)) + k) / 8); this string is then interpreted\r\nas an integer via OS2IP {{RFC8017}}.\r\nFor example, for p a 255-bit prime and k = 128-bit security, L = ceil((255 + 128) / 8) = 48 bytes.\r\n```",
              "createdAt": "2019-07-04T21:55:59Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            },
            {
              "originalPosition": 27,
              "body": "```suggestion\r\n- F, a finite field of characteristic p and order q = p^m.\r\n- L = ceil((ceil(log2(p)) + k) / 8), where k is the security parameter of the cryptosystem (e.g., k = 128).\r\n- HKDF-Expand-H is the HKDF-Expand function from RFC5869 instantiated with hash function H.\r\n```",
              "createdAt": "2019-07-04T21:58:33Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            },
            {
              "originalPosition": 44,
              "body": "Along with the suggestion to make L a parameter, I suggest removing this line and renumbering.",
              "createdAt": "2019-07-04T21:59:51Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            },
            {
              "originalPosition": 47,
              "body": "```suggestion\r\n4.   t = HKDF-Expand-H(m', I2OSP(i, 1), L)\r\n```",
              "createdAt": "2019-07-04T22:00:23Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            },
            {
              "originalPosition": 20,
              "body": "Suggest removing the second sentence (\"It requires...\") and instead defining HKDF-Expand-H in the Parameters section below, per one of my other comments.",
              "createdAt": "2019-07-04T22:01:59Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4MjExNjA4",
          "commit": {
            "abbreviatedOid": "e58ee2b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-05T03:45:58Z",
          "updatedAt": "2019-07-05T03:45:58Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I figured keeping \"counter\" (rather than a reference to `car`) as a parenthetical was enough for the curious, though you're right in that it's unnecessary information at this point. I'm fine with the example. I just took it out since it's a pretty trivial computation.",
              "createdAt": "2019-07-05T03:45:58Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4MjExNzQ0",
          "commit": {
            "abbreviatedOid": "8047b4f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-05T03:46:55Z",
          "updatedAt": "2019-07-05T03:46:56Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Works for me!",
              "createdAt": "2019-07-05T03:46:55Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4MjExNzkz",
          "commit": {
            "abbreviatedOid": "8047b4f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-05T03:47:20Z",
          "updatedAt": "2019-07-05T03:47:20Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Hmm, I'm not familiar with this way of indicating H. Typically it's is inferred from context, which I think is clear here.",
              "createdAt": "2019-07-05T03:47:20Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4MjExOTAw",
          "commit": {
            "abbreviatedOid": "8047b4f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-05T03:48:13Z",
          "updatedAt": "2019-07-05T03:48:13Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Yep, that's cleaner! Will remove.",
              "createdAt": "2019-07-05T03:48:13Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4MjEyMTQ1",
          "commit": {
            "abbreviatedOid": "8047b4f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-05T03:50:07Z",
          "updatedAt": "2019-07-05T03:50:07Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "(Read your suggestion below, and provided it's defined as a parameter then this works great. Will adopt it.)",
              "createdAt": "2019-07-05T03:50:07Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4MjMxMjk4",
          "commit": {
            "abbreviatedOid": "1736233"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Great!\r\n\r\nThese are pretty small nits, even though they look like a bunch of comments...\r\n\r\nOne other small thing: should we add a forward ref from {{domain-separation}} to here?\r\n\r\nMaybe a standalone paragraph before the one that starts \"Care is required...\" that says something like\r\n\r\n~~~\r\n{{hashtobase}} specifies how to apply a domain separation tag.\r\n~~~",
          "createdAt": "2019-07-05T05:56:25Z",
          "updatedAt": "2019-07-05T06:23:59Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Argh. Just realized that references inside fenced code blocks don't work (but maybe there's some escape sequence syntax for them?).\r\n\r\nAlso, I just realized that calling it a \"string\" rather than a \"tag\" breaks with the terminology elsewhere. So maybe we should say \"DST\" instead?\r\n\r\nSeems like there are a couple options: either we write in \"Section 4.1\" (or whatever) and then just make sure to keep it up-to-date, or we add some words in {{hashtobase-sec}} discussing the DSS parameter, put the crossref to {{domain-separation}} there, and then say something like\r\n~~~\r\n- DST, a domain separation tag (see discussion above).\r\n~~~\r\nlike we currently do for `ctr`.\r\n\r\nI guess I lean towards the second choice. Thoughts?\r\n\r\n([I've proposed](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/141#discussion_r300552314) specific text for {{hashtobase-sec}}, in case you agree.)",
              "createdAt": "2019-07-05T05:56:26Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            },
            {
              "originalPosition": 12,
              "body": "Suggested text vis-a-vis my [other comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/141#discussion_r300548990):\r\n\r\n```suggestion\r\n\r\n{{domain-separation}} discusses requirements for domain separation and recommendations\r\nfor choosing domain separation tags.\r\nThe hash\\_to\\_curve function takes such a tag as a parameter, DST; this is the\r\nRECOMMENDED way of applying domain separation.\r\nAs an alternative, implementations MAY instead prepend a domain separation tag to the\r\ninput msg; in this case, DST SHOULD be the empty string.\r\n\r\n```",
              "createdAt": "2019-07-05T06:14:44Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            },
            {
              "originalPosition": 34,
              "body": "Super nitpicky (and totally my fault): maybe break \"parameter\" onto the next line to keep line lengths approximately equal?\r\n\r\n:sweat:",
              "createdAt": "2019-07-05T06:17:59Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            },
            {
              "originalPosition": 20,
              "body": "nit (sorry...)\r\n\r\n```suggestion\r\nThe following procedure implements hash\\_to\\_base.\r\n```",
              "createdAt": "2019-07-05T06:20:08Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            },
            {
              "originalPosition": 53,
              "body": "If we're renaming DSS -> DST,\r\n\r\n```suggestion\r\n1. m' = HKDF-Extract-H(DST, msg)\r\n```",
              "createdAt": "2019-07-05T06:20:29Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NDAzODQx",
          "commit": {
            "abbreviatedOid": "a166f86"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-05T13:26:58Z",
          "updatedAt": "2019-07-05T13:26:59Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Not your fault! Good catch.",
              "createdAt": "2019-07-05T13:26:58Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NTE4Mjcz",
          "commit": {
            "abbreviatedOid": "2726950"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-05T18:48:06Z",
          "updatedAt": "2019-07-05T18:48:07Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "I find this syntax a little confusing. Is the idea that the H in `HKDF-Extract-H` should be expanded to SHA2, etc, in each case?\r\n\r\nI suggest we stick to the same notation used in the original draft, and others like the TLS 1.3 draft. So, just use \"HKDF-Extract\" and specify under that the hash function used is given by the ciphersuite?",
              "createdAt": "2019-07-05T18:48:07Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NTIwNzQz",
          "commit": {
            "abbreviatedOid": "2726950"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-05T18:57:29Z",
          "updatedAt": "2019-07-05T18:57:30Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "What if we just called it \"Extract\"?\r\n\r\n```\r\n- Extract is the HKDF-Extract function of RFC5869 instantiated with\r\n  hash function H.\r\n```\r\n\r\nIs that clearer?",
              "createdAt": "2019-07-05T18:57:30Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NTI1MDA2",
          "commit": {
            "abbreviatedOid": "2726950"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-05T19:14:32Z",
          "updatedAt": "2019-07-05T19:14:32Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Maybe:\r\n\r\n```\r\n - HKDF-Expand and HKDF-Extract are as defined in {{rfc5869}}, instantiated with the hash function H\r\n```\r\nAgain, keeping it closer to notation used elsewhere.",
              "createdAt": "2019-07-05T19:14:32Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NTQxNjg5",
          "commit": {
            "abbreviatedOid": "6ac003a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-05T20:28:01Z",
          "updatedAt": "2019-07-05T20:28:01Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "I preferred the -H notation since it made clear that H determined Extract, though the expansion issue is a valid concern. I'm fine with the proposal!",
              "createdAt": "2019-07-05T20:28:01Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NTU1MTQx",
          "commit": {
            "abbreviatedOid": "6ac003a"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Nice! Just one tiny annoyance, sorry...",
          "createdAt": "2019-07-05T21:39:55Z",
          "updatedAt": "2019-07-05T21:40:56Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Got caught by this last time: hotlinks are broken inside fenced blocks :face_with_head_bandage:\r\n\r\n```suggestion\r\n- HKDF-Extract and HKDF-Expand are as defined in RFC5869, \r\n```",
              "createdAt": "2019-07-05T21:39:55Z",
              "updatedAt": "2019-07-05T21:43:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 142,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0NzAwNDM1",
      "title": "remove out-of-date test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/142",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "...but promise to return them in the future :)\r\n\r\nIf we get the poc code updated in time, we can put these back before submitting the draft.",
      "createdAt": "2019-07-05T00:01:50Z",
      "updatedAt": "2019-07-05T18:42:25Z",
      "closedAt": "2019-07-05T13:53:09Z",
      "mergedAt": "2019-07-05T13:53:09Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NDE2NDAw",
          "commit": {
            "abbreviatedOid": "e9c01b0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-05T13:52:55Z",
          "updatedAt": "2019-07-05T13:52:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 143,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0OTU0MDY4",
      "title": "update description in {{hashtobase-perf}}",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/143",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "(seems easier to do this way...)",
      "createdAt": "2019-07-05T18:27:07Z",
      "updatedAt": "2019-07-06T18:13:36Z",
      "closedAt": "2019-07-05T20:05:59Z",
      "mergedAt": "2019-07-05T20:05:59Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NTM2OTEz",
          "commit": {
            "abbreviatedOid": "bb070f6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-05T20:05:53Z",
          "updatedAt": "2019-07-05T20:05:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 145,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1MDgwMjAx",
      "title": "small clarity fixes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/145",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This commit fixes some clarity issues that @reyzin pointed out in personal communication.\r\n\r\nAlso clarify which values are integer arithmetic and which are field arithmetic in implementations, which I think responds to #135.",
      "createdAt": "2019-07-07T05:34:44Z",
      "updatedAt": "2019-07-08T20:25:00Z",
      "closedAt": "2019-07-08T20:18:55Z",
      "mergedAt": "2019-07-08T20:18:55Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh I'll include the clarification re +-1 for sgn0 in the pseudocode PR.",
          "createdAt": "2019-07-08T20:25:00Z",
          "updatedAt": "2019-07-08T20:25:00Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDIwNDAx",
          "commit": {
            "abbreviatedOid": "07469c6"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T16:30:33Z",
          "updatedAt": "2019-07-08T16:30:34Z",
          "comments": [
            {
              "originalPosition": 101,
              "body": "```suggestion\r\n5.  e1 = (t2 ^ 2) == x\r\n```",
              "createdAt": "2019-07-08T16:30:34Z",
              "updatedAt": "2019-07-08T19:10:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDU0NTc5",
          "commit": {
            "abbreviatedOid": "07469c6"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I am pointing some nits that I found on this PR.",
          "createdAt": "2019-07-08T17:36:21Z",
          "updatedAt": "2019-07-08T18:28:18Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "if `q` is removed from `sqrt(x, q)` , then it should be removed from `is_square(x, q)` too.",
              "createdAt": "2019-07-08T17:36:21Z",
              "updatedAt": "2019-07-08T19:10:20Z"
            },
            {
              "originalPosition": 17,
              "body": "This paragraph can be improved with something like this: \r\n~~~\r\nFor security reasons, all field operations, comparisons, and assignments must be implemented in constant time (i.e., execution time must not depend on the values of the inputs), and without branching.\r\n~~~",
              "createdAt": "2019-07-08T17:40:10Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            },
            {
              "originalPosition": 26,
              "body": "```suggestion\r\n    Commonly, implementations assume that the selector c is 1 for True, or 0 for False.\r\n```",
              "createdAt": "2019-07-08T17:42:28Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            },
            {
              "originalPosition": 62,
              "body": "```suggestion\r\nOutput: s, an element of F such that s ^ 2 = x.\r\n```",
              "createdAt": "2019-07-08T17:44:25Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            },
            {
              "originalPosition": 68,
              "body": "```suggestion\r\n1. c1 = sqrt(-1) in F, i.e., (c1 * c1) = -1 in F\r\n2. c2 = (q + 3) / 8        // Integer arithmetic\r\n```",
              "createdAt": "2019-07-08T17:46:07Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            },
            {
              "originalPosition": 71,
              "body": "```suggestion\r\n 1. t1 = x ^ c2\r\n```",
              "createdAt": "2019-07-08T17:46:21Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            },
            {
              "originalPosition": 74,
              "body": "```suggestion\r\n2.  e = (t1 ^ 2) == x\r\n```",
              "createdAt": "2019-07-08T17:47:02Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            },
            {
              "originalPosition": 88,
              "body": "```suggestion\r\n3. c3 = sqrt(-c1) in F, i.e., (c3 * c3) == -c1 in F\r\n4. c4 = (q + 7) / 16\r\n```",
              "createdAt": "2019-07-08T17:48:30Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            },
            {
              "originalPosition": 91,
              "body": "```suggestion\r\n 1.  t1 = x^c4\r\n```",
              "createdAt": "2019-07-08T17:48:39Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            },
            {
              "originalPosition": 113,
              "body": "Why not `-x` ?",
              "createdAt": "2019-07-08T17:50:39Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            },
            {
              "originalPosition": 126,
              "body": "Do we need to remark that `-1` is an integer instead of an element of the field?",
              "createdAt": "2019-07-08T17:52:53Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            },
            {
              "originalPosition": 206,
              "body": "This definition is correct but difficult to get.\r\n~~~\r\nZ, is a value such that abs(Z) is the smallest in F for which g( B/(Z*A) ) is square. If Z and -Z both meet the above criteria, choose Z such that sgn0(Z) == 1.\r\n~~~\r\n",
              "createdAt": "2019-07-08T18:20:05Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            },
            {
              "originalPosition": 229,
              "body": "Since the exceptional cases were handled, there is no need for testing again for `is_square(gx2)`. \r\n\r\n```suggestion\r\n8.  Else, set x = x2 and y = sqrt(gx2)\r\n```\r\n",
              "createdAt": "2019-07-08T18:23:50Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            },
            {
              "originalPosition": 236,
              "body": "Does the sign of the root must be specified here or in the suite?",
              "createdAt": "2019-07-08T18:25:50Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4OTA1MTQz",
          "commit": {
            "abbreviatedOid": "07469c6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This looks good to me (modulo @armfazh's nits)!",
          "createdAt": "2019-07-08T13:35:15Z",
          "updatedAt": "2019-07-08T18:44:45Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "\ud83d\udc4d ",
              "createdAt": "2019-07-08T13:35:15Z",
              "updatedAt": "2019-07-08T19:10:20Z"
            },
            {
              "originalPosition": 304,
              "body": "\ud83d\udc4d ",
              "createdAt": "2019-07-08T13:40:31Z",
              "updatedAt": "2019-07-08T19:10:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDkwNTY5",
          "commit": {
            "abbreviatedOid": "d7dfde1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T18:46:08Z",
          "updatedAt": "2019-07-08T18:46:08Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "In principle it could be either, right?\r\n\r\nAlso, in the definition of abs we say `sgn0(x) * x`, which kind of implies interpreting sgn0 as returning an element of F.",
              "createdAt": "2019-07-08T18:46:08Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDkyMTk3",
          "commit": {
            "abbreviatedOid": "d7dfde1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T18:49:20Z",
          "updatedAt": "2019-07-08T18:49:20Z",
          "comments": [
            {
              "originalPosition": 236,
              "body": "No need to specify. Setting the sign of y gets the right result no matter which sign you choose for c3.",
              "createdAt": "2019-07-08T18:49:20Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDk2OTU2",
          "commit": {
            "abbreviatedOid": "99cb70a"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T18:58:56Z",
          "updatedAt": "2019-07-08T18:58:56Z",
          "comments": [
            {
              "originalPosition": 206,
              "body": "Yeah, I struggled with this one a lot.\r\n\r\nThe issue with the old wording (and I think with the suggested edit) is that it's not that abs(Z) is the smallest, it's that there's no other Z' smaller. In other words, it's `<=`, not `<`, and then we specify a way of breaking the possible tie from `<=`.\r\n\r\nMaybe a bulleted list makes it easier? I'll push an edit and let's see how that works.",
              "createdAt": "2019-07-08T18:58:56Z",
              "updatedAt": "2019-07-08T19:10:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTAyNjYz",
          "commit": {
            "abbreviatedOid": "0ef5698"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T19:10:56Z",
          "updatedAt": "2019-07-08T19:10:57Z",
          "comments": [
            {
              "originalPosition": 206,
              "body": "OK, pushed new text using lists. Thoughts?",
              "createdAt": "2019-07-08T19:10:57Z",
              "updatedAt": "2019-07-08T19:10:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTMxNDg0",
          "commit": {
            "abbreviatedOid": "0ef5698"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T20:13:30Z",
          "updatedAt": "2019-07-08T20:13:30Z",
          "comments": [
            {
              "originalPosition": 236,
              "body": "That's true.",
              "createdAt": "2019-07-08T20:13:30Z",
              "updatedAt": "2019-07-08T20:13:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTMxODgx",
          "commit": {
            "abbreviatedOid": "0ef5698"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T20:14:21Z",
          "updatedAt": "2019-07-08T20:14:21Z",
          "comments": [
            {
              "originalPosition": 206,
              "body": "I think it looks better now.",
              "createdAt": "2019-07-08T20:14:21Z",
              "updatedAt": "2019-07-08T20:14:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTMyNDA5",
          "commit": {
            "abbreviatedOid": "0ef5698"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T20:15:27Z",
          "updatedAt": "2019-07-08T20:15:28Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "It does, however, in the implementation side -1 \\in ZZ (or even -1 as a boolean) is different from -1 in F.\r\n",
              "createdAt": "2019-07-08T20:15:28Z",
              "updatedAt": "2019-07-08T20:15:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTM1NzUw",
          "commit": {
            "abbreviatedOid": "0ef5698"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T20:22:15Z",
          "updatedAt": "2019-07-08T20:22:16Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "True! Fixed.",
              "createdAt": "2019-07-08T20:22:16Z",
              "updatedAt": "2019-07-08T20:22:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 146,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1MTc2NzM5",
      "title": "pseudocode for curve25519, edwards25519, curve448, edwards448",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/146",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This adds optimized pcode for the above curves, plus an explanation of projective coordinate conversions.\r\n\r\ncloses #133\r\ncloses #4\r\n\r\nI'm going to do some extra proofreading tomorrow with fresh eyes, after which I'll mark it ready for merge. (Also,need to merge #145 first)\r\n\r\nReady for review now, though.",
      "createdAt": "2019-07-08T05:06:45Z",
      "updatedAt": "2019-11-05T18:26:21Z",
      "closedAt": "2019-07-08T23:30:52Z",
      "mergedAt": "2019-07-08T23:30:52Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "Ristretto's hash-to-curve differs slightly from Ed25519 btw:  https://doc.dalek.rs/src/curve25519_dalek/ristretto.rs.html#606 ",
          "createdAt": "2019-07-08T13:45:10Z",
          "updatedAt": "2019-07-08T13:45:10Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Ristretto's hash-to-curve differs slightly from Ed25519 btw: https://doc.dalek.rs/src/curve25519_dalek/ristretto.rs.html#606\r\n\r\nThanks! I'll link this comment from the Ristretto issue.",
          "createdAt": "2019-07-08T20:14:45Z",
          "updatedAt": "2019-07-08T20:14:45Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I've pushed sage tests for the text pseudocode.",
          "createdAt": "2019-07-08T20:50:00Z",
          "updatedAt": "2019-07-08T20:50:00Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to try and make the simplified SWU impl more generic and move the optimized P-256 to the appx, too. If I can't get it pushed within the hour I'll give up so that we have time before the deadline to finalize.",
          "createdAt": "2019-07-08T21:14:25Z",
          "updatedAt": "2019-07-08T21:14:25Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, pushed P-256 pcode. Now to push the corresponding sage checking script.",
          "createdAt": "2019-07-08T22:00:51Z",
          "updatedAt": "2019-07-08T22:00:51Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Checking script pushed, too.",
          "createdAt": "2019-07-08T22:20:25Z",
          "updatedAt": "2019-07-08T22:20:25Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "It should be warned somewhere in the main doc which sage scripts correspond to the version we will submit. ",
          "createdAt": "2019-07-08T22:45:39Z",
          "updatedAt": "2019-07-08T22:45:39Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> It should be warned somewhere in the main doc which sage scripts correspond to the version we will submit.\r\n\r\nDo you think doing it the opposite way would work? Namely, put a README file in the code directory that tells people which code corresponds to which parts of the draft?\r\n\r\nThe reason to do it in the above way is that it doesn't tie us to a particular directory structure for the repository, whereas if we commit to filenames / directory structure / whatever, we're stuck with it until we update the document.",
          "createdAt": "2019-07-08T22:54:24Z",
          "updatedAt": "2019-07-08T22:54:24Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "(Also: that way we can do it after the deadline :) )",
          "createdAt": "2019-07-08T22:54:51Z",
          "updatedAt": "2019-07-08T22:54:51Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> Do you think doing it the opposite way would work? Namely, put a README file in the code directory that tells people which code corresponds to which parts of the draft?\r\n\r\nYes, good idea.",
          "createdAt": "2019-07-08T22:55:31Z",
          "updatedAt": "2019-07-08T22:55:31Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Do you think doing it the opposite way would work? Namely, put a README file in the code directory that tells people which code corresponds to which parts of the draft?\r\n> \r\n> Yes, good idea.\r\n\r\nAdded #151 to capture this",
          "createdAt": "2019-07-08T22:57:11Z",
          "updatedAt": "2019-07-08T22:57:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTkwMzg0",
          "commit": {
            "abbreviatedOid": "92947e6"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T22:35:08Z",
          "updatedAt": "2019-07-08T22:35:08Z",
          "comments": [
            {
              "originalPosition": 259,
              "body": "```suggestion\r\nmap_to_curve_simple_sswu_p256(u)\r\n```",
              "createdAt": "2019-07-08T22:35:08Z",
              "updatedAt": "2019-07-08T23:30:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTkwOTAx",
          "commit": {
            "abbreviatedOid": "92947e6"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T22:36:48Z",
          "updatedAt": "2019-07-08T22:36:48Z",
          "comments": [
            {
              "originalPosition": 259,
              "body": "\"s\" in \"sswu\" stands for \"Simple,\" so I think \"simple_sswu\" is redundant.\r\n\r\nIn {{simple-swu}}, the function name is \"map_to_curve_simple_swu\", too.",
              "createdAt": "2019-07-08T22:36:48Z",
              "updatedAt": "2019-07-08T23:30:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTkxNzg0",
          "commit": {
            "abbreviatedOid": "92947e6"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T22:39:58Z",
          "updatedAt": "2019-07-08T22:39:58Z",
          "comments": [
            {
              "originalPosition": 259,
              "body": "sorry it's correct.",
              "createdAt": "2019-07-08T22:39:58Z",
              "updatedAt": "2019-07-08T23:30:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 147,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1NDc5NjMy",
      "title": "Typo",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/147",
      "state": "MERGED",
      "author": "JustinDrake",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-07-08T20:11:59Z",
      "updatedAt": "2019-07-08T20:17:47Z",
      "closedAt": "2019-07-08T20:17:42Z",
      "mergedAt": "2019-07-08T20:17:42Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": ":+1: looks good to me\r\n\r\n@chris-wood?",
          "createdAt": "2019-07-08T20:17:04Z",
          "updatedAt": "2019-07-08T20:17:04Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Also: thanks!!!",
          "createdAt": "2019-07-08T20:17:15Z",
          "updatedAt": "2019-07-08T20:17:15Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 -- thank you!",
          "createdAt": "2019-07-08T20:17:47Z",
          "updatedAt": "2019-07-08T20:17:47Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTMzNDM3",
          "commit": {
            "abbreviatedOid": "0e3bf4e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-08T20:17:37Z",
          "updatedAt": "2019-07-08T20:17:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 148,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1NDg4NzM1",
      "title": "Remove a duplicated word",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/148",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-07-08T20:39:39Z",
      "updatedAt": "2019-07-08T21:04:09Z",
      "closedAt": "2019-07-08T21:04:09Z",
      "mergedAt": "2019-07-08T21:04:09Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTQ1Njk4",
          "commit": {
            "abbreviatedOid": "56af65f"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T20:43:09Z",
          "updatedAt": "2019-07-08T20:43:09Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n where \\<csid\\> is the ciphersuite string, and \\<xx\\> and \\<zz\\> are\r\n```",
              "createdAt": "2019-07-08T20:43:09Z",
              "updatedAt": "2019-07-08T20:43:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTU1NjY0",
          "commit": {
            "abbreviatedOid": "59de8bf"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-08T21:04:04Z",
          "updatedAt": "2019-07-08T21:04:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 149,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1NDkxNTU5",
      "title": "Typo",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/149",
      "state": "CLOSED",
      "author": "JustinDrake",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The `hash_to_base` function has two parameters.\r\n\r\nNote: I'm note sure how new lines are determined. It looks like line 1260 is now longer than the others.",
      "createdAt": "2019-07-08T20:48:15Z",
      "updatedAt": "2019-07-08T22:26:35Z",
      "closedAt": "2019-07-08T22:26:35Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "JustinDrake",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Similar problem with \"The function hash_to_base, {0, 1}^* -> F\"",
          "createdAt": "2019-07-08T21:05:01Z",
          "updatedAt": "2019-07-08T21:05:01Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Similar problem with \"The function hash_to_base, {0, 1}^* -> F\"\r\n\r\nMaybe here, `{0, 1}^\\* x {0, 1, 2} -> F` would be OK.\r\n\r\n(Though I really don't love loading up on notation that readers might not be familiar with...)",
          "createdAt": "2019-07-08T21:11:28Z",
          "updatedAt": "2019-07-08T21:11:28Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I've combined both suggested fixes into #150",
          "createdAt": "2019-07-08T22:26:35Z",
          "updatedAt": "2019-07-08T22:26:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTU2NTYy",
          "commit": {
            "abbreviatedOid": "2b2d25f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for catching this!\r\n\r\nI think maybe the fix is to go the other direction, though:",
          "createdAt": "2019-07-08T21:06:01Z",
          "updatedAt": "2019-07-08T21:06:23Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think it might be better not to introduce either parameter at this point. The sentence reads fine without them, and the ctr variable is a distraction at this point in the text.\r\n\r\n```suggestion\r\nThe hash\\_to\\_base function hashes a string msg of any length into an element of a\r\n```",
              "createdAt": "2019-07-08T21:06:02Z",
              "updatedAt": "2019-07-08T21:06:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTU5NDQ4",
          "commit": {
            "abbreviatedOid": "2b2d25f"
          },
          "author": "JustinDrake",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T21:12:26Z",
          "updatedAt": "2019-07-08T21:12:26Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": ":+1:",
              "createdAt": "2019-07-08T21:12:26Z",
              "updatedAt": "2019-07-08T21:12:26Z"
            }
          ]
        }
      ]
    },
    {
      "number": 150,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1NTE4MjA4",
      "title": "fix type signature issues with hash_to_base",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/150",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "closes #149",
      "createdAt": "2019-07-08T22:25:46Z",
      "updatedAt": "2019-11-05T18:24:43Z",
      "closedAt": "2019-07-08T22:38:13Z",
      "mergedAt": "2019-07-08T22:38:13Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTg5NDAx",
          "commit": {
            "abbreviatedOid": "0424ff0"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-08T22:31:41Z",
          "updatedAt": "2019-07-08T22:31:41Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTkxMjgz",
          "commit": {
            "abbreviatedOid": "0424ff0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-08T22:38:08Z",
          "updatedAt": "2019-07-08T22:38:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 152,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1NjU5NTM2",
      "title": "Fix off by one",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/152",
      "state": "CLOSED",
      "author": "JustinDrake",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Since `2**256 - 1 mod 2**255-19` is 37",
      "createdAt": "2019-07-09T09:12:32Z",
      "updatedAt": "2019-10-23T21:46:34Z",
      "closedAt": "2019-10-23T21:46:34Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcyODk3NjMz",
          "commit": {
            "abbreviatedOid": "4f0773e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-09T00:20:07Z",
          "updatedAt": "2019-08-09T00:20:07Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgzODQxNzM3",
          "commit": {
            "abbreviatedOid": "4f0773e"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-09-04T19:25:09Z",
          "updatedAt": "2019-09-04T19:25:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 154,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1Njc2NDAy",
      "title": "Avoid rehashing msg",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/154",
      "state": "CLOSED",
      "author": "JustinDrake",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "`msg` can be large so we want to avoid rehashing it. As I understand it, `HKDF-Extract(DST, msg)` imposes an \"arbitrary\" hashing of `msg`, namely `H(DST XOR ipad, msg)` where `ipad` is the byte `0x36` repeated 64 times. (See section 2 in [RFC 2104](https://tools.ietf.org/html/rfc2104).) Since various applications will have `H(msg)` readily computed, it makes sense to use `H(msg)` in `HKDF-Extract` as a \"natural\" way to minimise the chances of hashing `msg` multiple times.",
      "createdAt": "2019-07-09T09:54:38Z",
      "updatedAt": "2019-09-04T09:20:16Z",
      "closedAt": "2019-09-04T09:20:15Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "In the invocation of HMAC, DST is the `key`, which is a short-length string, and the `text` corresponds to an arbitrary-length message `msg`. \r\n\r\n```fortran\r\nH(K XOR opad, H(K XOR ipad, text))\r\n```\r\n\r\nit seems to me that message is hashed once.",
          "createdAt": "2019-07-09T17:52:36Z",
          "updatedAt": "2019-07-09T17:52:36Z"
        },
        {
          "author": "JustinDrake",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If the application already hashed the message in the most natural way (i.e. computed `H(msg)`) then the signature forces *another* hashing of the message with `HKDF-Extract`.",
          "createdAt": "2019-07-09T18:08:16Z",
          "updatedAt": "2019-07-09T18:08:16Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "Related https://github.com/pairingwg/bls_standard/issues/18 ",
          "createdAt": "2019-07-10T06:41:11Z",
          "updatedAt": "2019-07-10T06:41:11Z"
        },
        {
          "author": "JustinDrake",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yep, #18 is related (may be worth reopening now that there is an issue with the current `hash_to_base`). I can see various ways to solve the double-hashing:\r\n\r\n1) The spec choose `H(msg)` as a \"best guess digest\" and feeds `H(msg)` into `HKDF-Extract`.\r\n2) The spec mandates that `msg` be 32 bytes (i.e. some sort of digest). The application layer can use any function that produces a 32-byte digest, including application-layer hash functions that are different to `H`, as well as Merkleisation functions which are common in blockchains.\r\n3) (status quo) Applications either consciously opt-in to option 2) or risk falling in the double signing trap.\r\n\r\nIt seems that option 3) is strictly worse than 2). As such, I'm inclined to favour option 1) or 2).",
          "createdAt": "2019-07-10T09:43:05Z",
          "updatedAt": "2019-07-10T09:43:05Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for bringing up this issue, Justin :+1:\r\n\r\nTerminology: let's use `H'` to mean the hash function that the invoking protocol is using, while `H` is the hash used inside hash_to_base.\r\n\r\n(I injected the above terminology in the below quote from Justin)\r\n> If the application already hashed the message in the most natural way (i.e. computed `H'(msg)`) then the signature forces _another_ hashing of the message with `HKDF-Extract`.\r\n\r\nTo be perfectly clear (this is of course implicit in your comments above): if an invoking protocol has already computed `H'(msg)`, it can hash that value to the curve rather than hashing `msg` to the curve, provided that `H'` meets essentially the same requirements that we impose on `H` in the definition of hash_to_base (collision resistance, sufficient output length).\r\n\r\nConsidering the options that Justin proposed:\r\n\r\n1. Using `H(msg)` doesn't appear to solve the problem, because there's no guarantee that `H` == `H'`, and if it doesn't then there's no opportunity for optimization. Am I correct in surmising that this is what you mean by \"best guess\"---it might be right, but no guarantees? And so the point is, if an application gets lucky and `H` == `H'`, it can bypass the `H(msg)` invocation in hash_to_base by passing this value in, thereby avoiding double hashing, right?\r\n\r\n2. From my perspective, forcing `msg` to a fixed length is something of a step backwards: not only does it make the primitive strictly less general, it means that the choice of `H'` is moved \"outside\" this document, which has potential security implications (what if the application uses MD5?)\r\n\r\n3. I kind of like the idea of letting the invoking protocol decide whether to hash `msg` or `H'(msg)`. Just to be clear, is your concern that someone will specify hashing `msg` to the curve, then later regret it when they realize they'd already computed `H'(msg)`? In this case, what if we add a note (probably in Section 5) making explicit the requirements on `H'` and stating that invoking protocols MAY use `H'(msg)` instead of `msg`?",
          "createdAt": "2019-08-09T00:17:27Z",
          "updatedAt": "2019-08-09T00:17:27Z"
        },
        {
          "author": "JustinDrake",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Am I correct in surmising that this is what you mean by \"best guess\"\r\n\r\nYes :)\r\n\r\n> what if we add a note (probably in Section 5) making explicit the requirements on `H'` and stating that invoking protocols MAY use `H'(msg)` instead of `msg`\r\n\r\nAdding a note sounds good to me :) And nothing prevents a \"blockchain standard\" strictly less general than the CFRG spec to recommend only signing 32-byte messages.",
          "createdAt": "2019-08-12T21:27:15Z",
          "updatedAt": "2019-08-12T21:27:15Z"
        },
        {
          "author": "JustinDrake",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The consensus after discussing this is to stick with the status quo. The expectation is that most implementors will make `msg` a short digest (but not necessarily a 32-byte hash output). We could add a note recommending `msg` be a short digest.\r\n\r\ncc @kirk-baird",
          "createdAt": "2019-09-04T09:20:15Z",
          "updatedAt": "2019-09-04T09:20:15Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 163,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1ODAxODUz",
      "title": "small fixes to address #160, #161, #162",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/163",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is mostly a minor edit to address the above.\r\n\r\nThe most major thing is a new (small) section laying out the convention for creating a new Suite ID. The reason for having the convention is that it's best if suite IDs are prefix-free, and this convention helps with that.",
      "createdAt": "2019-08-09T01:18:44Z",
      "updatedAt": "2019-08-14T01:36:41Z",
      "closedAt": "2019-08-13T15:41:59Z",
      "mergedAt": "2019-08-13T15:41:58Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 I added a paragraph at the end of the new subsection on suite IDs that I think comprehends the worries in #140 and #161. Please let me know if it seems like I'm missing anything.",
          "createdAt": "2019-08-09T01:25:05Z",
          "updatedAt": "2019-08-09T01:25:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@samscott89 please have a look!",
          "createdAt": "2019-08-11T15:13:23Z",
          "updatedAt": "2019-08-11T15:13:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjczNDI0NDY1",
          "commit": {
            "abbreviatedOid": "d939b3f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2019-08-10T12:50:37Z",
          "updatedAt": "2019-08-10T12:52:26Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Should we reference the earlier section where we define the minimum value of L?",
              "createdAt": "2019-08-10T12:50:37Z",
              "updatedAt": "2019-08-12T21:35:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjczNDc1NzQy",
          "commit": {
            "abbreviatedOid": "af09765"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This looks like a great clarity/ambiguity win.",
          "createdAt": "2019-08-11T19:15:38Z",
          "updatedAt": "2019-08-11T19:21:47Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "We should probably avoid using \"var prime\" as a variable name. It's not representable in most programming languages, and easy to misread.\r\n\r\nCould this be \"info_prefix\" instead? ",
              "createdAt": "2019-08-11T19:15:38Z",
              "updatedAt": "2019-08-12T21:35:40Z"
            },
            {
              "originalPosition": 91,
              "body": "Love the idea of adding the version to an existing field. But why the enc type field? To me this implies changing the entire definition of the random oracle construction, versus making, E.g., curve specific changes?",
              "createdAt": "2019-08-11T19:19:44Z",
              "updatedAt": "2019-08-12T21:35:40Z"
            },
            {
              "originalPosition": 18,
              "body": "( I accept this is maybe not in scope for this PR) ",
              "createdAt": "2019-08-11T19:21:04Z",
              "updatedAt": "2019-08-12T21:35:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjczNDkwMDQw",
          "commit": {
            "abbreviatedOid": "af09765"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-12T01:05:47Z",
          "updatedAt": "2019-08-12T01:05:48Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Ah, this is a great question!\r\n\r\nIn my head, the reason was just that there's nothing else to go in the ENC field other than the two characters \"RO\" or \"NU\", so there's tons of room for subfields while still respecting the (somewhat arbitrary) 64 char per field size limit.\r\n\r\n(Regarding the size limit: I thought having an explicit size limit would make impls somewhat easier to reason about.)\r\n\r\nWhat if we renamed it to \"ENC_MISC\" and modified the description to make this more explicit?\r\n\r\nAn alternative is to have a separate \"misc\" field, but then it doesn't seem to make sense to allow 64 chars for the \"ENC_TYPE\" field, at which point the grammar gets more complex because some fields have different sizes than other fields, and it's honestly not obvious that we'll ever use the misc field...",
              "createdAt": "2019-08-12T01:05:48Z",
              "updatedAt": "2019-08-12T21:35:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjczNDkwMTA3",
          "commit": {
            "abbreviatedOid": "af09765"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-12T01:06:54Z",
          "updatedAt": "2019-08-12T01:06:55Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "This is a great point. Totally easy to fix here (and `m'`, too).",
              "createdAt": "2019-08-12T01:06:54Z",
              "updatedAt": "2019-08-12T21:35:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjczNzcyNDM3",
          "commit": {
            "abbreviatedOid": "d38e757"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-12T15:30:43Z",
          "updatedAt": "2019-08-12T15:30:44Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": ">  and it's honestly not obvious that we'll ever use the misc field...\r\n\r\nYeah, the following is very much TIOLI, since it does seem low importance.\r\n\r\nA few potential counter points: implementations might assume exactly 2 bytes for `RO` or `NU`. Although following this logic very much leads us into needing a GREASE-like system. \r\n\r\nI mostly just semantically find the idea of versioning the \"encoding type\" to feel weird. \r\n\r\n> What if we renamed it to \"ENC_MISC\" and modified the description to make this more explicit?\r\n\r\nHow about \"ENC_VAR\" ~ encoding variant? ",
              "createdAt": "2019-08-12T15:30:43Z",
              "updatedAt": "2019-08-12T21:35:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjczODE2NTI5",
          "commit": {
            "abbreviatedOid": "d38e757"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-12T16:47:00Z",
          "updatedAt": "2019-08-12T16:47:01Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "ENC_VAR sounds great to me. @chris-wood?",
              "createdAt": "2019-08-12T16:47:01Z",
              "updatedAt": "2019-08-12T21:35:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjczOTUyMTY5",
          "commit": {
            "abbreviatedOid": "d38e757"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-12T21:09:05Z",
          "updatedAt": "2019-08-12T21:09:05Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Yep, sounds good to me, too! (Though I would be fine with either. :))",
              "createdAt": "2019-08-12T21:09:05Z",
              "updatedAt": "2019-08-12T21:35:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjczOTY0MDc1",
          "commit": {
            "abbreviatedOid": "466df2a"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-12T21:35:50Z",
          "updatedAt": "2019-08-12T21:35:50Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "OK, changed. Thoughts?",
              "createdAt": "2019-08-12T21:35:50Z",
              "updatedAt": "2019-08-12T21:35:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjczOTY4Mzk4",
          "commit": {
            "abbreviatedOid": "466df2a"
          },
          "author": "samscott89",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM! ",
          "createdAt": "2019-08-12T21:46:30Z",
          "updatedAt": "2019-08-12T21:46:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 167,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE5MDQ4NzMw",
      "title": "Promoting SW as a general map",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/167",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The original construction of Shallue-van de Woestijne (SW, to avoid confusion with names) can be used as a (almost) generic method for hashing into **any** curve in short Weierstrass form.\r\n\r\nChanges:\r\n - SW stands now as a generic method.\r\n - SW costs 4 exponentiation (in affine coordinates).\r\n - Added SW suites for P-256, P-384, P-521, BN256, SECP256K1.\r\n - Added a PDF with the description of the formulas (it follows a combination of Fouque-Tibouchi and Wahby approaches) File: ([math/sw.pdf](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/blob/a0c68c9c78e67d5019e7aa3659e5a9f0af2ba29a/math/sw.pdf)).",
      "createdAt": "2019-09-19T00:28:38Z",
      "updatedAt": "2019-10-23T21:54:53Z",
      "closedAt": "2019-10-23T21:54:53Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a great start! but I think there's a problem:\r\n\r\nIn math/sw.pdf and in the proposed edits, the requirements for Z are given as\r\n\r\n- `f(Z)` != 0\r\n- `f(Z)` is a QR\r\n- `-(3 Z^2 + 4A) != 0`\r\n- `-(3 Z^2 + 4A)` is a QR\r\n\r\nMy issue is that there certainly exist curves for which this parameterization **does not work**. In particular, if `A = 0`, then the fourth requirement is that `-3 Z^2` is a QR, which reduces to -3 is a QR, which is equivalent to requiring p = 1 mod 3. (You can convince yourself that -3 is a QR iff p = 1 mod 3 via some quadratic residuosity manipulations. FT point this out in FT12, too.)\r\n\r\nSo: any curve where p = 2 mod 3 and A = 0 simply cannot work with this parameterization.\r\n\r\nThat was the point of [my write-up](https://github.com/kwantam/draft-irtf-cfrg-hash-to-curve/raw/generalized_svdw/svdw_general.pdf) --- to work (with high probability) for any curve. I realize it's slightly more complicated than what's described here, but I don't see a simpler approach that really works for any curve.",
          "createdAt": "2019-10-10T04:06:13Z",
          "updatedAt": "2019-10-10T04:06:13Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "This method shows one parametrization to the conic equal to the one followed in FT paper. However, it fails when A=0 and p=2 mod 3, since -3 is a non square.\r\n ",
          "createdAt": "2019-10-23T21:54:53Z",
          "updatedAt": "2019-10-23T21:54:53Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 168,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE5MDUxNjE4",
      "title": "Removing Icart encoding",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/168",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The curve P384 is one example that uses Icart method. However, it can also be used SW and SSWU mappings instead.\r\n\r\nLets argue on this proposal.",
      "createdAt": "2019-09-19T00:47:13Z",
      "updatedAt": "2019-10-10T21:35:08Z",
      "closedAt": "2019-10-10T21:35:08Z",
      "mergedAt": "2019-10-10T21:35:08Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "\ud83d\udc4d I agree, let's remove it! @kwantam @samscott89 @grittygrease, any objections?",
          "createdAt": "2019-09-19T15:18:58Z",
          "updatedAt": "2019-09-19T15:18:58Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems like a great idea to me! I was thinking we should do exactly the same thing!",
          "createdAt": "2019-10-10T01:42:11Z",
          "updatedAt": "2019-10-10T01:42:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk5Nzg0Nzc0",
          "commit": {
            "abbreviatedOid": "47c0cf6"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looks good to me other than a small consistency issue.",
          "createdAt": "2019-10-10T02:00:00Z",
          "updatedAt": "2019-10-10T02:01:05Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "```suggestion\r\n- Z: -1\r\n```\r\n\r\nIsn't `Z = -1` the value that meets the criteria given in `{{simple-swu}}`? -2 also works, but I think is not consistent with that part of the document.\r\n\r\nIs the idea to avoid -1 for reasons that Bjorn Haase has pointed out? If so, I think we should discuss that change in a separate PR, and this PR should stay consistent with the rest of the document.",
              "createdAt": "2019-10-10T02:00:30Z",
              "updatedAt": "2019-10-10T17:58:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwMjQzODU5",
          "commit": {
            "abbreviatedOid": "47c0cf6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Approved pending @kwantam's suggestion!",
          "createdAt": "2019-10-10T17:48:19Z",
          "updatedAt": "2019-10-10T17:48:19Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwMjcxODkw",
          "commit": {
            "abbreviatedOid": "6841e8c"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": ":+1: ",
          "createdAt": "2019-10-10T18:35:30Z",
          "updatedAt": "2019-10-10T18:35:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 169,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIyNDUwMzYw",
      "title": "Security consideration: brute-force attacks",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/169",
      "state": "CLOSED",
      "author": "vanhoefm",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This informs the reader of brute-force attacks if the output of hash_to_base (or derived values) is leaked. Suggested defence is to preprocess the input of hash_to_base.\r\n\r\nComments are welcome!",
      "createdAt": "2019-09-28T22:15:25Z",
      "updatedAt": "2019-10-23T21:46:35Z",
      "closedAt": "2019-10-23T21:46:35Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the PR!\r\n\r\nIt's probably simpler (and certainly true) to point out that even the output of *hash-to-curve* (not just hash-to-base) enables such a brute-force attack.\r\n\r\nSo maybe the way to phrase the advice is that one should treat passwords the same with these hash functions as with any other: use salts, use expensive KDFs, etc.",
          "createdAt": "2019-10-10T16:43:58Z",
          "updatedAt": "2019-10-10T16:44:25Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 170,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI3NDE1MzI4",
      "title": "roll-up of a few small-ish changes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/170",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR addresses a few TODOs from my list.\r\n\r\nThe most major one is that it addresses @cjpatton's suggestions regarding domain separation.\r\n\r\nIt also rolls in suggestions from @JustinDrake and @vanhoefm, and fixes some small editorial nits.\r\n\r\nOh, and it updates the acknowledgment sections.",
      "createdAt": "2019-10-12T02:15:25Z",
      "updatedAt": "2019-10-23T21:46:33Z",
      "closedAt": "2019-10-23T21:46:33Z",
      "mergedAt": "2019-10-23T21:46:33Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Looks good. Though I would double check with Benjamin Lipp about interpretation of his result for HKDF, just to be on the safe side.\r\n\r\n@kwantam are you OK with merging this PR as is, or do you want to wait?",
          "createdAt": "2019-10-17T19:52:47Z",
          "updatedAt": "2019-10-17T19:52:47Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> @kwantam are you OK with merging this PR as is, or do you want to wait?\r\n\r\nSorry for the late reply. I emailed Benjamin and he pointed out an issue: while it's true that this proposal fixes this specific problem with the indifferentiability proof, it unfortunately points to a different and potentially more pernicious one.\r\n\r\nThe issue is, since we've added a call to H(msg), we now need to ensure that no other invocation of H (*inside* HMAC) collides with this invocation! So we've kind of \"pushed the bubble.\"\r\n\r\nI chatted with Leo Reyzin about this, and we concluded that that we could fix this by instead computing\r\n\r\n    msg_prime = HKDF-Extract(DST, msg || 0x00)\r\n\r\nThis works because `0x00` (a 1-byte value) will never be the last byte of the input to any HMAC invocation inside HKDF-Expand, [by construction](https://tools.ietf.org/html/rfc5869#section-2.3).\r\n\r\nBut here's the problem: this notion that we have to worry about colliding inputs to `H` may go further than just hash-to-base, because arguably it implies that any protocol that uses hash-to-base in \"prehash mode\" (i.e., calls hash-to-base on `H(msg)` where `msg` is potentially an adversarially-supplied input) could break the indifferentiability simulator from the LBB19 proof.\r\n\r\nNow, it may be that this is not a realistic worry (in which case, there's no need to change hash-to-base at all). We ought to be able to make this statement more formally in terms of some concrete hardness assumption about H. I'll think about this over the weekend and report back.\r\n\r\nMeanwhile, @cjpatton, do the above \"fix\" make sense to you? (I'll also plan to ping Benjamin.)",
          "createdAt": "2019-10-18T22:56:29Z",
          "updatedAt": "2019-10-18T22:56:52Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, Benjamin Lipp sanity checked me and agrees that the above fix works in isolation.\r\n\r\nThe question of whether pre-hashing `msg` with the same `H` used in hash-to-base breaks indifferentiability remains open. At first blush, there *certainly* seem to be protocols in which the indifferentiability proof is broken: allowing arbitrary (adversarial) queries to both `H` and hash_to_base seems to be one example.\r\n\r\nMy hope is that we can at least resolve the \"prehash mode\" issue, since I suspect folks will definitely want that use-case to be secure!",
          "createdAt": "2019-10-22T02:36:48Z",
          "updatedAt": "2019-10-22T02:41:00Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "NONE",
          "body": "If I understand @kwantam correctly, the issue is that we can apply LBB19's indifferentiability Lemma, to get from HKDF to HMAC, but we now have to deal with simulating H(msg) when applying [[DRST12](https://eprint.iacr.org/2013/382.pdf), Thm.4.3] to get from HMAC to H. I'm not sure I see the difficulty here.\r\n\r\nIn particular, to apply [DRST12, Thm.4.3] we need only to restrict the usage of HMAC so that the key is in some \"allowed key set\" as defined in [DRST12, Sec.4.4]. In particular, I believe all we need to do is ensure that the length of the salt (i.e., DST) is equal to the output length of H. (Note that the same should suffice when applying [DRST12, Thm.4.4], which deals with length-extension attacks against Merkle-Damagard-type hash functions.)\r\n\r\nI might be missing something, however.\r\n\r\nIn any case, I think appending a `0x00` byte to the unhashed input would work.",
          "createdAt": "2019-10-22T18:16:15Z",
          "updatedAt": "2019-10-22T18:17:58Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton thanks for the sanity check.\r\n\r\nI'm going to update the PR to append the 0x00 to the unhashed input, because we *know* that meets the requirements. We can separately think about whether we need to add any specific recommendations when pre-hashing msg.\r\n\r\nFirst blush, I agree with you (@cjpatton) that I don't see an issue with the DRST12 result and H(msg), at least generically. Or, at least, it looks to me like any difficulty that arises is of the sort described by [RSS11](https://eprint.iacr.org/2011/339)---and that would be a problem with the invoking protocol, *not* with us. (For this reason, it's probably worthwhile to point to RSS11 in the security considerations.)",
          "createdAt": "2019-10-23T03:04:31Z",
          "updatedAt": "2019-10-23T03:04:31Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK @chris-wood @armfazh I changed the approach to one that's easily proven good.\r\n\r\n~~I'll open a separate issue where we can discuss whether to add words about pre-hashing security considerations.~~ Actually, on second thought, this isn't the right document for that conversation, because we don't have the necessary details. So higher-level protocols should worry about any kind of \"prehash\" mode, I'd say.",
          "createdAt": "2019-10-23T04:35:39Z",
          "updatedAt": "2019-10-23T04:52:44Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh any objections to merging?",
          "createdAt": "2019-10-23T21:18:20Z",
          "updatedAt": "2019-10-23T21:18:20Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> @armfazh any objections to merging?\r\n\r\nI have no objections, just few comments:\r\n-  As you mentioned #167  didn't work for curves A=0 and p=2 mod 3.\r\n-  I noticed that different ways to parametrize the conic leads to different mappings (which maybe equivalent).\r\n-  However, I am working on another parametrization, different from #167 and from this PR, which seems to be simpler. I will share with you some details.\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2019-10-23T21:45:07Z",
          "updatedAt": "2019-10-23T21:45:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMDIzMTg3",
          "commit": {
            "abbreviatedOid": "4ad3d3e"
          },
          "author": "cjpatton",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "At a high-level, hashing the message first seems like a good idea, but I'm not 100% sure that the spec meets the requirements of [LBB19, Lemma 8]. (See detailed comment below.) You might want to reach out to the authors of that paper for feedback.",
          "createdAt": "2019-10-12T21:27:31Z",
          "updatedAt": "2019-10-12T22:22:01Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "More precisely: \"whose outputs are indifferentiable from a random oracle when XXX is modeled as a random oracle\", where XXX is the underlying construction.",
              "createdAt": "2019-10-12T21:27:32Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            },
            {
              "originalPosition": 74,
              "body": "nit: \"random oracle to G\" -> \"random oracle whose range is G\"",
              "createdAt": "2019-10-12T21:29:13Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            },
            {
              "originalPosition": 151,
              "body": "I feel this is a bit too informal. I would either punt on this (just say something like, \"so care must be taken when instantiating it\") or provide a deeper discussion about how the structure of H might (or mightn't) be exploited in the application of H described here. As a reader, I would be interested in whether Merkle-Damgard constructions (e.g., SHA2) are suitable instantiations of H. In particular, how do BCIMRT10 recommend instantiating the hash function? Does their analysis address length-extension attacks [[CDMP05](https://iacr.org/archive/crypto2005/36210424/36210424.pdf)]?",
              "createdAt": "2019-10-12T21:44:20Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            },
            {
              "originalPosition": 172,
              "body": "You should refer to Lemma 8 instead of Appendix A.2 here. (Note that I misquoted this as Lemma 7 in my paper :/)",
              "createdAt": "2019-10-12T21:58:15Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            },
            {
              "originalPosition": 170,
              "body": "My understanding is that the following are sufficient conditions for ensuring the usage of HKDF is indiferentiable from an RO when the hash function used by HMAC is modeled as an RO. These combine results from LBB19 (Lemma 8) and [[DRST12](https://eprint.iacr.org/2013/382.pdf)] (Theorems 4.3 and 4.4) See the discussion in [[PS19](https://eprint.iacr.org/2019/519.pdf), Appx. B] for details. Suppose that HMAC has output length `h` (in bits).\r\n\r\n1. The \"info\" string is always length `u` (in bits).\r\n2. The \"salt\" string is always length `h`.\r\n3. The \"key\" string (i.e., `msg`) has length other than `u + 8` he length of the input to HMAC for the first HKDF-extracted block) or `h + u + 8` (the length of the input to HMAC for each subsequent block).\r\n\r\nSo `H(msg)` is suitable as long as `u !=  h - 8`.\r\n\r\nBy the way, what is `H`? Is the same hash function as used with HKDF?",
              "createdAt": "2019-10-12T22:03:17Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            },
            {
              "originalPosition": 282,
              "body": "\"Chris\" -> \"Christopher\" (for look-up purposes)",
              "createdAt": "2019-10-12T22:18:57Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMDI2Nzc0",
          "commit": {
            "abbreviatedOid": "4ad3d3e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-12T23:58:51Z",
          "updatedAt": "2019-10-12T23:58:51Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "Great point. I've updated the wording.\r\n\r\nBCIMRT10 don't discuss the underlying hash function, because in their construction they assume that one has already managed to instantiate a random oracle whose domain is the base field of the target elliptic curve.\r\n\r\nFor our purposes, length extension isn't a problem because SHA-2 gets wrapped inside of HMAC inside of the HKDF construction, which plausibly eliminates this worry. More generally, as long as we're happy modeling HKDF as a random oracle outputting L-byte strings for sufficiently large L (i.e., log (p) + k bits, k the security parameter), then hash_to_base is a random oracle whose domain is Z/pZ giving at most 2^-k statistical distance from a uniform distribution over Z/pZ.",
              "createdAt": "2019-10-12T23:58:51Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMDI2OTkx",
          "commit": {
            "abbreviatedOid": "4ad3d3e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-13T00:08:46Z",
          "updatedAt": "2019-10-13T00:08:46Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "H is indeed the same hash used with HKDF. I'll double check that this is clear in the text.\r\n\r\nThinking out loud here:\r\n\r\n- HMAC's output length is the same as H's output length, which is `h` (we used `b` in the document, but I'll stick with your terminology in this comment).\r\n\r\n- `u` is 40 bits for us: info is `H2Cxy`, where \"H2C\" is ASCII text, and x and y are 8-bit values.\r\n\r\n- As you say, input to the HMAC calls inside HKDF-Expand are either 48 or 48 + `h` bits, and so what we need is that `40 != h - 8` or, sufficiently, `h > 48`. But of course `h` will *definitely* be more than 48 because of the collision resistance requirements in this section.\r\n\r\nSo: I think we're in agreement here, and I think the text correctly states a sufficient requirement for `h`.",
              "createdAt": "2019-10-13T00:08:46Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMDI3MTYz",
          "commit": {
            "abbreviatedOid": "4ad3d3e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-13T00:16:51Z",
          "updatedAt": "2019-10-13T00:16:51Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "(I've now added a cite to DRST12, too)",
              "createdAt": "2019-10-13T00:16:51Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMDI4Mzk2",
          "commit": {
            "abbreviatedOid": "c177dd6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM -- thanks for the cleanup, @kwantam!",
          "createdAt": "2019-10-13T01:17:34Z",
          "updatedAt": "2019-10-13T01:27:24Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "Provided the sufficient conditions are correct, I agree with @kwantam's conclusion. (And thanks for writing that down, @cjpatton!)",
              "createdAt": "2019-10-13T01:17:35Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            },
            {
              "originalPosition": 91,
              "body": "\ud83d\udc4d ",
              "createdAt": "2019-10-13T01:25:55Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            },
            {
              "originalPosition": 159,
              "body": "Perhaps we should drop a reference to the ciphersuite section here? (One might read this and think of ciphersuites as part of the protocol in which h2c is used, whereas here we mean a single protocol using multiple h2c suites.)",
              "createdAt": "2019-10-13T01:27:14Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMDMzMDI0",
          "commit": {
            "abbreviatedOid": "c177dd6"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-13T05:10:09Z",
          "updatedAt": "2019-10-13T05:10:09Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "Oh! Good point---but actually probably we should mean both! I'll update.",
              "createdAt": "2019-10-13T05:10:09Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMDMzMjY1",
          "commit": {
            "abbreviatedOid": "07fc683"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-13T05:19:31Z",
          "updatedAt": "2019-10-13T05:19:32Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "Clearer now?",
              "createdAt": "2019-10-13T05:19:31Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMDY3MzU0",
          "commit": {
            "abbreviatedOid": "07fc683"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-13T21:10:30Z",
          "updatedAt": "2019-10-13T21:10:31Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "Yep -- looks good!",
              "createdAt": "2019-10-13T21:10:30Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMzc1NTE3",
          "commit": {
            "abbreviatedOid": "07fc683"
          },
          "author": "cjpatton",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-14T15:19:21Z",
          "updatedAt": "2019-10-14T15:19:21Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "Agreed.",
              "createdAt": "2019-10-14T15:19:21Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMzc2NTU0",
          "commit": {
            "abbreviatedOid": "07fc683"
          },
          "author": "cjpatton",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-14T15:20:59Z",
          "updatedAt": "2019-10-14T15:21:00Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "I would double check with Benjamin Lipp, just to be 100% we're interpreting his result correctly. (He's the lead author on the WireGuard analysis.)",
              "createdAt": "2019-10-14T15:21:00Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxMzc3NjU5",
          "commit": {
            "abbreviatedOid": "07fc683"
          },
          "author": "cjpatton",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Looks good. Though I would double check with Benjamin Lipp about interpretation of his result for HKDF, just to be on the safe side.",
          "createdAt": "2019-10-14T15:22:48Z",
          "updatedAt": "2019-10-14T15:22:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxNTQ2MTA5",
          "commit": {
            "abbreviatedOid": "07fc683"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks @cjpatton for your comments on the draft.",
          "createdAt": "2019-10-14T21:19:51Z",
          "updatedAt": "2019-10-14T21:19:51Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA1NjMzNDA0",
          "commit": {
            "abbreviatedOid": "03d7ad2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for driving this forward! And thanks to @blipp and @cjpatton for their help.",
          "createdAt": "2019-10-23T05:01:16Z",
          "updatedAt": "2019-10-23T05:02:48Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Since we don't define indifferentiability framework here, might it make sense to say something such as, \"As Ristenpart et al. discuss in {{RSS11}}, however, security proofs in the Random Oracle model may not always hold when such functions are replaced with indifferentiable counterpart,\" or something? (That is, perhaps unroll the meaning of the framework inline so readers don't have to look at RSS11.)",
              "createdAt": "2019-10-23T05:01:16Z",
              "updatedAt": "2019-10-23T17:00:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2MDQ1OTg4",
          "commit": {
            "abbreviatedOid": "a36792d"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-23T17:00:41Z",
          "updatedAt": "2019-10-23T17:00:42Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Good call! Better now?",
              "createdAt": "2019-10-23T17:00:42Z",
              "updatedAt": "2019-10-23T17:00:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2MTUwODY0",
          "commit": {
            "abbreviatedOid": "a36792d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-23T19:56:36Z",
          "updatedAt": "2019-10-23T19:56:36Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Yep \u2014 perfect!",
              "createdAt": "2019-10-23T19:56:36Z",
              "updatedAt": "2019-10-23T19:56:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2MjExMTg3",
          "commit": {
            "abbreviatedOid": "a36792d"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-23T21:45:56Z",
          "updatedAt": "2019-10-23T21:45:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 172,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMwNzk4NDU4",
      "title": "update Z selection, add pseudocode, promote SvdW map",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/172",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR updates the Z selection criteria to [avoid patent infringement](https://mailarchive.ietf.org/arch/msg/cfrg/jV4Wr4fbMKkd4vzsbEhKbous16Y) for S-SWU, and to add Sage scripts for generating parameters.\r\n\r\nI've also promoted the S-vdW map (using the more general parameterization, rather than the one in #167, which has issues I pointed out there), rewritten the pseudocode, etc.\r\n\r\nOne change from the prior version of this document is that this version no longer tries to establish a canonical Z. Rather, it gives the criteria, and then gives a Sage script for computing the RECOMMENDED Z.",
      "createdAt": "2019-10-22T04:24:01Z",
      "updatedAt": "2019-10-26T19:17:16Z",
      "closedAt": "2019-10-26T19:16:27Z",
      "mergedAt": "2019-10-26T19:16:27Z",
      "mergedBy": "kwantam",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "~~OK, this is very close to ready to go @chris-wood @armfazh.~~\r\n\r\n~~I'm going to look at it again with fresh eyes, check the pseudocode against a Sage impl, and update all the ciphersuites as follows:~~ Done!\r\n- [x] add suites for SW map\r\n- [x] update Z for all maps to correspond to the newest requirements\r\n\r\nI should be able to push this tomorrow.",
          "createdAt": "2019-10-23T04:06:30Z",
          "updatedAt": "2019-10-25T04:22:12Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh I think [this message](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/170#issuecomment-545649584) mostly pertains to this PR, so let's move conversation here.\r\n\r\nI'd be glad to look at details of the parameterization you're working on. I guess the main questions from this PR's point of view should be whether it's simpler and whether it will work in (almost) all cases.\r\n\r\nFrom my perspective, we probably shouldn't spend too much time honing this map since it's mostly a fallback...",
          "createdAt": "2019-10-23T21:54:09Z",
          "updatedAt": "2019-10-23T21:54:09Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes my comment should be posted in this thread.\r\nSo I also agree with this PR too. ",
          "createdAt": "2019-10-23T21:57:47Z",
          "updatedAt": "2019-10-23T21:57:47Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, from my perspective this is now good to go.\r\n\r\nHow about let's not wait on ePrinting the SvdW parameterization, since it'll take a few days for it to appear on ePrint and we can come back and change the URL later. This will let us get the other PRs done.",
          "createdAt": "2019-10-25T04:23:07Z",
          "updatedAt": "2019-10-25T04:23:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA1NjM0NDYx",
          "commit": {
            "abbreviatedOid": "ebe50fc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-23T05:06:21Z",
          "updatedAt": "2019-10-23T05:08:54Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Is there any chance you can put this on ePrint? (The current link doesn't work, so I can't review the rest of the PR!)",
              "createdAt": "2019-10-23T05:06:21Z",
              "updatedAt": "2019-10-26T19:13:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2MDQ3NjQw",
          "commit": {
            "abbreviatedOid": "ebe50fc"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-23T17:03:26Z",
          "updatedAt": "2019-10-23T17:03:27Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I can, though there will be some delay before it's accepted (probably makes sense as a way of documenting, though, so I'll plan to do this before we merge this PR)\r\n\r\nThe PDF is included in this PR, or you can find the same file at https://github.com/kwantam/draft-irtf-cfrg-hash-to-curve/raw/generalized_svdw/svdw_general.pdf\r\n",
              "createdAt": "2019-10-23T17:03:27Z",
              "updatedAt": "2019-10-26T19:13:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2MjE2NDc4",
          "commit": {
            "abbreviatedOid": "ebe50fc"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-23T21:57:57Z",
          "updatedAt": "2019-10-23T21:57:57Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2MjE2Nzkw",
          "commit": {
            "abbreviatedOid": "ebe50fc"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-23T21:58:44Z",
          "updatedAt": "2019-10-23T21:58:44Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Do you have a latex source for me to make a PR for that document?",
              "createdAt": "2019-10-23T21:58:44Z",
              "updatedAt": "2019-10-26T19:13:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2NzY1MTYx",
          "commit": {
            "abbreviatedOid": "8d8b974"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T18:06:18Z",
          "updatedAt": "2019-10-24T18:06:18Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "The source isn't public right now because it relies on some LaTeX sources that I haven't scrubbed for release. If the proposed edits are small, we can probably handle them in this thread. If you don't think that will work, I'll need to spend some time to make a version of the sources that I can make public.",
              "createdAt": "2019-10-24T18:06:18Z",
              "updatedAt": "2019-10-26T19:13:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NDc2MDIx",
          "commit": {
            "abbreviatedOid": "a9598ef"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-25T22:16:31Z",
          "updatedAt": "2019-10-25T22:18:25Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "```suggestion\r\n21.  e2 = is_square(gx2) AND NOT e1     // avoid short-circuit logic ops\r\n```",
              "createdAt": "2019-10-25T22:16:32Z",
              "updatedAt": "2019-10-26T19:13:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 175,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMyNzk0MTI5",
      "title": "requirements and guidelines for alternative hash_to_base functions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/175",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This patch gives guidance on how to define a new hash_to_base function and use it\r\nin a way that won't interfere with existing suites.\r\n\r\ncloses #165 ",
      "createdAt": "2019-10-26T19:22:48Z",
      "updatedAt": "2019-10-30T21:29:13Z",
      "closedAt": "2019-10-30T16:29:51Z",
      "mergedAt": "2019-10-30T16:29:50Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "We *could* add an appendix with a hash_to_base from cSHAKE-128 and/or cSHAKE-256,\r\nbut that might be overkill. Thoughts?",
          "createdAt": "2019-10-26T19:22:58Z",
          "updatedAt": "2019-10-26T19:22:58Z"
        },
        {
          "author": "JustinDrake",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> that might be overkill. Thoughts?\r\n\r\nAgreed :)",
          "createdAt": "2019-10-26T20:28:57Z",
          "updatedAt": "2019-10-26T20:28:57Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "iiuc, ( something might be inaccurate in my description)\r\n\r\nat a higher level, one can think that hash_to_base requires two functions: a hash function H1 and a pseudo-random function H2.\r\n\r\nit would be better to give a description of hash_to_base in terms of H1, H2; and give criteria to choose H1 and H2. This is in some sense already included, but it might be clear for a reader having a notion that 2 functions are required.\r\n\r\nAlso, the ciphersuite can contain another field indicating this choice.\r\n```\r\nCURVE_ID ' -' HASH_ID '-' PRF_ID '-' MAP_ID '-' ENC_ID '-' \r\n```\r\nSome examples:\r\nP256-SHA256-HKDF-SSWU-RO\r\nP256-SHA256-KMAC-SSWU-RO\r\nP256-SHA3256-HKDF-SSWU-RO\r\n\r\nAs side comment: the ciphersuite string is starting to look as a C-struct or a configuration file rather than a unique identifier.\r\n\r\n",
          "createdAt": "2019-10-29T00:09:26Z",
          "updatedAt": "2019-10-29T00:09:26Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> at a higher level, one can think that hash_to_base requires two functions:\r\n> a hash function H1 and a pseudo-random function H2.\r\n\r\nThis would be a nice thought, but I don't think it's possible to generalize in the way you've stated without putting unnecessary restrictions on alternative hash-to-base functions. The reason is that in general it's not even true that hash_to_base requires H1 and H2!\r\n\r\nAs a few examples:\r\n\r\n- How would you describe the current hash-to-base in terms of these two functions? We might be tempted to say that HKDF is H2 and (e.g.) SHA-256 is H1, but that doesn't work because there's no clean decomposition between HKDF and SHA-256---the former is built in terms of the latter.\r\n\r\n- We might instead be tempted to say that H2 is somehow parameterized over H1, but that *also* doesn't work, because then what would H1 be when H2 = KMAC128? I don't see any sensible assignment to H1 in that case, because KMAC isn't parameterized over a hash function at all.\r\n\r\n- What about the case where someone wants to use HMAC to combine msg, ctr, and DST, then somehow use the result as an AES key? But HMAC can't be H1 because it's not a hash, and AES can't be H2 because it's a PRG, not a PRF (using the distinction discussed above, from [K10](https://eprint.iacr.org/2010/265)).\r\n\r\nBacking up: **the point of this section is not to try and teach someone how to make up their own hash_to_base function**. The one we've got took a good bit of work to get to this point, and there are a lot of subtleties in designing a replacement. The point is to state the high-level *requirements*, and to show how to use it in a way that won't mess up security or interoperability for people using the hash_to_base function given in this document.\r\n\r\n---\r\n\r\nEDIT to add:\r\n\r\n>  P256-SHA256-KMAC-SSWU-RO\r\n\r\nRight, so this is an example of my second bullet above: KMAC doesn't work with SHA-256; it's not parameterized in terms of anything, it's built directly out of the Keccak sponge...\r\n\r\n(~~This also means, admittedly, that the current example of KMAC128 in the HASH_ID field in Suites isn't perfect. I'm not convinced that matters so much there since it's only intended to illustrate how to construct the field, but I'll think about whether there's something better to be said.~~ Fixed.)",
          "createdAt": "2019-10-29T00:25:55Z",
          "updatedAt": "2019-10-29T00:38:12Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think @kwantam's comment above cleared this up, so I'm merging for now. @armfazh please file a separate issue if you think this section needs more work!",
          "createdAt": "2019-10-30T16:29:46Z",
          "updatedAt": "2019-10-30T16:29:46Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTQzMTU1",
          "commit": {
            "abbreviatedOid": "f762e57"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-26T20:47:20Z",
          "updatedAt": "2019-10-26T21:23:59Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "```suggestion\r\n  It is RECOMMENDED to follow the guidelines for controlling bias\r\n```",
              "createdAt": "2019-10-26T20:47:20Z",
              "updatedAt": "2019-10-29T00:37:51Z"
            },
            {
              "originalPosition": 105,
              "body": "A possible clarification:\r\n\r\n```\r\nThe hash\\_to\\_base function is suitable for use with a wide range of hash functions,\r\nincluding SHA-2 {{FIPS180-4}}, SHA-3 {{FIPS202}}, BLAKE2 {{!RFC7963}}, and others.\r\nIn some cases, however, implementors may wish to replace the HKDF-based function\r\ndefined in this section with one that uses a different underlying pseudorandom generator.\r\n(The function in this section uses HKDF-Expand as a variable-length pseudorandom function\r\nsince it accepts an additional context parameter as input. In practice, however, any pseudorandom\r\ngenerator would suffice provided context strings are supported.) Examples of different\r\npseudorandom functions include extendable-output functions like cSHAKE {{SP.800-185}}\r\nor BLAKE2X {{BLAKE2X}}.\r\n```\r\n\r\nI think this aligns the PRF vs PRG distinction that Hugo makes in his paper, and I hope avoids confusion. (Some readers might observe that HKDF-Expand is a PRF whereas we now refer to it as PRG.)",
              "createdAt": "2019-10-26T21:23:40Z",
              "updatedAt": "2019-10-29T00:37:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTQ3NjIz",
          "commit": {
            "abbreviatedOid": "f594d29"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-26T23:23:57Z",
          "updatedAt": "2019-10-26T23:23:58Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "You're right, I was sloppy. We should probably use PRF throughout. Let me try again... :)",
              "createdAt": "2019-10-26T23:23:57Z",
              "updatedAt": "2019-10-29T00:37:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTQ5Mjc2",
          "commit": {
            "abbreviatedOid": "06ccf38"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-27T00:39:35Z",
          "updatedAt": "2019-10-27T00:39:35Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "OK, I've pushed some clarifications.\r\n\r\nOne major change is that the section does not recommend any particular primitives, because it seems like not a great idea to recommend something unless we're quite sure it will work.\r\n\r\n(For example, thinking about it more, I think KMAC is a better option than cSHAKE---so I changed the one remaining example in the Suites section.)",
              "createdAt": "2019-10-27T00:39:35Z",
              "updatedAt": "2019-10-29T00:37:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTQ5MzY2",
          "commit": {
            "abbreviatedOid": "06ccf38"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The latest changes LGTM!",
          "createdAt": "2019-10-27T00:42:31Z",
          "updatedAt": "2019-10-27T00:42:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 176,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMyNzk2NTEw",
      "title": "make sgn0 definition per-suite ; improve descriptions of sgn0 and sqrt functions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/176",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This patch does three (roughly) related things:\r\n\r\n1. It defines two variants of sgn0, \"little endian\" (LE) and \"big endian\" (BE).\r\n  - LE is a generalization of IEEE P1363a-2004 Section 5.5.6.1.1, ANSI X9.62-1998, Section 4.2.1, and [SEC 1 Section 2.3.3](https://secg.org/sec1-v2.pdf). (All three of these use the same notion of sign: the value of the least significant bit.)\r\n      \r\n      This is the notion of sign used by most widely-deployed curves. For example, it's the one specified in RFC 8032 (Sections 5.1.3 and 5.2.3) and the one used in TLS (per [RFC 4492, Section 5.1.2](https://tools.ietf.org/html/rfc4492#section-5.1.2)).\r\n\r\n  - BE is equivalent to the method given in IEEE P1363a-2004, Section 5.5.6.1.2.\r\n\r\n      This is the form used by [BLS12-381](https://github.com/zkcrypto/pairing/blob/master/src/bls12_381/README.md), and is the same as what we used to call sgn0.\r\n\r\n2. It adds a sgn0 parameter to each suite that specifies which sgn0 function to use. All suites use sgn0_le except BLS12-381, which corresponds with widely-used notions of sign for each curve.\r\n\r\n3. It clarifies the sqrt functions and gives a constant-time version of Tonelli-Shanks (which works for any p) due to Sean Bowe, Jack Grigg, Eirik Ogilvie-Wigley, and Michael Scott. It also moves these to the appendix, since we treat sqrt as non-normative (in particular, we don't care about how implementors compute the sign).",
      "createdAt": "2019-10-26T19:57:12Z",
      "updatedAt": "2019-10-30T21:29:06Z",
      "closedAt": "2019-10-30T16:30:12Z",
      "mergedAt": "2019-10-30T16:30:12Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "(Rebased on new master)",
          "createdAt": "2019-10-27T02:19:56Z",
          "updatedAt": "2019-10-27T02:19:56Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased again. Phew!",
          "createdAt": "2019-10-27T05:54:43Z",
          "updatedAt": "2019-10-27T05:54:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTQ0NzQ1",
          "commit": {
            "abbreviatedOid": "24e1fd0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-10-26T21:33:34Z",
          "updatedAt": "2019-10-26T21:41:47Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "```suggestion\r\nOther sgn0 variants are possible, but the two given below cover\r\n```",
              "createdAt": "2019-10-26T21:33:35Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            },
            {
              "originalPosition": 163,
              "body": "```suggestion\r\ncommonly used notions of sign.\r\n```",
              "createdAt": "2019-10-26T21:33:51Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            },
            {
              "originalPosition": 166,
              "body": "```suggestion\r\nIt is RECOMMENDED to select the variant that matches the point decompression\r\n```",
              "createdAt": "2019-10-26T21:34:06Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            },
            {
              "originalPosition": 173,
              "body": "```suggestion\r\nsign, since this may permit simpler implementations.\r\n```",
              "createdAt": "2019-10-26T21:34:38Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            },
            {
              "originalPosition": 484,
              "body": "Can we drop a reference for this somewhere?",
              "createdAt": "2019-10-26T21:38:10Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            },
            {
              "originalPosition": 516,
              "body": "`b_is_good` is unused (looks like it should replace `tmp` below!)",
              "createdAt": "2019-10-26T21:38:49Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            },
            {
              "originalPosition": 77,
              "body": "Hmm, the version of TS in that file seems to only work for certain values of `p`, unless I'm misreading?",
              "createdAt": "2019-10-26T21:41:44Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTQ5NDY3",
          "commit": {
            "abbreviatedOid": "7ecb071"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-27T00:46:34Z",
          "updatedAt": "2019-10-27T00:46:35Z",
          "comments": [
            {
              "originalPosition": 516,
              "body": "argh, great catch.",
              "createdAt": "2019-10-27T00:46:35Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTQ5NTE5",
          "commit": {
            "abbreviatedOid": "3c123b5"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-27T00:49:28Z",
          "updatedAt": "2019-10-27T00:49:28Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "It really does work for any value of p. I think the point is that they only use it for p = 1 mod 16 because otherwise there are the faster special-purpose versions.\r\n\r\n(I confirmed this with Michael Scott, too.)",
              "createdAt": "2019-10-27T00:49:28Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTQ5NTY3",
          "commit": {
            "abbreviatedOid": "3c123b5"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-27T00:51:35Z",
          "updatedAt": "2019-10-27T00:51:36Z",
          "comments": [
            {
              "originalPosition": 484,
              "body": "To clarify: do you mean cite the zcash codebase? Happy to do it, though it's possible the link won't age well... :)",
              "createdAt": "2019-10-27T00:51:36Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTQ5NzI4",
          "commit": {
            "abbreviatedOid": "3c123b5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-27T01:00:27Z",
          "updatedAt": "2019-10-27T01:00:27Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "\ud83d\udc4d got it -- the comment in their code was just a bit misleading. Thanks!",
              "createdAt": "2019-10-27T01:00:27Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTQ5NzM3",
          "commit": {
            "abbreviatedOid": "3c123b5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-27T01:00:55Z",
          "updatedAt": "2019-10-27T01:00:56Z",
          "comments": [
            {
              "originalPosition": 484,
              "body": "I'm just trying to give credit where credit is due, though, yeah, not sure how to do that here... :-\\",
              "createdAt": "2019-10-27T01:00:55Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTUwMTE5",
          "commit": {
            "abbreviatedOid": "707be34"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-27T01:18:06Z",
          "updatedAt": "2019-10-27T01:18:07Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "We probably could make `m=2` for this example -- there's three redundant zeros!",
              "createdAt": "2019-10-27T01:18:06Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTUwODI4",
          "commit": {
            "abbreviatedOid": "aa2e077"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-27T01:53:18Z",
          "updatedAt": "2019-10-27T01:53:18Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Good point!",
              "createdAt": "2019-10-27T01:53:18Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTUwODk5",
          "commit": {
            "abbreviatedOid": "eb99c63"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-27T01:56:39Z",
          "updatedAt": "2019-10-27T01:56:39Z",
          "comments": [
            {
              "originalPosition": 484,
              "body": "Makes sense! Even if the link dies, it's better to have than not.\r\n\r\nOK now?",
              "createdAt": "2019-10-27T01:56:39Z",
              "updatedAt": "2019-10-27T05:52:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA4MDgzNTYx",
          "commit": {
            "abbreviatedOid": "28961d5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-28T19:08:25Z",
          "updatedAt": "2019-10-28T19:08:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 177,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMyODE1OTUz",
      "title": "Style nits.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/177",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I combed the document for #105. It all looks good! Though I did notice a couple other inconsistencies and fixed them here.",
      "createdAt": "2019-10-27T01:33:42Z",
      "updatedAt": "2019-10-27T02:08:57Z",
      "closedAt": "2019-10-27T02:08:57Z",
      "mergedAt": "2019-10-27T02:08:57Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Just one tiny thing that's my fault!\r\n\r\nEagle eye!",
          "createdAt": "2019-10-27T02:00:56Z",
          "updatedAt": "2019-10-27T02:00:56Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good to me. Shall we merge, or do you want to handle #110 here, too?",
          "createdAt": "2019-10-27T02:08:18Z",
          "updatedAt": "2019-10-27T02:08:18Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's merge, keeping PRs small.",
          "createdAt": "2019-10-27T02:08:53Z",
          "updatedAt": "2019-10-27T02:08:53Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTUwOTk3",
          "commit": {
            "abbreviatedOid": "b69e2b0"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Just one tiny thing that's my fault!",
          "createdAt": "2019-10-27T01:59:43Z",
          "updatedAt": "2019-10-27T02:00:09Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "```suggestion\r\n3.   xd = t1 + 1              // Nonzero: -1 is square mod p, t1 is not\r\n```\r\n\r\nOops! I think that was my typo :)",
              "createdAt": "2019-10-27T01:59:44Z",
              "updatedAt": "2019-10-27T02:00:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTUxMDg5",
          "commit": {
            "abbreviatedOid": "a3df87b"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-27T02:04:19Z",
          "updatedAt": "2019-10-27T02:04:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 178,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMyODE3MTA3",
      "title": "fix p256 map in appx for new Z value in suites",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/178",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also updated the sage impl and tested to make sure it's correct.",
      "createdAt": "2019-10-27T02:00:45Z",
      "updatedAt": "2019-10-27T02:03:21Z",
      "closedAt": "2019-10-27T02:02:06Z",
      "mergedAt": "2019-10-27T02:02:06Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTUxMDQ4",
          "commit": {
            "abbreviatedOid": "e00dfc5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-27T02:01:51Z",
          "updatedAt": "2019-10-27T02:01:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 179,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMyODE4NjI1",
      "title": "consistency: (mod N) in parens",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/179",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Very tiny consistency issue I noticed.\r\n\r\nI guess we could go the other way and get rid of the parens... what looks better to you?",
      "createdAt": "2019-10-27T02:32:37Z",
      "updatedAt": "2019-10-27T05:44:49Z",
      "closedAt": "2019-10-27T03:01:28Z",
      "mergedAt": "2019-10-27T03:01:28Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm used to seeing parentheses. Does this cover all of them, including ones in pseudocode? I see it without parens in the hash_to_base definition, for example. A couple other spots I noticed:\r\n\r\n- `mod 2^255 - 19`\r\n- `Nonzero: -1 is square mod p, xd is not`",
          "createdAt": "2019-10-27T02:48:55Z",
          "updatedAt": "2019-10-27T02:48:55Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Oops! Thanks---I'll fix these later tonight. :+1:\n\nOn Sat, Oct 26, 2019, 7:49 PM Christopher Wood <notifications@github.com>\nwrote:\n\n> *@chris-wood* requested changes on this pull request.\n>\n> I think a couple were missed!\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/179?email_source=notifications&email_token=AAFO6MMGREOG4HZKFNHJD6DQQT6SJA5CNFSM4JFPXHP2YY3PNVWWK3TUL52HS4DFWFIHK3DMKJSXC5LFON2FEZLWNFSXPKTDN5WW2ZLOORPWSZGOCJKN5IA#pullrequestreview-307551904>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAFO6MJLO42GT5MKAHFT3UTQQT6SJANCNFSM4JFPXHPQ>\n> .\n>\n",
          "createdAt": "2019-10-27T02:57:15Z",
          "updatedAt": "2019-10-27T02:57:15Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I can just fix it here :-) Done and merged!",
          "createdAt": "2019-10-27T03:01:53Z",
          "updatedAt": "2019-10-27T03:01:53Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NTUxOTA0",
          "commit": {
            "abbreviatedOid": "d2e7947"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think a couple were missed!",
          "createdAt": "2019-10-27T02:49:07Z",
          "updatedAt": "2019-10-27T02:49:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 180,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMyODE5ODY3",
      "title": "More mods!",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/180",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-10-27T03:01:17Z",
      "updatedAt": "2019-10-27T03:01:27Z",
      "closedAt": "2019-10-27T03:01:27Z",
      "mergedAt": "2019-10-27T03:01:27Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": []
    },
    {
      "number": 182,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMyODgyNTkw",
      "title": "Clarifications around S-SWU map",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/182",
      "state": "CLOSED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a small cleanup:\r\n\r\n- Clarify some text regarding optimized S-SWU implementations.\r\n- Rename \"S-SWU for pairing-friendly\" to \"S-SWU for AB==0\", since it's not really limited to pairing-friendly curves.\r\n- Move the renamed S-SWU,AB==0 section to the Weierstrass subsection of the mappings section.",
      "createdAt": "2019-10-27T18:56:59Z",
      "updatedAt": "2019-10-28T18:33:21Z",
      "closedAt": "2019-10-28T18:27:39Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing and incorporating into #183, since the two are somewhat related.",
          "createdAt": "2019-10-28T18:27:38Z",
          "updatedAt": "2019-10-28T18:27:38Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 183,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMyOTA4MTMy",
      "title": "S-SWU clarifications; example code tests and fixes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/183",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "High-level summary: this PR adds Sage code that tests all of the example code in the document. In adding these tests, I found some bugs; this PR also fixes those. Details:\r\n\r\nThis PR does a few things related to the document's handling of S-SWU:\r\n\r\n- Clarify some text regarding optimized S-SWU implementations.\r\n- Rename \"S-SWU for pairing-friendly\" to \"S-SWU for AB==0\", since it's not really limited to pairing-friendly curves.\r\n- Move the renamed S-SWU,AB==0 section to the Weierstrass subsection of the mappings section.\r\n- Generalizes S-SWU example code for P-256 to any curve over p = 3 (mod 4), and forward refs from the relevant ciphersuites.\r\n- Makes the \"generic mapping\" approach used for the SvdW sage impl in #172 into a more general-purpose framework.\r\n- Implements the SSWU mapping in the generic mapping framework.\r\n- Parameterizes the optimized S-SWU sage impl.\r\n- Adds tests for the optimized vs. generic sage impl for P-256, P-384, P-521, secp256k1, and BLS12-381 G1.\r\n\r\nIn addition, it:\r\n\r\n- implements Elligator2 in the generic mapping framework discussed above\r\n- fixes bugs in the straight-line Elligator2 impl from Section 6\r\n- fixes bugs in the optimized Elligator2 and Edwards->Montgomery maps in the appendix\r\n- implements Elligator2 for Edwards curves in the generic mapping framework\r\n- fixes the straight-line Montgomery->Edwards mapping\r\n- implements Boneh-Franklin in the generic mapping framework\r\n- implements Elligator 2, A == 0 in the generic mapping framework\r\n\r\nAll of the bugs mentioned above are now tested in the Sage implementations of the optimized maps.",
      "createdAt": "2019-10-28T00:02:58Z",
      "updatedAt": "2019-10-31T21:28:27Z",
      "closedAt": "2019-10-31T21:26:08Z",
      "mergedAt": "2019-10-31T21:26:08Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "~~Hmm, we could also use the NIST sample impl as a sample impl for secp256k1. I'll update the text a bit later tonight.~~",
          "createdAt": "2019-10-28T00:11:37Z",
          "updatedAt": "2019-10-28T06:05:25Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "(Rebased onto master)",
          "createdAt": "2019-10-30T21:35:53Z",
          "updatedAt": "2019-10-30T21:35:53Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh thanks! :+1:",
          "createdAt": "2019-10-31T05:59:19Z",
          "updatedAt": "2019-10-31T05:59:19Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NTg5NzA2",
          "commit": {
            "abbreviatedOid": "58f5de4"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-31T00:06:28Z",
          "updatedAt": "2019-10-31T00:06:28Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "The reference [KSS08] is not used in the document",
              "createdAt": "2019-10-31T00:06:28Z",
              "updatedAt": "2019-10-31T05:44:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NTg5ODYw",
          "commit": {
            "abbreviatedOid": "58f5de4"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-31T00:07:00Z",
          "updatedAt": "2019-10-31T00:07:00Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "BLAKE has a wrong reference",
              "createdAt": "2019-10-31T00:07:00Z",
              "updatedAt": "2019-10-31T05:44:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NTk0NzU4",
          "commit": {
            "abbreviatedOid": "58f5de4"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-31T00:27:53Z",
          "updatedAt": "2019-10-31T00:27:53Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "```suggestion\r\n8.  y = y * y'\r\n```",
              "createdAt": "2019-10-31T00:27:53Z",
              "updatedAt": "2019-10-31T05:44:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NTk1NTQx",
          "commit": {
            "abbreviatedOid": "58f5de4"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-31T00:31:11Z",
          "updatedAt": "2019-10-31T00:31:12Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "```suggestion\r\n Output: (x, y), a point on an equivalent twisted Edwards curve.\r\n```",
              "createdAt": "2019-10-31T00:31:11Z",
              "updatedAt": "2019-10-31T05:44:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NjU3NzUz",
          "commit": {
            "abbreviatedOid": "58f5de4"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-31T05:39:47Z",
          "updatedAt": "2019-10-31T05:39:47Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Oops! Fixed the BLAKE reference, removed KSS08 from the bib (it isn't used on master either; we can bring it back if we need it later).",
              "createdAt": "2019-10-31T05:39:47Z",
              "updatedAt": "2019-10-31T05:44:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMTI2ODc4",
          "commit": {
            "abbreviatedOid": "b79dc33"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-31T19:21:19Z",
          "updatedAt": "2019-10-31T19:21:19Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMTkwNzI1",
          "commit": {
            "abbreviatedOid": "b79dc33"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I haven't checked the scripts entirely, but the main text is ok. \r\n",
          "createdAt": "2019-10-31T21:24:10Z",
          "updatedAt": "2019-10-31T21:24:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 184,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM0NTYzNjAw",
      "title": "domain separation requirement: simplify",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/184",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Slight text improvement in the DST section, I think.",
      "createdAt": "2019-10-30T23:09:44Z",
      "updatedAt": "2019-10-31T17:05:55Z",
      "closedAt": "2019-10-30T23:10:34Z",
      "mergedAt": "2019-10-30T23:10:34Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NTczODQ3",
          "commit": {
            "abbreviatedOid": "280da44"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-30T23:10:29Z",
          "updatedAt": "2019-10-30T23:10:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 185,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM1MTc0NzE3",
      "title": "howtos: using the document, picking a mapping, creating a suite",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/185",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds some text to make the document a bit more friendly:\r\n\r\n- in the intro, \"how to use this document\"\r\n- in the mappings section, \"how to pick a map for a given curve\"\r\n- in the suites section, \"how to define a new suite\"\r\n\r\nThese are pretty brief, but I think they'll make things a bit clearer.",
      "createdAt": "2019-10-31T21:53:31Z",
      "updatedAt": "2019-11-01T19:47:11Z",
      "closedAt": "2019-11-01T19:40:26Z",
      "mergedAt": "2019-11-01T19:40:26Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "The last commit in this PR changes variable names like `x', y'` and `x'', y''` to names like `s, t` and `v, w`. This makes things significantly easier to read (in my opinion), which is nice. I need to run away for a bit, but I'm going to take a careful pass over the document and make sure I've got the variables named correctly everywhere (and more eyes on this would be appreciated!)\r\n\r\nIn particular, I've tried to follow the convention that Weierstrass curves use `x, y`, Montgomery curves use `s, t`, and Edwards curves use `v, w`. I know that in other contexts `u, v` is preferred, but we use `u` throughout the document as the input to mapping functions, and I wanted to avoid confusion.",
          "createdAt": "2019-10-31T22:40:31Z",
          "updatedAt": "2019-10-31T22:42:29Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> However, there is now a clash in the Interface and Notation sections.\r\n\r\nThanks for the super detailed comments! :+1:\r\n\r\nIt's true that there is a very small clash, in the case of the twisted Edwards maps. (Everything else---including Elligator---is actually working on a Weierstrass curve.) It's a very small thing, and I don't think it will cause confusion, but I will think about how we can resolve it.\r\n\r\n--\r\n\r\nEDIT: added a quick parenthetical in the one spot where there's a notational weirdness.",
          "createdAt": "2019-11-01T06:13:29Z",
          "updatedAt": "2019-11-01T06:25:54Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "One other action item for me before we merge this PR is to copy-paste all of the rational map specs into sage and make sure that they work correctly. I'll do this tomorrow.",
          "createdAt": "2019-11-01T06:48:28Z",
          "updatedAt": "2019-11-01T06:48:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh are you OK with the changes? ",
          "createdAt": "2019-11-01T17:11:51Z",
          "updatedAt": "2019-11-01T17:11:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjYwMDgy",
          "commit": {
            "abbreviatedOid": "4ad1160"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for the clarifying notation and guidance! I only have on comment on content. I'd like to hear from @armfazh before we merge.",
          "createdAt": "2019-11-01T01:51:54Z",
          "updatedAt": "2019-11-01T01:53:21Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "I wonder if this paragraph is needed, or if it can be replaced with something a bit lighter, e.g., \"Note that the Shallue-van de Woestijne method ({{svdw}}) works with any curve and may be used in cases where a specific curve is not targeted.\" I read this as sort of recommending this as a viable alternative, which I don't think is a goal. Rather, targeting specific curves seems best. @armfazh, what do you think?",
              "createdAt": "2019-11-01T01:51:54Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjgwMzE5",
          "commit": {
            "abbreviatedOid": "4ad1160"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I general I liked to use different pair (x,y) for denoting a point, it makes more clear to read when referring to different models. However, there is now a clash in the Interface and Notation sections.\r\n\r\nAlso, I left other comments concerning to the readability of the document.  ",
          "createdAt": "2019-11-01T03:43:26Z",
          "updatedAt": "2019-11-01T05:18:04Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "recommending the implementation of test vectors is not the main objective of this document. This paragraph adds few information.",
              "createdAt": "2019-11-01T03:43:26Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 4,
              "body": "The important thing that must be presented in the Introduction is the purpose of the document, basically it\r\n1) shows how to perform hashing to elliptic curve points, \r\n2) proposes two encodings with different statistical properties,\r\n3) describes how to construct a ciphersuite for hashing, and \r\n4) recommends ciphersuites for well-known curves.\r\n\r\n",
              "createdAt": "2019-11-01T03:52:30Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 6,
              "body": "There shouldn't be specific distinctions, our audience is  _anyone_ who wants to hash a string into a point.\r\nSo I feel that these paragraphs do not focus on the high level speech required at the Introduction section.",
              "createdAt": "2019-11-01T03:56:17Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 4,
              "body": "I consider that the how-to section is the roadmap section, which could be renamed if needs to be clearer.",
              "createdAt": "2019-11-01T04:25:27Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 53,
              "body": "```suggestion\r\n As an example, consider a fictional protocol named Quux\r\n```",
              "createdAt": "2019-11-01T04:30:37Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 42,
              "body": "I missed why should be at least 8 bytes. ",
              "createdAt": "2019-11-01T04:32:06Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 59,
              "body": "This could be said using a more natural language. Something like this : \"Each mapping produces a different set of points\" ",
              "createdAt": "2019-11-01T04:41:55Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 57,
              "body": "```suggestion\r\n or random oracle encodings using the constructions of {{roadmap}}.\r\n Certain mappings restrict the form of the curve or its parameters.\r\n For each mapping presented, this document lists the relevant restrictions.\r\n```",
              "createdAt": "2019-11-01T04:42:41Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 231,
              "body": "A shorter version can appear at section 6.0 or after Section 6.4, in which recommends the mapping to use according to the type of curve, and thus give forward pointers.\r\n",
              "createdAt": "2019-11-01T04:57:42Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 238,
              "body": "Reverse the order. first Weierstrass, -> Montgomery/Edwards, -> supersingular -> none of the above (Shallue-van de Woestijne)",
              "createdAt": "2019-11-01T04:59:23Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 258,
              "body": "I agree, it would be better to say \" use the Shallue-van de Woestijne mapping if none of the above mappings applies to your curve\" . ",
              "createdAt": "2019-11-01T05:01:17Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 290,
              "body": "```suggestion\r\n1. E, F, p, and m are determined by the elliptic curve and the field.\r\n```",
              "createdAt": "2019-11-01T05:08:25Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 294,
              "body": "```suggestion\r\n3. Choose a hash function H meeting the requirements in {{hashtobase-sec}},\r\n```",
              "createdAt": "2019-11-01T05:11:11Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 304,
              "body": "```suggestion\r\n6. Construct a Suite ID following the guidelines in {{suiteIDformat}}.\r\n```",
              "createdAt": "2019-11-01T05:12:29Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            },
            {
              "originalPosition": 306,
              "body": "it is not common to standardize curves. Using curves, on the other hand, is more often the case.",
              "createdAt": "2019-11-01T05:14:33Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjk5Mjg4",
          "commit": {
            "abbreviatedOid": "4ad1160"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T05:42:06Z",
          "updatedAt": "2019-11-01T05:42:07Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I understand your concern here, and it makes a lot of sense. That said, I added these paragraphs for a couple specific reasons:\r\n\r\n1. A couple people asked me to add them! The feedback was basically, \"this document is huge; is there some way to add a small section telling me how to begin implementing a hash-to-curve suite?\"\r\n\r\n2. Related to the above: my guess is that very few people will read the whole document end-to-end (or even close!). Rather, most people will read it either because they're specifying a new protocol or because they're implementing one, hence the quick \"getting started\"--style pointers geared towards those specific audiences.\r\n\r\nI think it would be great if lots of people read the document end to end! but adding this small section certainly won't discourage those people from reading, whereas people who just want to get in and out will really appreciate the quick pointers. Or, at least, that seems to be the case based on the feedback I've gotten recently.",
              "createdAt": "2019-11-01T05:42:06Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjk5NjQx",
          "commit": {
            "abbreviatedOid": "4ad1160"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T05:44:11Z",
          "updatedAt": "2019-11-01T05:44:11Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "These are good points, and in general I agree. See [my comment](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/185#discussion_r341457421) below, though: I think adding something along the lines of these two paragraphs will make it easier for people to use the document. And, importantly, having \"how to use this document\" right up front will make it easier to find, and thus more useful.",
              "createdAt": "2019-11-01T05:44:11Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjk5NjU3",
          "commit": {
            "abbreviatedOid": "4ad1160"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T05:44:19Z",
          "updatedAt": "2019-11-01T05:44:20Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Good point. I'll remove this.",
              "createdAt": "2019-11-01T05:44:20Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjk5OTYw",
          "commit": {
            "abbreviatedOid": "4ad1160"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T05:46:12Z",
          "updatedAt": "2019-11-01T05:46:12Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Hmm, I was looking at some old notes earlier and had this as a TODO item, but now that I go back and double check it, I think you're right. I'll remove the minimum size.",
              "createdAt": "2019-11-01T05:46:12Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzAwODQ4",
          "commit": {
            "abbreviatedOid": "4ad1160"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T05:51:02Z",
          "updatedAt": "2019-11-01T05:51:02Z",
          "comments": [
            {
              "originalPosition": 238,
              "body": "Hmmm.... I'm not sure I understand how this suggestion would work.\r\n\r\nSpecifically, I think going from least specific (Weierstrass) to most specific (supersingular) would be confusing, and would lead people to make incorrect decisions. The reason for the current ordering is that it presents effectively a simple decision tree: the most specific cases should come *first*, and then other cases \"fall through.\"",
              "createdAt": "2019-11-01T05:51:02Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzAxMDY3",
          "commit": {
            "abbreviatedOid": "4ad1160"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T05:52:12Z",
          "updatedAt": "2019-11-01T05:52:12Z",
          "comments": [
            {
              "originalPosition": 306,
              "body": "You're totally right that it's not common! That said, I think it's a *good* thing to recommend that people standardizing curves generate their own hash-to-curve suites. No? Is there a reason not to include this suggestion?",
              "createdAt": "2019-11-01T05:52:12Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzAxMjA0",
          "commit": {
            "abbreviatedOid": "4ad1160"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T05:52:56Z",
          "updatedAt": "2019-11-01T05:52:56Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Good point! Edited.",
              "createdAt": "2019-11-01T05:52:56Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzA0NzY1",
          "commit": {
            "abbreviatedOid": "bafe982"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T06:11:31Z",
          "updatedAt": "2019-11-01T06:11:32Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "OK, I pushed an edit that tones this down as suggested. Better?",
              "createdAt": "2019-11-01T06:11:32Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzA1NDgx",
          "commit": {
            "abbreviatedOid": "bafe982"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T06:15:09Z",
          "updatedAt": "2019-11-01T06:15:09Z",
          "comments": [
            {
              "originalPosition": 231,
              "body": "Yeah, I think you're totally right that it's best if it lives at the top of 6 rather than the bottom.",
              "createdAt": "2019-11-01T06:15:09Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzA4MDc2",
          "commit": {
            "abbreviatedOid": "f661bfb"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T06:28:31Z",
          "updatedAt": "2019-11-01T06:28:31Z",
          "comments": [
            {
              "originalPosition": 306,
              "body": "(Also note: this suggestion was in prior versions of the document---I just moved it here because it seemed to be the right place for it.)",
              "createdAt": "2019-11-01T06:28:31Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzExNDEx",
          "commit": {
            "abbreviatedOid": "2314366"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T06:43:47Z",
          "updatedAt": "2019-11-01T06:43:48Z",
          "comments": [
            {
              "originalPosition": 306,
              "body": "My point is that the suggestion must be broader, not only when someone is stardardizing a curve. \r\nThe suggestion could say something like :  \"anyone using a curve that is not listed in this document should generate a hash to curve method following this recommendation\"\r\n  ",
              "createdAt": "2019-11-01T06:43:47Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzExNjEx",
          "commit": {
            "abbreviatedOid": "2314366"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T06:44:39Z",
          "updatedAt": "2019-11-01T06:44:40Z",
          "comments": [
            {
              "originalPosition": 306,
              "body": "Ah, got it!",
              "createdAt": "2019-11-01T06:44:40Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzExNzUy",
          "commit": {
            "abbreviatedOid": "2314366"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T06:45:21Z",
          "updatedAt": "2019-11-01T06:45:22Z",
          "comments": [
            {
              "originalPosition": 238,
              "body": "I am fine with going from specific to general. I suggested to reverse the order to follow the order of the sections.\r\n ",
              "createdAt": "2019-11-01T06:45:22Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzEyMTM2",
          "commit": {
            "abbreviatedOid": "d5323ff"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T06:47:00Z",
          "updatedAt": "2019-11-01T06:47:01Z",
          "comments": [
            {
              "originalPosition": 238,
              "body": "Ah, got it. Yeah, I tried to do that for the same reason and it got really messy...",
              "createdAt": "2019-11-01T06:47:00Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzIwMjgy",
          "commit": {
            "abbreviatedOid": "d5323ff"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T07:22:33Z",
          "updatedAt": "2019-11-01T07:22:34Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Aligned to those requests, you can consider these paragraphs:\r\n\r\n```\r\nThis document covers a wide range of aspects regarding the security and implementation of hashing to elliptic curves. \r\n\r\nIn particular, protocol designers looking for a hashing method should either choose an existing suite or follow the guidelines to specify a new one (see {{new-suite}}). \r\nAlso, anyone implementing one of these methods could find more interesting going directly to Section X and Y that describe exact parameters for standard curves.\r\n\r\nIn brief summary, once an elliptic curve has been targeted, a hash-to-curve suite requires implementing an encoding function ({{roadmap}}), its constituent subroutines  ({{hashtobase}}, {{mappings}}, {{cofactor-clearing}}), and a few utility functions ({{utility}}).\r\n\r\nIn all cases, special attention is needed to handle domain separation {{domain-separation}}.\r\n```\r\n",
              "createdAt": "2019-11-01T07:22:34Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzIwNjAz",
          "commit": {
            "abbreviatedOid": "d5323ff"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T07:23:59Z",
          "updatedAt": "2019-11-01T07:23:59Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "The comments for the introduction section (those suggested in this thread) still apply.",
              "createdAt": "2019-11-01T07:23:59Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzIzOTg2",
          "commit": {
            "abbreviatedOid": "d5323ff"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T07:37:59Z",
          "updatedAt": "2019-11-01T07:37:59Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "The previous paragraph repeats almost the same words.\r\n",
              "createdAt": "2019-11-01T07:37:59Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNTc1NjIy",
          "commit": {
            "abbreviatedOid": "d5323ff"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T17:01:08Z",
          "updatedAt": "2019-11-01T17:01:08Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Hmm, I think I don't understand the difference between the proposed edit and what's there. The content is almost exactly the same, just presented in a different order. And whereas the version I proposed gives people actionable instructions (do this, then do this, then do that), the version here seems less clear in its purpose.\r\n\r\nSo maybe let's take a step back: what *precisely* is the objection to the current text? In other words, what does the above proposed edit fix? Because, as far as I can tell, the proposed edit no longer tells people \"how to use this document.\"",
              "createdAt": "2019-11-01T17:01:08Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNTc2OTU0",
          "commit": {
            "abbreviatedOid": "d5323ff"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T17:03:30Z",
          "updatedAt": "2019-11-01T17:03:31Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Maybe I've been unclear. The reason to add this text is that the document needs a friendly entry point that tells people what to do. The scenarios I'm trying to address with these two paragraphs are:\r\n\r\n1. Someone is implementing standard ABC, which says to use hash-to-curve suite XYZ and links to the hash-to-curve document. The implementor follows the link and ends up at this 60 page monster of a document, and has no idea what to do. \"How to use this document\" would tell that implementor, you need to implement this, this, this and this. Done.\r\n\r\n2. Someone is writing standard DEF, and needs a hash function to a curve. So they open the hash-to-curve document and start reading---and they just have no idea what to do. \"How to use this document\" would tell them to find or define a suite (see section X), decide on a domain separation tag, and you're done.\r\n\r\nThe key problem with the document in its current form is that both of the above use-cases require reading essentially the whole document. That should not be true.\r\n\r\nI'm happy to move this content to the roadmap section. Maybe that would help clear up some of these objections, though I still think it's less useful than if it were in the introduction.",
              "createdAt": "2019-11-01T17:03:31Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNTc3NDg4",
          "commit": {
            "abbreviatedOid": "d5323ff"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T17:04:33Z",
          "updatedAt": "2019-11-01T17:04:34Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Also would like to hear @chris-wood's opinion on putting \"howto\" in the intro vs in the roadmap.",
              "createdAt": "2019-11-01T17:04:33Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNTc5OTgx",
          "commit": {
            "abbreviatedOid": "d5323ff"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T17:09:37Z",
          "updatedAt": "2019-11-01T17:09:37Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "Yep, thanks!",
              "createdAt": "2019-11-01T17:09:37Z",
              "updatedAt": "2019-11-01T17:15:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNjQ2MTc1",
          "commit": {
            "abbreviatedOid": "74d94ac"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I am ok with these changes.",
          "createdAt": "2019-11-01T19:14:11Z",
          "updatedAt": "2019-11-01T19:14:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 186,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM1NjMyNzE4",
      "title": "fix errors in map appx ; add script to check maps",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/186",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Made a script and found a couple typos / errors in the maps appx. Phew!",
      "createdAt": "2019-11-01T21:54:37Z",
      "updatedAt": "2019-11-01T22:23:09Z",
      "closedAt": "2019-11-01T21:58:17Z",
      "mergedAt": "2019-11-01T21:58:17Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNzE0NjM0",
          "commit": {
            "abbreviatedOid": "2a8bf2d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-01T21:58:12Z",
          "updatedAt": "2019-11-01T21:58:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 187,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM1Njk5NTIw",
      "title": "add one more quick map check function",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/187",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This only adds a couple functions to poc/map_check.sage that might be useful in the future.",
      "createdAt": "2019-11-02T02:33:33Z",
      "updatedAt": "2019-11-03T04:41:07Z",
      "closedAt": "2019-11-02T14:04:09Z",
      "mergedAt": "2019-11-02T14:04:09Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNzcyMDA1",
          "commit": {
            "abbreviatedOid": "a6e8e8b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-02T14:04:04Z",
          "updatedAt": "2019-11-02T14:04:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 188,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM1OTkwNTY0",
      "title": "code cleanup ; implement suites",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/188",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR:\r\n\r\n- moves all old code (i.e., not based on the \"generic map\" concept) into `poc_old`\r\n\r\n- adds support for different sgn0 functions (sgn0_le and sgn0_be) in the generic map framework\r\n\r\n- adds a testing sqrt function that randomizes the returned sign (to ensure that all maps really don't care about sign)\r\n\r\n- brings in an implementation of hash_to_base (borrowed from kwantam/bls_sigs_ref, which has been thoroughly cross-checked against Rust and Python3 impls)\r\n\r\n- implements a generic h2c-suite framework (see `poc/h2c_suite.sage`)\r\n\r\n- implements \"native\" Montgomery and Edwards curve operations for cross-checking the suites (see `poc/curves.sage`)\r\n\r\n- implements all of the suites in the document using the above frameworks (see `poc/suite_*.sage`)",
      "createdAt": "2019-11-03T04:12:24Z",
      "updatedAt": "2019-11-20T03:49:47Z",
      "closedAt": "2019-11-17T03:35:05Z",
      "mergedAt": "2019-11-17T03:35:05Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, this is more or less ready for review.\r\n\r\nFrom here it's a pretty simple task (probably quick edits in `poc/h2c_suite.sage`) to output test vectors for any suite. I'm happy to do that in this PR or wait for another one. Thoughts?",
          "createdAt": "2019-11-05T07:22:09Z",
          "updatedAt": "2019-11-05T07:22:09Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "~~Probably should add a README (which would also handle #151) before merging~~ Done",
          "createdAt": "2019-11-05T07:22:56Z",
          "updatedAt": "2019-11-05T08:09:49Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Reorganized. This PR does not touch the document, only the code. I'll open a separate PR for the document.",
          "createdAt": "2019-11-05T16:39:25Z",
          "updatedAt": "2019-11-05T16:39:25Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the comments @armfazh! I've pushed responses.\r\n\r\n@chris-wood, shall we merge this now and then handle test vector generation in another PR? That way we can decide things like which DSTs to use, what inputs to use, etc. separately from the code changes.",
          "createdAt": "2019-11-16T21:42:58Z",
          "updatedAt": "2019-11-16T21:42:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "It'll take me a while to get through these changes, so in order to move things along let's just merge this now!",
          "createdAt": "2019-11-17T03:35:00Z",
          "updatedAt": "2019-11-17T03:35:00Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE0NTExMDE5",
          "commit": {
            "abbreviatedOid": "abf2af4"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "So far, I have reviewed these files:\r\n- common.sage\r\n- curves.sage\r\n- map_check.sage\r\n- hash_to_base.py\r\n- ell2_448_opt.sage\r\n- ell2_25519_opt.sage\r\n\r\nI pointed small nits and will continue my review.",
          "createdAt": "2019-11-08T23:28:18Z",
          "updatedAt": "2019-11-09T01:35:45Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "\r\n```suggestion\r\n    p = F.characteristic()\r\n```\r\n\r\n",
              "createdAt": "2019-11-08T23:28:19Z",
              "updatedAt": "2019-11-16T21:41:47Z"
            },
            {
              "originalPosition": 134,
              "body": "given `F = GF(p^m)`,  it should verify that `F.degree() is odd`",
              "createdAt": "2019-11-08T23:43:25Z",
              "updatedAt": "2019-11-16T21:41:47Z"
            },
            {
              "originalPosition": 14,
              "body": "In Line 34:  # https://eprint.iacr.org/2008/013\r\n",
              "createdAt": "2019-11-09T00:18:00Z",
              "updatedAt": "2019-11-16T21:41:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE1MDk2MTkz",
          "commit": {
            "abbreviatedOid": "abf2af4"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "one general recommendation is to make more explicit (for someone reading the code) that suites require of a DST parameter. For example, following the fictitious protocol `DST = \"QUUX-V<xx>-CS<yy>\"`.",
          "createdAt": "2019-11-11T19:06:44Z",
          "updatedAt": "2019-11-11T19:35:13Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "add a comment to recall the reader that Ap, Bp are parameters of the curve isogenous to E.",
              "createdAt": "2019-11-11T19:06:44Z",
              "updatedAt": "2019-11-16T21:41:47Z"
            },
            {
              "originalPosition": 25,
              "body": "How does L=64 was calculated?",
              "createdAt": "2019-11-11T19:08:51Z",
              "updatedAt": "2019-11-16T21:41:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3OTg5NTY3",
          "commit": {
            "abbreviatedOid": "abf2af4"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-16T21:22:36Z",
          "updatedAt": "2019-11-16T21:22:36Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "That's the value from the suite; it's calculated using the procedure described in the hash_to_base section. p = 381 bits, the curve gives ~128-bit security; 381 + 128 = 509. Ceil(509 / 8) = 64.",
              "createdAt": "2019-11-16T21:22:36Z",
              "updatedAt": "2019-11-16T21:41:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3OTkwMjE2",
          "commit": {
            "abbreviatedOid": "abf2af4"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-16T21:40:34Z",
          "updatedAt": "2019-11-16T21:40:35Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "Sorry, the above suggestion is not correct: it breaks the algorithm. Also, this algorithm works whether m is odd or even.",
              "createdAt": "2019-11-16T21:40:34Z",
              "updatedAt": "2019-11-16T21:41:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3OTkwMjQ4",
          "commit": {
            "abbreviatedOid": "abf2af4"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-16T21:41:10Z",
          "updatedAt": "2019-11-16T21:41:10Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "I have added tests for TS over p^2 and p^3 for random primes p in common.sage",
              "createdAt": "2019-11-16T21:41:10Z",
              "updatedAt": "2019-11-16T21:41:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 189,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2OTUzMDc0",
      "title": "clarifications in document",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/189",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR fixes and clarifies a few things:\r\n\r\n- resolves ambiguity in sign of a sqrt in SvdW high-level procedural description\r\n\r\n- remove pairing-friendly draft cite (we can't go to last call with an I-D ref per Nick)\r\n\r\n- update variable names in elliptic curve equations (again, this time I think is better) and make corresponding changes in `map_check.sage`\r\n\r\n- clean up unused stuff: abs(x) is not used, one of the constants in the optimized sswu impl is not used\r\n\r\n- notational consistency throughout\r\n\r\n- slightly improved discussion of indifferentiability\r\n\r\n- other minor touch-up issues\r\n\r\nSee next post for discussion of notation",
      "createdAt": "2019-11-05T19:42:38Z",
      "updatedAt": "2019-12-14T00:33:28Z",
      "closedAt": "2019-12-13T16:08:08Z",
      "mergedAt": "2019-12-13T16:08:08Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I chose variable names for the elliptic curve equations based on existing notation in the document. Here's what I compiled for current notational usage:\r\n\r\n| letter | use | letter | use |\r\n|:------:|------|:-------:|------|\r\n| a | Edwards coeff | A | short Weierstrass coeff |\r\n| b | | B | short Weierstrass coeff |\r\n| c | pcode const | C | long Weierstrass coeff (NEW) |\r\n| d | Edwards coeff | D | long Weierstrass coeff (NEW) |\r\n| e | | E | an Elliptic curve |\r\n| f | map fn in suites | F | field |\r\n| g | y^2 = g(x) | G | group |\r\n| h | cofactor | H | hash fn |\r\n| i | pcode counter | I | primitive element in extension field |\r\n| j | pcode counter | J | Montgomery coeff (NEW) |\r\n| k | security parameter | K | Montgomery coeff (NEW) |\r\n| l | | L | length in hash_to_base |\r\n| m | extension degree | M | secondary curve in Ell2Edw |\r\n| n | group order | N | |\r\n| o | | O | |\r\n| p | field characteristic | P | EC point |\r\n| q | field order | Q | EC point |\r\n| r | subgroup order | R | EC point |\r\n| s | Montgomery coord (NEW) | S | |\r\n| t | Montgomery coord (NEW) | T | |\r\n| u | input to map_to_curve | U | |\r\n| v | Edwards coord | V |  |\r\n| w | Edwards coord | W |  |\r\n| x | short Weierstrass coord | X | long Weierstrass coord (NEW) |\r\n| y | short Weierstrass coord | Y | long Weierstrass coord (NEW) |\r\n| z | sqrt result in Appx | Z | map_to_curve parameter |\r\n\r\n`tvX` is now temporary variables.\r\n\r\n---\r\n\r\nCurve equations are now:\r\n\r\n- Short Weierstrass: y^2 = x^3 + A * x + B\r\n\r\n- Long Weierstrass: Y^2 = X^3 + C * X^2 + D * X\r\n\r\n- Montgomery: K * t^2 = s^3 + J * s^2 + s\r\n\r\n- twisted Edwards: a * v^2 + w^2 = 1 + d * v^2 * w^2\r\n\r\n---\r\n\r\nEDIT: I've updated to reflect latest commits.",
          "createdAt": "2019-11-05T19:52:24Z",
          "updatedAt": "2019-11-16T22:46:32Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd really appreciate a careful look at variable naming. I've done a couple passes and I'll do another one, but more eyes is always better.",
          "createdAt": "2019-11-05T19:54:32Z",
          "updatedAt": "2019-11-05T19:54:32Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm still reviewing all the changes. one first suggestion will be whether the equation `Long Weierstrass: Y^2 = X^3 + C * X^2 + D * X` can be removed.\r\nI know we added it for making explicit the transition between Montgomery -> W -> twisted Edwards. But, it might be better to provide the direct map, thus we release two variables.",
          "createdAt": "2019-11-06T02:07:26Z",
          "updatedAt": "2019-11-06T02:07:26Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "although is correct, Montgomery equation looks strange due to the variables used. We are familiar with this document, and somewhat understand thses choices, but I would prefer to use other variables. \r\nFor example, many people use (u,v) -- but u is already taken\r\n(x, y) -- for Weierstrass is ok\r\n(v,w) -- for Edwards looks good\r\n\r\nif t is needed, you can use T0,T1,T2.... for temporal variables.\r\n\r\n\r\n",
          "createdAt": "2019-11-06T02:12:22Z",
          "updatedAt": "2019-11-06T02:12:22Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Refactoring this document is not a simple task, but we can try to stick more closely to the literature, even the equations be correct.",
          "createdAt": "2019-11-06T02:13:41Z",
          "updatedAt": "2019-11-06T02:13:41Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the excellent points. I agree, I don't love the weird variable names.\r\n\r\n> if t is needed, you can use T0,T1,T2.... for temporal variables.\r\n\r\nOr tmp1, tmp2, which is anyway nice and intuitive.\r\n\r\nBut: does `K * t^2 = s^3 + J * s^2 + s` look better for Montgomery? Maybe... I think we agree that the capital letters are a bit jarring for variables. But then what do we do with long Weierstrass? Still thinking get rid of it? (But I have to admit that X, Y looks kind of OK, even though V, W doesn't.)\r\n\r\nOther random thoughts:\r\n\r\n- Are you OK with (X, Y) for long Weierstrass, assuming we don't remove it?\r\n\r\n- For coefficients, I guess we could do A, B for short Weierstrass, Aw, Bw for long Weierstrass, and Am, Bm for Montgomery. (I'm not proposing Al, Bl because the `l` is easy to confuse with a `1` or an `I`.) Since the document basically doesn't mix short and long Weierstrass at all, this might actually be OK. But on the other hand, I think the potential for confusing (A, B) with (Aw, Bw) is greater than confusing it with (C, D) or (J, K).\r\n\r\n- The idea of getting rid of long Weierstrass altogether is really interesting. If I'm understanding your suggestion correctly, this would mean we'd have to modify the Elligator map description. I haven't thought about what that would look like, but probably it would be fine---just change around the constants and add two more multiplications (by 1, in the case of 25519 and 448) to the map.\r\n\r\n---\r\n\r\n> Refactoring this document is not a simple task, but we can try to stick more closely to the literature, even the equations be correct.\r\n\r\nIt's a great point, so I went back and refreshed my memory. The paper where Montgomery introduces his curve shape uses `B * y^2 = x^3 + A * x^2 + x`. The twisted Edwards paper uses `B * v^2 = u^3 + A * u^2 + u` for Montgomery curves. The Elligator paper doesn't mention B != 1 for Montgomery curves, so it just uses `y^2 = x^3 + A * x^2 + x`.\r\n\r\nIn other words---the literature tends to disagree a lot.\r\n\r\n(I think RFC7748 follows the twisted Edwards paper---it uses (x, y) for Edwards and (u, v) for Montgomery.)",
          "createdAt": "2019-11-06T05:20:49Z",
          "updatedAt": "2019-11-06T05:24:45Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Or maybe just using tmp1, ... and then switching (V, W) -> (s, t) would already be enough of an improvement? Hmm. Not so hard to do...",
          "createdAt": "2019-11-06T05:26:35Z",
          "updatedAt": "2019-11-06T05:26:35Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I've tried to resolve the worry about Montgomery coords. It's now back to (s, t), as it is in draft -05.\r\n\r\nTo make this happen, I renamed temporary variables \"tX\" to \"tvX\". I used this rather than \"tmpX\" because essentially all of our example code is already indented for three-character variable names (e.g., gx1), so this does the least damage. Also, this takes fewer columns, which is nice because we're sometimes squeezed for space.\r\n\r\nI also renamed \"s\" to \"z\" in the sqrt appendix, and at the same time I made the other changes I suggested in @chris-wood's recent PR. In doing this, I decided that the sample code to compute c1--c5 for Tonelli-Shanks was not useful (too simplistic, adding complexity to the document for no reason; people can look in example code if they need help).\r\n\r\nFinally, I added a commit that changes comments from `//` to `#` everywhere. This is because we're already giving essentially Python-ish pseudocode, so we may as well use the corresponding comment char. Also, again, it saves one column, which is helpful in a few spots.\r\n\r\nThoughts on this version? Happy to keep editing if you think there are further clarity issues @chris-wood @armfazh ",
          "createdAt": "2019-11-16T22:45:56Z",
          "updatedAt": "2019-11-16T22:45:56Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood if you're happy with this I'll merge (or you can, of course!)",
          "createdAt": "2019-12-13T05:24:21Z",
          "updatedAt": "2019-12-13T05:24:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm OK with it -- merging away!",
          "createdAt": "2019-12-13T16:08:04Z",
          "updatedAt": "2019-12-13T16:08:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NDM3Mzg5",
          "commit": {
            "abbreviatedOid": "76b03ec"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Make sure to rebase with master.",
          "createdAt": "2019-11-20T00:10:14Z",
          "updatedAt": "2019-11-20T00:47:22Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "These break changes done in #193 .\r\n ",
              "createdAt": "2019-11-20T00:10:15Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            },
            {
              "originalPosition": 587,
              "body": "here it should be `(X, Y)` ? ",
              "createdAt": "2019-11-20T00:21:31Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            },
            {
              "originalPosition": 611,
              "body": "> When defining new twisted Edwards curves, a Montgomery equivalent and rational\r\n> map SHOULD be specified, and the sign of the rational map SHOULD be stated\r\n> unambiguously.\r\n\r\nAccording to the last modifications, this paragraph should be updated too with something like this:\r\n\r\n> When defining new twisted Edwards curves, a **Weierstrass** equivalent and rational\r\n> map SHOULD be specified, and the sign of the rational map SHOULD be stated\r\n> unambiguously.\r\n\r\n\r\n",
              "createdAt": "2019-11-20T00:28:13Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            },
            {
              "originalPosition": 707,
              "body": "Since elligator2 uses a Weierstrass curve defined above, then `M` (which previously referred to a Montgomery curve) got undefined.",
              "createdAt": "2019-11-20T00:30:00Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            },
            {
              "originalPosition": 1336,
              "body": "@kwantam: Could you please remind me why is required that `g(x)-Z` be irreducible in `find_z_sswu`?",
              "createdAt": "2019-11-20T00:41:58Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NDg0NjAx",
          "commit": {
            "abbreviatedOid": "76b03ec"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-20T03:00:44Z",
          "updatedAt": "2019-11-20T03:00:45Z",
          "comments": [
            {
              "originalPosition": 833,
              "body": "```suggestion\r\n1. c1 = (q + 1) / 4         # Integer arithmetic\r\n```",
              "createdAt": "2019-11-20T03:00:45Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NDk2MzAy",
          "commit": {
            "abbreviatedOid": "d23da27"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-20T03:54:14Z",
          "updatedAt": "2019-11-20T03:54:14Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Thanks for the heads-up! I made sure to keep #193's changes when rebasing.",
              "createdAt": "2019-11-20T03:54:14Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NTAwNTkw",
          "commit": {
            "abbreviatedOid": "d23da27"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-20T04:14:18Z",
          "updatedAt": "2019-11-20T04:14:19Z",
          "comments": [
            {
              "originalPosition": 611,
              "body": "This is outside the scope of this PR, so I think we should fix it elsewhere---if we do. But:\r\n\r\nNote that this section is (and has been since we included it) a discussion of Edwards-to-Montgomery, not Edwards-to-Weierstrass. So what is written here *is* consistent with this section.\r\n\r\n---\r\n\r\nEDIT: ah, I see. This section *does* have an issue, as you've pointed out, because it's not consistent about Montgomery vs Long Weierstrass. Mea culpa.\r\n\r\nI've opened #195 about this; let's discuss separately from this issue and come up with a plan. In the meantime, we can get the rest of this PR integrated so it doesn't languish.\r\n\r\n---\r\n\r\nOn the other hand, you make a good point: maybe this is needlessly indirect! Why not just do Edwards-to-Weierstrass and then use Elligator2 directly? From my perspective, the answer is that most curves will have an Edwards-to-Montgomery map defined, and thus most readers will already be familiar with that map---so talking about it in those terms will be more familiar to the reader.\r\n\r\nAlso, remember: the reason we do Edwards-to-Montgomery in the first place is so that Edwards and Montgomery hashes are compatible, *and can share an implementation*. So the whole point is, once someone has a hash to a Montgomery curve, they just implement a map to the Edwards and they're done.\r\n\r\nFinally, in practice, most Montgomery curves that people use have B = 1, which means that they're already equivalent to the long Weierstrass form---so this distinction is mostly academic. But from my perspective it's cleaner to keep the internal details of the Montgomery map in the Montgomery section, and treat it as a black box here.\r\n\r\nIf you'd like to keep discussing this, maybe let's move it to its own issue?",
              "createdAt": "2019-11-20T04:14:19Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NTAzNTQy",
          "commit": {
            "abbreviatedOid": "d23da27"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-20T04:28:56Z",
          "updatedAt": "2019-11-20T04:28:57Z",
          "comments": [
            {
              "originalPosition": 707,
              "body": "Yeah, I see what you mean. We could call it E', I suppose.\r\n\r\nThe fundamental issue is that, as you have pointed out above, the \"Montgomery to Edwards\" section is inconsistent. Let's fix this after discussing in #195 rather than here, OK?",
              "createdAt": "2019-11-20T04:28:56Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NTAzOTQ4",
          "commit": {
            "abbreviatedOid": "d23da27"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-20T04:30:41Z",
          "updatedAt": "2019-11-20T04:30:41Z",
          "comments": [
            {
              "originalPosition": 1336,
              "body": "Sure thing! It's an attempt to avoid infringing on an existing patent. See [my post](https://mailarchive.ietf.org/arch/msg/cfrg/jV4Wr4fbMKkd4vzsbEhKbous16Y) from the cfrg mailing list.",
              "createdAt": "2019-11-20T04:30:41Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NTA5NDkz",
          "commit": {
            "abbreviatedOid": "3566f35"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-20T04:57:15Z",
          "updatedAt": "2019-11-20T04:57:16Z",
          "comments": [
            {
              "originalPosition": 587,
              "body": ":+1: pushed a pass over the document that addresses this.",
              "createdAt": "2019-11-20T04:57:15Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwMjQ5NjAz",
          "commit": {
            "abbreviatedOid": "b183bd8"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Only small nits, you can merge after solving them.\r\nAlso, we will continue the discussion on #195 .",
          "createdAt": "2019-11-20T20:22:32Z",
          "updatedAt": "2019-11-20T20:41:13Z",
          "comments": [
            {
              "originalPosition": 683,
              "body": "Something shorter\r\n \r\n```suggestion\r\n(v, w) = (0, 1), which is the identity point \r\n```",
              "createdAt": "2019-11-20T20:22:32Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            },
            {
              "originalPosition": 684,
              "body": "```suggestion\r\non all twisted Edwards curves.\r\n```",
              "createdAt": "2019-11-20T20:22:59Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            },
            {
              "originalPosition": 1449,
              "body": "```suggestion\r\n3. tv2 = tv1 * c1\r\n4.   z = CMOV(tv2, tv1, e)\r\n5. return z\r\n```",
              "createdAt": "2019-11-20T20:32:44Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            },
            {
              "originalPosition": 1450,
              "body": "```suggestion\r\n```",
              "createdAt": "2019-11-20T20:32:56Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwMjYwNTcz",
          "commit": {
            "abbreviatedOid": "b183bd8"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-20T20:43:12Z",
          "updatedAt": "2019-11-20T20:43:12Z",
          "comments": [
            {
              "originalPosition": 611,
              "body": "Move discussion to 195",
              "createdAt": "2019-11-20T20:43:12Z",
              "updatedAt": "2019-11-20T21:36:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNTY4MDQx",
          "commit": {
            "abbreviatedOid": "f3c0f20"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-21T00:08:31Z",
          "updatedAt": "2019-11-21T00:08:32Z",
          "comments": [
            {
              "originalPosition": 871,
              "body": "This constant can be omitted since calling to sqrt already includes this constant as q=3 (mod 4).\r\nReplace \r\n```\r\n6.   Y = gX1^c1\r\n```\r\nby \r\n```\r\n6.   Y = sqrt(gX1)\r\n```",
              "createdAt": "2019-11-21T00:08:31Z",
              "updatedAt": "2019-11-21T00:08:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNTY5MzM3",
          "commit": {
            "abbreviatedOid": "f3c0f20"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-21T00:12:58Z",
          "updatedAt": "2019-11-21T00:12:58Z",
          "comments": [
            {
              "originalPosition": 871,
              "body": "This would be a nice simplification, but I don't think it works in this context.\r\n\r\nThe reason is, gX1 is not guaranteed to be square, and we define our sqrt functions only for square inputs.\r\n\r\nTo be sure, we both know that the sqrt function we give for q = 3 mod 4 does the right thing in this context! The problem is that we've told the reader elsewhere that they can use whatever sqrt function they want---so we can't be sure that they're going to use the right one.\r\n\r\nThe point here is that we're *not necessarily* taking the sqrt of gX1---we might instead get back the sqrt of -gX1. So saying `sqrt(gX1)` won't connect to readers who don't already know this trick for `q = 3 mod 4`.",
              "createdAt": "2019-11-21T00:12:58Z",
              "updatedAt": "2019-11-21T00:17:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNTc2NzEw",
          "commit": {
            "abbreviatedOid": "f3c0f20"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-21T00:36:47Z",
          "updatedAt": "2019-11-21T00:36:47Z",
          "comments": [
            {
              "originalPosition": 871,
              "body": "oh, I got it.\r\nSo using the exponentiation you are preventing (for instance) the following case: someone implemeted sqrt in such a way that always returns error when the sqrt is not found.\r\n\r\n",
              "createdAt": "2019-11-21T00:36:47Z",
              "updatedAt": "2019-11-21T00:36:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNTgxMzUy",
          "commit": {
            "abbreviatedOid": "f3c0f20"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-21T00:51:42Z",
          "updatedAt": "2019-11-21T00:51:42Z",
          "comments": [
            {
              "originalPosition": 871,
              "body": "Yes, exactly right. Nicely put.",
              "createdAt": "2019-11-21T00:51:42Z",
              "updatedAt": "2019-11-21T00:51:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 191,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM4MTk3OTIz",
      "title": "Add appendix section for `clear_cofactor` in BLS12-381 G2.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/191",
      "state": "OPEN",
      "author": "mmaker",
      "authorAssociation": "FIRST_TIME_CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This pull request fixes #166 specifying the algorithm of [BP18] for a fast cofactor clearing.",
      "createdAt": "2019-11-07T19:14:41Z",
      "updatedAt": "2020-03-23T08:18:01Z",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "mmaker",
          "authorAssociation": "NONE",
          "body": "Hello @chris-wood  and @kwantam! I doublechecked the code in the pull request and the analogous rust implementation is now in https://github.com/zkcrypto/bls12_381. What do you think?",
          "createdAt": "2019-12-17T11:06:38Z",
          "updatedAt": "2019-12-17T11:06:38Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Excellent! I finally should have some time to look at this in the next few days. I'll get back to you asap!",
          "createdAt": "2019-12-17T17:26:06Z",
          "updatedAt": "2019-12-17T17:26:06Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased onto master because diff tab was super confused :)",
          "createdAt": "2020-02-25T02:09:45Z",
          "updatedAt": "2020-02-25T02:09:45Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "NONE",
          "body": "Hey @kwantam, thanks a lot for this review! I updated the pull request integrating your comments, and rebasing it all on master to keep the git log tidied up :). What do you think?",
          "createdAt": "2020-03-11T13:25:26Z",
          "updatedAt": "2020-03-11T13:26:29Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "NONE",
          "body": "hello @kwantam ! any updates on this?\r\n\r\n(hope you're doing fine during these crazy days!)",
          "createdAt": "2020-03-23T08:18:00Z",
          "updatedAt": "2020-03-23T08:18:00Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzODMwMzk0",
          "commit": {
            "abbreviatedOid": "41ed1e1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Sorry for the delay in reviewing.\r\n\r\nIf you don't have cycles to make edits, I'm happy to edit and include. In either case, we really really appreciate your help with this!!!",
          "createdAt": "2020-02-25T02:16:55Z",
          "updatedAt": "2020-02-25T02:29:52Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nBudroni and Pintore ({{BP18}}, Section 4.1).\r\n{{clear-cofactor-bls12381-g2}} gives an example implementation of this method.\r\n```",
              "createdAt": "2020-02-25T02:16:56Z",
              "updatedAt": "2020-03-11T13:10:26Z"
            },
            {
              "originalPosition": 16,
              "body": "The existence of faster methods is already stated in `{{cofactor-clearing}}`, so that fact should not be repeated here.\r\n\r\nIn addition, it does not seem correct to say that \"we propose\" this method---*Budroni and Pintore* proposed this method, based on `{{SBCDK09}}` and `{{FKR11}}`.\r\n\r\nBut: I wouldn't say any of that here, since it's redundant with the text in `{{cofactor-clearing}}`. Instead, I'd forward ref from the bullet there to here and then this section should jump right into example code.",
              "createdAt": "2020-02-25T02:20:14Z",
              "updatedAt": "2020-03-11T13:10:26Z"
            },
            {
              "originalPosition": 23,
              "body": "As above, redundant. I'd also get rid of the second-level heading---one level of heading is enough.",
              "createdAt": "2020-02-25T02:20:42Z",
              "updatedAt": "2020-03-11T13:10:26Z"
            },
            {
              "originalPosition": 36,
              "body": "This duplicates the definitions in `{{suites-bls12381-g2}}`. Instead, please refer to those definitions with a crossref, and then *only* define the constant you need (which I believe is `u = I + 1`, as `I` is defined in the appropriate Suites subsection).\r\n\r\nI wouldn't bother with the `EllipticCurve()` stuff here. The goal should be to present it in a way that is readable to a human, not as syntactically correct Sage code (we could *also* add that if we wanted, but for the spec document itself that's beside the point).",
              "createdAt": "2020-02-25T02:23:42Z",
              "updatedAt": "2020-03-11T13:10:26Z"
            },
            {
              "originalPosition": 43,
              "body": "Here, we probably first need to define `frobenius` (because this subsection should be for human consumption, not for Sage's consumption).\r\n\r\nThen it would be useful to write out the values of x, y, and z on separate lines so that it's more easily understood.",
              "createdAt": "2020-02-25T02:25:49Z",
              "updatedAt": "2020-03-11T13:10:26Z"
            },
            {
              "originalPosition": 48,
              "body": "Same as prior comment: x, y, z, one per line please",
              "createdAt": "2020-02-25T02:26:02Z",
              "updatedAt": "2020-03-11T13:10:26Z"
            },
            {
              "originalPosition": 51,
              "body": "Maybe be explicit: `u^((p-1)/3)` and `u^((p-1)/2)`, or whatever. It might be even better to follow the format we use elsewhere, and call these constants `c1`, `c2`, ...",
              "createdAt": "2020-02-25T02:26:49Z",
              "updatedAt": "2020-03-11T13:10:26Z"
            },
            {
              "originalPosition": 18,
              "body": "This is a collision in terminology. We use `E'` to mean a curve isogenous to `E`. This should be called \"Cofactor clearing for BLS12-381 G2\", or something like that.",
              "createdAt": "2020-02-25T02:27:56Z",
              "updatedAt": "2020-03-11T13:10:26Z"
            },
            {
              "originalPosition": 53,
              "body": "`E'` (see comment above)",
              "createdAt": "2020-02-25T02:28:19Z",
              "updatedAt": "2020-03-11T13:10:26Z"
            },
            {
              "originalPosition": 61,
              "body": "comment says `psi(psi(P))`, but code says `psi(psi(2 * P))` (issue continued in comments below)",
              "createdAt": "2020-02-25T02:28:49Z",
              "updatedAt": "2020-03-11T13:10:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyNjE0OTQ2",
          "commit": {
            "abbreviatedOid": "41ed1e1"
          },
          "author": "mmaker",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-11T10:00:00Z",
          "updatedAt": "2020-03-11T10:00:00Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Fixed, thanks! ",
              "createdAt": "2020-03-11T10:00:00Z",
              "updatedAt": "2020-03-11T13:10:26Z"
            }
          ]
        }
      ]
    },
    {
      "number": 192,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM4NzcwNjY5",
      "title": "Clarify Tonelli-Shanks algorithm variable.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/192",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also, remove unused extension degree parameters where not used.",
      "createdAt": "2019-11-08T17:06:30Z",
      "updatedAt": "2019-11-12T18:47:39Z",
      "closedAt": "2019-11-12T18:47:38Z",
      "mergedAt": "2019-11-12T18:47:38Z",
      "mergedBy": "kwantam",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam I'll just fix the T-S issues here. We can resolve the other stuff in a separate PR!",
          "createdAt": "2019-11-11T18:14:26Z",
          "updatedAt": "2019-11-11T18:14:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam please merge if you think it's good to go!",
          "createdAt": "2019-11-12T18:22:26Z",
          "updatedAt": "2019-11-12T18:22:26Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE0NTA2Mjgx",
          "commit": {
            "abbreviatedOid": "22010ce"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-08T23:10:12Z",
          "updatedAt": "2019-11-08T23:10:12Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Input: x, an element of F.\r\nOutput: r, an element of F such that r^2 == x, if x is a square in F.",
              "createdAt": "2019-11-08T23:10:12Z",
              "updatedAt": "2019-11-12T18:43:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE0NTA2Nzk1",
          "commit": {
            "abbreviatedOid": "22010ce"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-08T23:12:08Z",
          "updatedAt": "2019-11-08T23:12:08Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I don't follow?",
              "createdAt": "2019-11-08T23:12:08Z",
              "updatedAt": "2019-11-12T18:43:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE0NTA3MDA1",
          "commit": {
            "abbreviatedOid": "22010ce"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-08T23:12:50Z",
          "updatedAt": "2019-11-08T23:12:50Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Oh, you just want to rename. (This comment doesn't apply to the current line.)",
              "createdAt": "2019-11-08T23:12:50Z",
              "updatedAt": "2019-11-12T18:43:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE0NTQ5ODM5",
          "commit": {
            "abbreviatedOid": "22010ce"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "The edits look good. A few more things that could be fixed:\r\n\r\n1. The headings could be updated to say (e.g.) `q = 3 mod 4` rather than `p = 3 mod 4`.\r\n2. Could get rid of `p` in the parameters, too! (Notice that the constants are written in terms of q.)\r\n3. Could pull the `{{AR13}}` and `{{S85}}` cites to top of section.\r\n4. the \"Note that...\" in the 9 mod 16 case is redundant if p is renamed to q.\r\n5. As @armfazh points out, `r` in T-S should really be `s`; `r` is a reserved letter :)\r\n\r\nIf you'd like, I'm happy to make some of these edits and push them to this branch.",
          "createdAt": "2019-11-09T09:32:47Z",
          "updatedAt": "2019-11-09T09:32:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE1NzU0MjQz",
          "commit": {
            "abbreviatedOid": "88aebd1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Sorry, one error that's my fault.",
          "createdAt": "2019-11-12T18:37:21Z",
          "updatedAt": "2019-11-12T18:37:35Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "```suggestion\r\n7.      for j in (1, 2, ..., k - 2):\r\n```\r\n\r\nOops! This is my fault.\r\n\r\nI just mechanically translated the code from the latest commit into Sage and it runs correctly after the above change.",
              "createdAt": "2019-11-12T18:37:22Z",
              "updatedAt": "2019-11-12T18:43:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE1NzYwMjU4",
          "commit": {
            "abbreviatedOid": "e31b085"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-12T18:47:12Z",
          "updatedAt": "2019-11-12T18:47:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 193,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM5NjMwODc0",
      "title": "Extension fields everywhere.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/193",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Changes:\r\n- Matching polynomial basis with polynomial representation, like in FIPS 186-4 (Sec. D.1.1.3).\r\n- F is an extension field.\r\n\r\n",
      "createdAt": "2019-11-11T21:47:45Z",
      "updatedAt": "2019-11-17T03:28:30Z",
      "closedAt": "2019-11-17T03:28:30Z",
      "mergedAt": "2019-11-17T03:28:30Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I will review more carefully, but fundamentally I do not like \"polynomial\" in place of \"vector.\" It sounds more \"science-ey\" but is no more precise, and will be less intuitively familiar to readers.\r\n\r\n---\r\n\r\nEDIT to add: I'm on a deadline until Friday, so probably I won't have time to review until after that. Sorry...",
          "createdAt": "2019-11-12T18:22:01Z",
          "updatedAt": "2019-11-12T18:39:07Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE1ODgzNTQx",
          "commit": {
            "abbreviatedOid": "9a32580"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I agree with @kwantam here. I think we should keep our use of the vector representation, perhaps with a note that says this is equivalent to a polynomial basis representation. ",
          "createdAt": "2019-11-12T22:17:59Z",
          "updatedAt": "2019-11-12T22:19:25Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "nit: missed `vector` usage here and elsewhere (L1354 below)",
              "createdAt": "2019-11-12T22:17:59Z",
              "updatedAt": "2019-11-14T21:43:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MjczNDUy",
          "commit": {
            "abbreviatedOid": "e624edf"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-14T21:31:45Z",
          "updatedAt": "2019-11-14T21:31:46Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "This change should probably be reverted too, right?",
              "createdAt": "2019-11-14T21:31:45Z",
              "updatedAt": "2019-11-14T21:43:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3Mjc5OTU5",
          "commit": {
            "abbreviatedOid": "205660e"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-14T21:43:36Z",
          "updatedAt": "2019-11-14T21:43:36Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "true.",
              "createdAt": "2019-11-14T21:43:36Z",
              "updatedAt": "2019-11-14T21:43:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3OTkwMzQx",
          "commit": {
            "abbreviatedOid": "205660e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": ":+1: ",
          "createdAt": "2019-11-16T21:44:14Z",
          "updatedAt": "2019-11-16T21:44:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 196,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUyNjc1NDU4",
      "title": "Generation of test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/196",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It is re-based on top of #189 and #201 .\r\n\r\nJSON test vectors for matching compatible implementations.\r\n\r\nExample:\r\n```json\r\n{\r\n  \"ciphersuite\": \"P256-SHA256-SSWU-RO-\",\r\n  \"curve\": \"P256\",\r\n  \"dst\": \"QUUX-V01-CS02\",\r\n  \"field\": {\r\n    \"m\": \"0x1\",\r\n    \"p\": \"0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff\"\r\n  },\r\n  \"hash\": \"sha256\",\r\n  \"map\": {\r\n    \"name\": \"SSWU\",\r\n    \"sgn0\": \"sgn0_le\"\r\n  },\r\n  \"randomOracle\": true,\r\n  \"vectors\": [\r\n    {\r\n      \"P\": {\r\n        \"x\": \"0x8beb73a82ebeb6b400456f4da126aacbfa9b8049b71b250d2b7e4885b6b466bd\",\r\n        \"y\": \"0x15826dc578f4fbc1ac5fc3f9e15da3ece18be914f332bce8ce5bf1371805d149\"\r\n      },\r\n      \"msg\": \"\"\r\n    },\r\n ]\r\n}\r\n```",
      "createdAt": "2019-12-13T00:52:15Z",
      "updatedAt": "2020-02-25T02:27:41Z",
      "closedAt": "2020-02-25T02:27:41Z",
      "mergedAt": "2020-02-25T02:27:41Z",
      "mergedBy": "armfazh",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Nice! I will take a more careful look in the next few days.\r\n\r\nTo be clear: the JSON wouldn't go into the document, right? (Of course, we can provide test vector files to be downloaded and mechanically processed.)\r\n\r\nSo probably we will also want a script to turn the JSON structures into whatever format will actually go into the appendix of the document. (Or have I missed it, and that's already here?)",
          "createdAt": "2019-12-13T04:38:22Z",
          "updatedAt": "2019-12-13T04:38:22Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> To be clear: the JSON wouldn't go into the document, right? \r\n\r\nNo, only ascii. JSON files are intended to be available at an external repo.\r\n\r\n> So probably we will also want a script to turn the JSON structures into whatever format will actually go into the appendix of the document.\r\n\r\nNow it supports both ascii and json formats.\r\n\r\n",
          "createdAt": "2019-12-14T01:59:46Z",
          "updatedAt": "2019-12-14T02:00:44Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "This branch has been rebased including the Python3 updates. \r\nShould I also include in this PR the test vector  (json/ascii) files?\r\n",
          "createdAt": "2020-01-22T00:19:22Z",
          "updatedAt": "2020-01-22T00:19:22Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I know that I still need to review this. I'm sorry for the very long delay. I should have time this week.\r\n\r\nJust to double check: The Sage9/Python3 version generates the same test vectors as the Sage8/Python2 version, right?",
          "createdAt": "2020-01-22T01:40:32Z",
          "updatedAt": "2020-01-22T01:40:32Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "The SHA512 suites for {curve/edwards}25519 are now included in Sage scripts.",
          "createdAt": "2020-01-29T02:15:04Z",
          "updatedAt": "2020-01-29T02:15:04Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I rebased this on top of master because the diff interface was very confused :)",
          "createdAt": "2020-02-25T01:46:33Z",
          "updatedAt": "2020-02-25T01:46:33Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzODIyMzAx",
          "commit": {
            "abbreviatedOid": "5d30875"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me. I re-ran test vector generation on my machine (sage9/python3) and got the same files back out. Just a few very small things.\r\n\r\nI assume once #212 lands and we update the code to the new suites we'll generate new test vectors, but it doesn't hurt to have these in the repo history anyway, IMO.",
          "createdAt": "2020-02-25T01:48:11Z",
          "updatedAt": "2020-02-25T01:59:36Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Probably not an issue here, but `-j` can totally thrash a machine, so I try to avoid suggesting it by default. Maybe out of an abundance of caution\r\n\r\n```suggestion\r\n1. `make -j4` --- This preprocesses the sage files. If you don't do this, you'll get\r\n```\r\n\r\n:man_shrugging:",
              "createdAt": "2020-02-25T01:48:12Z",
              "updatedAt": "2020-02-25T02:25:46Z"
            },
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n        self.name = \"ELL2\"\r\n```\r\n\r\nMaybe use this to match the naming scheme in the Suites?",
              "createdAt": "2020-02-25T01:49:33Z",
              "updatedAt": "2020-02-25T02:25:46Z"
            },
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-02-25T01:53:50Z",
              "updatedAt": "2020-02-25T02:25:46Z"
            },
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-02-25T01:54:06Z",
              "updatedAt": "2020-02-25T02:25:46Z"
            },
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-02-25T01:54:15Z",
              "updatedAt": "2020-02-25T02:25:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzODMwNjg1",
          "commit": {
            "abbreviatedOid": "5d30875"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I did a quick cursory scan -- looks good! (Riad having run them gives me confidence it's good to go.)",
          "createdAt": "2020-02-25T02:17:56Z",
          "updatedAt": "2020-02-25T02:17:56Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzODMwNzQz",
          "commit": {
            "abbreviatedOid": "5d30875"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-25T02:18:10Z",
          "updatedAt": "2020-02-25T02:18:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 197,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUzMTI0NTE2",
      "title": "tiny build fixes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/197",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The new version of xml2rfc doesn't like empty dates, and something has started dumping out an empty metadata.min.js file.\r\n\r\nFix empty date, add metadata.min.js to .gitignore.",
      "createdAt": "2019-12-14T00:55:02Z",
      "updatedAt": "2019-12-15T20:03:35Z",
      "closedAt": "2019-12-14T03:29:30Z",
      "mergedAt": "2019-12-14T03:29:30Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMyMTkzNTY3",
          "commit": {
            "abbreviatedOid": "6323fcb"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-14T03:29:26Z",
          "updatedAt": "2019-12-14T03:29:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 198,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUzMTI4Njgw",
      "title": "remove Boneh-Franklin and Ell2C0 maps",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/198",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Having chatted with folks at ECC and elsewhere, I've become convinced that there's no need to support Boneh-Franklin or Elligator2, C=0.\r\n\r\nAs far as I can tell, there are no applications that are geared specifically towards the very narrow class of curves that these maps support. Moreover, if anyone wants to map to such curves, they can just use one of the other maps---SvdW and SWU would both work (the latter via the isogeny trick).\r\n\r\nSo: from my perspective it's better to simplify the document and not include these. Of course, if anyone decides in the future they really want to use these maps, they can grab the text from draft-05 (or the git repo) and easily do so. But my guess is that no one will...\r\n\r\nI know this PR might be controversial, and I'll understand if y'all disagree! :)\r\n\r\n----\r\n\r\nEDIT: this pr is built on #197, so if we decide to merge it we should do so after that one",
      "createdAt": "2019-12-14T01:32:04Z",
      "updatedAt": "2020-01-23T22:13:20Z",
      "closedAt": "2020-01-23T21:22:06Z",
      "mergedAt": "2020-01-23T21:22:06Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood I checked, looks like this branch is up-to-date and ready for review.",
          "createdAt": "2020-01-21T16:50:57Z",
          "updatedAt": "2020-01-21T16:50:57Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh, please take a look! Let's aim to merge this by the end of the week.",
          "createdAt": "2020-01-21T18:29:48Z",
          "updatedAt": "2020-01-21T18:29:48Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Some arguments on favor of keeping them.\r\nNote that these maps are faster and simpler of implementing than SvdW and SSWU+Isog. \r\nSomeone should be tempted to use them due to their efficiency.\r\nIf someone really needs them, this document specifies their correct usage and compatibility. Otherwise, nothing guarantees that the same specification will be followed.\r\n",
          "createdAt": "2020-01-22T01:03:36Z",
          "updatedAt": "2020-01-22T01:03:36Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "(Rebased on master, tested against Sage 9 and Sage 8.1.)",
          "createdAt": "2020-01-22T15:27:47Z",
          "updatedAt": "2020-01-22T15:27:47Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh, all of the points you make are good ones, and I fully agree that there would be good reason to keep these maps if anyone were interested in hashing to the curves they support. But as far as I can tell there is no such interest---so I think the advantages of keeping these maps are mostly hypothetical, while the advantage of simplifying the document by removing them appears to be real.\r\n\r\nThat said, I think we may have other, more important things to worry about (issue coming soon), so I don't want to get bogged down in a disagreement on this one; happy to go either way.",
          "createdAt": "2020-01-22T15:49:04Z",
          "updatedAt": "2020-01-22T15:49:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "For what it's worth, I think we should remove them. If we later find an application that needs them, we can always spin a new document to include them. @armfazh, would that work?",
          "createdAt": "2020-01-23T17:57:41Z",
          "updatedAt": "2020-01-23T17:57:41Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm agree, also additionally to the changes of this PR, we could include a small paragraph just mentioning these maps in the Appendix.",
          "createdAt": "2020-01-23T18:07:47Z",
          "updatedAt": "2020-01-23T18:07:47Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh I pushed an edit that mentions BLMP19 in the Related Work section. BF01 was already mentioned there. Does this work for you?",
          "createdAt": "2020-01-23T20:58:56Z",
          "updatedAt": "2020-01-23T20:58:56Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM, ",
          "createdAt": "2020-01-23T21:19:18Z",
          "updatedAt": "2020-01-23T21:19:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MDk2Mjcy",
          "commit": {
            "abbreviatedOid": "362e5a9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-21T18:28:56Z",
          "updatedAt": "2020-01-21T18:28:56Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NTAxODM3",
          "commit": {
            "abbreviatedOid": "7cf3580"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-23T18:07:57Z",
          "updatedAt": "2020-01-23T18:07:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 201,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY1NTQ1Njcy",
      "title": "update poc/ code to be compatible with python3",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/201",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR updates the code to work with Python3/Sage9.\r\n\r\nI've tested with Sage9 and with Sage8.1, and both appear to work correctly.\r\n\r\n--\r\n\r\nSeems good to go now. Closes #199.",
      "createdAt": "2020-01-21T22:11:18Z",
      "updatedAt": "2020-01-22T15:18:54Z",
      "closedAt": "2020-01-22T02:17:32Z",
      "mergedAt": "2020-01-22T02:17:32Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "All tests pass in Sage v9. LGTM for merging\r\n",
          "createdAt": "2020-01-22T00:17:45Z",
          "updatedAt": "2020-01-22T00:18:02Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MzExODU3",
          "commit": {
            "abbreviatedOid": "4686684"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, @kwantam! This LGTM, too.",
          "createdAt": "2020-01-22T02:17:24Z",
          "updatedAt": "2020-01-22T02:17:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 204,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY2NjA1NDgw",
      "title": "define SHA512 suites for *25519",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/204",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Ed25519 pairs SHA-512 with the edwards25519 curve. Because of this, several other protocols use this combination of primitives, including the VRF draft and CPace. So probably it makes life easy for us to define this suite.",
      "createdAt": "2020-01-23T22:51:27Z",
      "updatedAt": "2020-02-16T01:22:17Z",
      "closedAt": "2020-01-25T14:01:25Z",
      "mergedAt": "2020-01-25T14:01:25Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MjQ1MzIz",
          "commit": {
            "abbreviatedOid": "0104885"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I don't see any blockers on this.",
          "createdAt": "2020-01-24T21:51:12Z",
          "updatedAt": "2020-01-24T21:51:12Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MzI3MzEx",
          "commit": {
            "abbreviatedOid": "0104885"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-25T14:01:18Z",
          "updatedAt": "2020-01-25T14:01:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 205,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY3NzkyNDg0",
      "title": "Adding a link to a Go reference implementation.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/205",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Adds a link to a Go reference implementation.",
      "createdAt": "2020-01-28T02:05:58Z",
      "updatedAt": "2020-01-28T18:46:36Z",
      "closedAt": "2020-01-28T18:46:36Z",
      "mergedAt": "2020-01-28T18:46:36Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh does the Go implementation produce outputs that match the Sage version? ",
          "createdAt": "2020-01-28T16:40:01Z",
          "updatedAt": "2020-01-28T16:40:01Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, the files in `testdata` folder are json files produced by Sage and consumed by Go tests. ",
          "createdAt": "2020-01-28T18:36:26Z",
          "updatedAt": "2020-01-28T18:36:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Yes, the files in testdata folder are json files produced by Sage and consumed by Go tests.\r\n\r\nSweet!",
          "createdAt": "2020-01-28T18:39:34Z",
          "updatedAt": "2020-01-28T18:39:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5NjEwODM5",
          "commit": {
            "abbreviatedOid": "f8caad8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-28T18:40:19Z",
          "updatedAt": "2020-01-28T18:40:25Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nThese implementations are for reference only. They MUST NOT be used in production systems.\r\n```",
              "createdAt": "2020-01-28T18:40:20Z",
              "updatedAt": "2020-01-28T18:45:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 208,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc1Nzc0MjE5",
      "title": "Fix",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/208",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-02-16T01:10:21Z",
      "updatedAt": "2020-02-16T01:10:34Z",
      "closedAt": "2020-02-16T01:10:34Z",
      "mergedAt": "2020-02-16T01:10:34Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": []
    },
    {
      "number": 209,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc1Nzc0ODky",
      "title": "Fix bug in appendix D.1.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/209",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #201.",
      "createdAt": "2020-02-16T01:19:26Z",
      "updatedAt": "2020-02-16T19:27:50Z",
      "closedAt": "2020-02-16T19:27:50Z",
      "mergedAt": "2020-02-16T19:27:50Z",
      "mergedBy": "kwantam",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5NDIzNjE4",
          "commit": {
            "abbreviatedOid": "dcbb496"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-16T19:27:37Z",
          "updatedAt": "2020-02-16T19:27:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 211,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc3MzAwMDY4",
      "title": "poc/sswu_*.sage: use sgn0_be with bls12381, as specified.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/211",
      "state": "CLOSED",
      "author": "dot-asm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "BLS12-381 suites are specified to use big-endian variant of sgn0, while sswu_*.sage scripts default to little-endian one in all cases. This pull request should probably be viewed rather as \"here is a problem\" than \"this is how to fix it,\" as there might be better way to achieve the goal. Cheers.\r\n",
      "createdAt": "2020-02-19T17:45:01Z",
      "updatedAt": "2020-02-28T09:56:51Z",
      "closedAt": "2020-02-28T09:56:50Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! I'll follow up asap.",
          "createdAt": "2020-02-24T06:10:38Z",
          "updatedAt": "2020-02-24T06:10:38Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, looking into this more:\r\n\r\nThe suite definitions don't have any issues with this, because suites set the appropriate sgn0 variant as part of the suite definition (see h2c_suite.sage line 31).\r\n\r\nSo it looks to me like the only place that this could arguably be an issue is in the BLS12-381-isogenous curve in sswu_opt.sage. (To me, that doesn't matter much---it's a simple functionality test, not a suite definition---but I'm happy to fix it.)\r\n\r\nI'll take care of this when editing suites for #212.",
          "createdAt": "2020-02-24T23:42:00Z",
          "updatedAt": "2020-02-24T23:42:00Z"
        },
        {
          "author": "dot-asm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> (To me, that doesn't matter much---it's a simple functionality test, not a suite definition---\r\n\r\nWhile the test passes in so to say loopback mode, i.e. when both optimized and generic implementations use same variant of sgn0, I'd still argue that it's not insignificant difference. If an implementation fails to process test vector and you have to dig into it, rigid compliance with specification even at this level helps.\r\n\r\n> but I'm happy to fix it.)\r\n\r\nCool! Thanks!\r\n",
          "createdAt": "2020-02-28T09:56:50Z",
          "updatedAt": "2020-02-28T09:56:50Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 212,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc4ODI1MjQ3",
      "title": "new hash_to_field definition",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/212",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR redefines hash_to_field in the way discussed in #202.\r\n\r\nNow ready for review, I believe.\r\n\r\nTodo:\r\n\r\n- [x] rename to hash_to_field\r\n- [x] write new definitions and security considerations\r\n- [x] update Security Considerations section\r\n- [x] update Roadmap section\r\n- [x] update Suites section\r\n- ~update implementations~  we can do this in a separate PR (or I'm happy to do it here... what do we think?)\r\n\r\n@armfazh @chris-wood @JustinDrake I'd appreciate comments on the WIP version. I'm sure I've left typos, things aren't super clear yet, etc.!",
      "createdAt": "2020-02-24T06:08:08Z",
      "updatedAt": "2020-02-28T22:46:24Z",
      "closedAt": "2020-02-28T22:45:15Z",
      "mergedAt": "2020-02-28T22:45:15Z",
      "mergedBy": "kwantam",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood, @armfazh should we wait to update code until after we land #196?\r\n\r\n(I know that I need to review that code! Sorry!!! I will do it next...)",
          "createdAt": "2020-02-25T00:37:42Z",
          "updatedAt": "2020-02-25T00:37:50Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> @chris-wood, @armfazh should we wait to update code until after we land #196?\r\n\r\nWhat about merging 196 (modulo Riad's review). \r\nOnce this PR (212) be reviewed and approved, we can generate a new pr addressing only the new hash_to_field function. \r\n",
          "createdAt": "2020-02-25T01:22:14Z",
          "updatedAt": "2020-02-25T01:22:14Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I added `k`, the target security level, to the suite definition. It's needed in the definition of `expand_message_md`, so we need to specify it for compatibility.",
          "createdAt": "2020-02-25T06:52:50Z",
          "updatedAt": "2020-02-25T06:52:50Z"
        },
        {
          "author": "peteroupc",
          "authorAssociation": "NONE",
          "body": "You have said that power analysis attacks are not in scope for this document (https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/202#issuecomment-581644873); you should note something about that in the security considerations.",
          "createdAt": "2020-02-25T14:57:12Z",
          "updatedAt": "2020-02-25T14:57:12Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I've got updated code [ready to go](/kwantam/draft-irtf-cfrg-hash-to-curve/tree/new-h2f-code).\r\n\r\nShould I just add those commits to this PR, or should we handle them separately? @armfazh @chris-wood ",
          "createdAt": "2020-02-27T07:10:23Z",
          "updatedAt": "2020-02-27T07:10:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Should I just add those commits to this PR, or should we handle them separately? @armfazh @chris-wood\r\n\r\nSeparately is fine by me!",
          "createdAt": "2020-02-27T13:13:53Z",
          "updatedAt": "2020-02-27T13:13:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> What is the consensus about using octet rather than byte?\r\n\r\nI prefer byte. @kwantam?",
          "createdAt": "2020-02-27T23:06:26Z",
          "updatedAt": "2020-02-27T23:06:26Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> I prefer byte. @kwantam?\r\n\r\nI think \"octet\" is a little awkward and annoying, but is more precise than \"byte\" (in the sense that octet is exactly 8 bits, but byte isn't necessarily).\r\n\r\nIn practice this probably mattered a lot more when RFC793 was written than it does now, so I'm fine switching everything to bytes and just noting somewhere that we assume bytes are 8 bits.",
          "createdAt": "2020-02-28T00:07:45Z",
          "updatedAt": "2020-02-28T00:07:45Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Ach, there's one more issue I need to think about before we merge @chris-wood @armfazh\r\n\r\nWe want to use *a prefix-free encoding* of DST in both of the expand_message variants. This is easy: just prepend DST with its length. But I want to make sure the text reflects this throughout. ~So can we hold off until later today when I push an edit?~\r\n\r\n--\r\n\r\nDone now. By the way, I didn't give a good justification for this above, but the reason is that otherwise we don't meet our own requirement that all distinct (msg, DST, length_in_bytes) triplets give distinct outputs. Specifically, without a prefix-free DST encoding, it's possible to \"trade\" bytes between msg and DST to get two triplets that give the same output.",
          "createdAt": "2020-02-28T17:41:47Z",
          "updatedAt": "2020-02-28T18:35:26Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMjg0MzM3",
          "commit": {
            "abbreviatedOid": "d66c81e"
          },
          "author": "mratsim",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-24T10:20:40Z",
          "updatedAt": "2020-02-24T10:28:42Z",
          "comments": [
            {
              "originalPosition": 441,
              "body": "The slicing notation `[0 : len_in_octets]` is straightforward with Python experience but isn't the length of the constructed `pseudo_random_octets` implied by construction of `ell = ceil((len_in_octets - k_in_octets) / b_in_octets)`?",
              "createdAt": "2020-02-24T10:20:41Z",
              "updatedAt": "2020-02-28T18:26:52Z"
            },
            {
              "originalPosition": 547,
              "body": "There is no HKDF-Expand anymore",
              "createdAt": "2020-02-24T10:24:10Z",
              "updatedAt": "2020-02-28T18:26:52Z"
            },
            {
              "originalPosition": 584,
              "body": "Change to `h2f/kmac128` and `SHA3:h2f/kmac128`",
              "createdAt": "2020-02-24T10:26:15Z",
              "updatedAt": "2020-02-28T18:26:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNDIwNTgz",
          "commit": {
            "abbreviatedOid": "d66c81e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This looks great! I quite like the new modularity, especially as it lets us more easily test things. (We can have different test vectors for hash_to_field and expand_message_md et al.)",
          "createdAt": "2020-02-24T14:19:13Z",
          "updatedAt": "2020-02-24T15:12:18Z",
          "comments": [
            {
              "originalPosition": 344,
              "body": "```suggestion\r\n2. pseudo_random_octets = expand_message(msg, DST, pro_length)\r\n```\r\n\r\nor the other way around!",
              "createdAt": "2020-02-24T14:19:13Z",
              "updatedAt": "2020-02-28T18:26:52Z"
            },
            {
              "originalPosition": 343,
              "body": "nit: I might rename this to `expand_length`",
              "createdAt": "2020-02-24T14:20:11Z",
              "updatedAt": "2020-02-28T18:26:52Z"
            },
            {
              "originalPosition": 379,
              "body": "Should we elaborate on why this is indifferentiable from a RO? Perhaps we can cite [1] and note that we encode the input `msg` in a prefix-free manner (by prepending the length and DST)? (And whatever else is needed?)\r\n\r\n[1] https://cs.nyu.edu/~dodis/ps/merkle.pdf",
              "createdAt": "2020-02-24T15:11:19Z",
              "updatedAt": "2020-02-28T18:26:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNzEwNDc1",
          "commit": {
            "abbreviatedOid": "d66c81e"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-24T21:23:30Z",
          "updatedAt": "2020-02-24T21:23:30Z",
          "comments": [
            {
              "originalPosition": 441,
              "body": "Whoops, this comment made me realize there's a typo in the definition of `ell`---should be `len_in_octets + k_in_octets` (not subtraction). Thanks!!!\r\n\r\n---\r\n\r\nHowever:\r\n\r\n`ell` is the number of blocks that it takes to generate *at least* `len_in_octets + k_in_octets` bytes, but it can be that it gives slightly more than the necessary number of bytes (because we have to round up to a whole number of blocks).\r\n\r\nFor example, imagine `len_in_octets` = 128, `k_in_octets` = 16, and `b_in_octets` = 32. (This would be the case when hashing to two elements of the BLS12-381 G1 group using SHA-256.)\r\n\r\n    ell = ceil((len_in_octets + k_in_octets) / b_in_octets) = ceil(144 / 4) = 5\r\n\r\nThe length of `b_0_chopped` is `b_in_octets - k_in_octets` = 16, and the length of b_1 through b_4 are each 32, so in total `pseudo_random_bytes` is 144 bytes in length. We only need to return 128 bytes.",
              "createdAt": "2020-02-24T21:23:30Z",
              "updatedAt": "2020-02-28T18:26:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNzE2MTAx",
          "commit": {
            "abbreviatedOid": "3a69e3b"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-24T21:32:30Z",
          "updatedAt": "2020-02-24T21:32:30Z",
          "comments": [
            {
              "originalPosition": 343,
              "body": "How about `len_in_octets` to match the `expand_message` prototype?",
              "createdAt": "2020-02-24T21:32:30Z",
              "updatedAt": "2020-02-28T18:26:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNzUwNDM4",
          "commit": {
            "abbreviatedOid": "2790581"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-24T22:34:10Z",
          "updatedAt": "2020-02-24T22:34:10Z",
          "comments": [
            {
              "originalPosition": 379,
              "body": "OK, I've added discussion on this in Security Considerations.\r\n\r\n(Does that seem like the right spot for it?)",
              "createdAt": "2020-02-24T22:34:10Z",
              "updatedAt": "2020-02-28T18:26:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNzUxMzg3",
          "commit": {
            "abbreviatedOid": "2790581"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-24T22:36:08Z",
          "updatedAt": "2020-02-24T22:36:09Z",
          "comments": [
            {
              "originalPosition": 379,
              "body": "Yep! I'll take a look. ",
              "createdAt": "2020-02-24T22:36:09Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNzgwMzkx",
          "commit": {
            "abbreviatedOid": "3eca2aa"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-24T23:43:43Z",
          "updatedAt": "2020-02-24T23:43:43Z",
          "comments": [
            {
              "originalPosition": 584,
              "body": "this is now gone because of edits to the Suites section.",
              "createdAt": "2020-02-24T23:43:43Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1Njc1MDAw",
          "commit": {
            "abbreviatedOid": "f19ef32"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The latest changes LGTM!",
          "createdAt": "2020-02-27T13:24:03Z",
          "updatedAt": "2020-02-27T13:24:03Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1ODQyMDQx",
          "commit": {
            "abbreviatedOid": "f19ef32"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "It looks good, I just left few comments.\r\nWhat is the consensus about using octet rather than byte?",
          "createdAt": "2020-02-27T17:11:57Z",
          "updatedAt": "2020-02-27T18:57:42Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "```suggestion\r\nbyte-string and produces as output a point on an elliptic curve.\r\n```",
              "createdAt": "2020-02-27T17:11:58Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 166,
              "body": "idem",
              "createdAt": "2020-02-27T17:12:18Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 340,
              "body": "```suggestion\r\nFor example, for a 255-bit prime p and k = 128-bit security level,\r\n```",
              "createdAt": "2020-02-27T17:43:12Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 336,
              "body": "```suggestion\r\nis appropriate for targeting k-bit security level.\r\n```",
              "createdAt": "2020-02-27T17:44:05Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 428,
              "body": "To match with line 1614, the i-loop must start in 1.",
              "createdAt": "2020-02-27T17:52:55Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 475,
              "body": "```suggestion\r\nAs an example, for 128-bit security level, b >= 256 bits and either SHA-256 or\r\n```",
              "createdAt": "2020-02-27T17:57:49Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 1086,
              "body": "```suggestion\r\n- E' is not required for this suite\r\n- iso\\_map is not required for this suite\r\n```",
              "createdAt": "2020-02-27T18:27:28Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 1146,
              "body": "idem",
              "createdAt": "2020-02-27T18:28:59Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 1216,
              "body": "I think this is not needed, since a hash function cannot be used as an extendable output function and vice versa (unless there is an special case).\r\nSo, specifying the `expand_message` variant must be done inside the suite parameters, but not in the suiteID.",
              "createdAt": "2020-02-27T18:34:15Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 1225,
              "body": "I suggest we can change the main separator character, thus hyphen will be available in names.",
              "createdAt": "2020-02-27T18:35:37Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 1251,
              "body": "I consider we must fix the suiteID name. I am still not convinced on using versions. what is the value added to have  suites XYZv01 and XYZv02?  \r\n\r\nIf some information is really needed to append in the suiteID, then it should be after the last separator. \r\nex: `P256-SHA256-SSWU-RO-<here>` ",
              "createdAt": "2020-02-27T18:41:36Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 416,
              "body": "`str[ a : b ]` means the bytes from str[a] to str[b] both included and `b>=a`? ",
              "createdAt": "2020-02-27T18:52:13Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 513,
              "body": "Q: what is the maximum length of input the messages? ",
              "createdAt": "2020-02-27T18:54:51Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            },
            {
              "originalPosition": 345,
              "body": "somebody ask me whether these methods can be used for small characteristic field. Ex. binary or ternary field extensions.?\r\nObviously we are not covering binary or ternary curves.",
              "createdAt": "2020-02-27T18:56:38Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1OTE4OTU5",
          "commit": {
            "abbreviatedOid": "f19ef32"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-27T19:01:13Z",
          "updatedAt": "2020-02-27T19:01:14Z",
          "comments": [
            {
              "originalPosition": 264,
              "body": "`it first expand the input` \r\nthe first time I read this sentence, it gives me the idea that if I have a large message to be hashed, then the hash_to_base function will expand to a bigger string. \r\nActually, what happens is the opposite, the input message is hashed to produce a pseudo-random string. \r\nMaybe we can rephrase this sentence.",
              "createdAt": "2020-02-27T19:01:14Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTE3NjI5",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T01:51:42Z",
          "updatedAt": "2020-02-28T01:51:42Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "resolved by latest commit",
              "createdAt": "2020-02-28T01:51:42Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTE3Njgy",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T01:51:53Z",
          "updatedAt": "2020-02-28T01:51:54Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "resolved by latest commit",
              "createdAt": "2020-02-28T01:51:54Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTE4MzI2",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T01:54:15Z",
          "updatedAt": "2020-02-28T01:54:16Z",
          "comments": [
            {
              "originalPosition": 336,
              "body": "```suggestion\r\nis appropriate when targeting k-bit security.\r\n```",
              "createdAt": "2020-02-28T01:54:16Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTE4NjQ0",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T01:55:28Z",
          "updatedAt": "2020-02-28T01:55:28Z",
          "comments": [
            {
              "originalPosition": 345,
              "body": "Hmmm, this is a great question. I guess it probably works, but I'd bet there are more efficient ways...",
              "createdAt": "2020-02-28T01:55:28Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTE5MjMy",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T01:57:37Z",
          "updatedAt": "2020-02-28T01:57:38Z",
          "comments": [
            {
              "originalPosition": 340,
              "body": "```suggestion\r\nFor example, for a 255-bit prime p, and k = 128-bit security,\r\n```",
              "createdAt": "2020-02-28T01:57:37Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTE5MzUw",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T01:58:07Z",
          "updatedAt": "2020-02-28T01:58:07Z",
          "comments": [
            {
              "originalPosition": 477,
              "body": "```suggestion\r\n- (u_0, ..., u_(count - 1)), a list of field elements.\r\n```",
              "createdAt": "2020-02-28T01:58:07Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTE5NDY1",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T01:58:35Z",
          "updatedAt": "2020-02-28T01:58:36Z",
          "comments": [
            {
              "originalPosition": 428,
              "body": "Great catch! Since the loop indices are used to compute elm_offset, it works slightly better to start at  0. I've fixed line 1614.",
              "createdAt": "2020-02-28T01:58:35Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTE5Nzc3",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T01:59:43Z",
          "updatedAt": "2020-02-28T01:59:44Z",
          "comments": [
            {
              "originalPosition": 475,
              "body": "```suggestion\r\nAs an example, for the 128-bit security level, b >= 256 bits and either SHA-256 or\r\n```",
              "createdAt": "2020-02-28T01:59:43Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTIyNTQy",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T02:10:00Z",
          "updatedAt": "2020-02-28T02:10:01Z",
          "comments": [
            {
              "originalPosition": 513,
              "body": "ell implies a maximum length of the output, namely, `256 * b_in_bytes - k_in_bytes`. For 256-bit hashes at 128-bit security this is 8176 bytes.\r\n\r\nFor comparison, the pairing-friendly curves draft defines BLS48-581. When hashing to G2, we need an element of F_(p^8) for p a 581-bit integer at the 256-bit security level. So L = 105 bytes, and hashing to two elements of F_(p^8) requires `len_in_bytes = 2 * 8 * 105 = 1680` + `k_in_bytes = 32`, so ell = 54 in this case if we used SHA-256.\r\n\r\n(But note that one would have to use SHA-512, not SHA-256, so ell = 54 is pessimistic.)",
              "createdAt": "2020-02-28T02:10:01Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTI0ODUz",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T02:18:37Z",
          "updatedAt": "2020-02-28T02:18:38Z",
          "comments": [
            {
              "originalPosition": 1216,
              "body": "The reason I was thinking to have EXP_TAG is that if someone introduces a new expand_message variant in the future, this keeps things unambiguous. I suppose it's true that we could just require them to tag their nonstandard variant, though. I'm pretty neutral on this. @chris-wood, thoughts?",
              "createdAt": "2020-02-28T02:18:37Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTI1MTc3",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T02:19:48Z",
          "updatedAt": "2020-02-28T02:19:48Z",
          "comments": [
            {
              "originalPosition": 1225,
              "body": "This is a good point. Can we hash it out in a different issue? It's easy to fix once we've decided.",
              "createdAt": "2020-02-28T02:19:48Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTI2NDQx",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T02:24:34Z",
          "updatedAt": "2020-02-28T02:24:34Z",
          "comments": [
            {
              "originalPosition": 1225,
              "body": "Created a new issue: https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/213",
              "createdAt": "2020-02-28T02:24:34Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTI3OTc0",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T02:30:20Z",
          "updatedAt": "2020-02-28T02:30:21Z",
          "comments": [
            {
              "originalPosition": 1251,
              "body": "The reason that we require the trailing separator is to ensure that suite IDs are prefix-free.\r\n\r\nI wanted to have an \"optional\" field that people could use to put extra stuff when defining a new suite-ID, and I explicitly described it this way because I wanted to make sure that people *did not* add anything after the trailing separator. (I think I should make this more explicit, though.)\r\n\r\nSo I think there are three options:\r\n\r\n1. leave \"optional\" field as described here, or\r\n2. add an extra blank field, or\r\n3. don't describe any optional field at all (in which case I worry that people will get it wrong)",
              "createdAt": "2020-02-28T02:30:21Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTI4MzQ3",
          "commit": {
            "abbreviatedOid": "fe5b23f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T02:31:42Z",
          "updatedAt": "2020-02-28T02:31:43Z",
          "comments": [
            {
              "originalPosition": 1216,
              "body": "Thinking about it a little more, I think I do slightly prefer having an explicit tag. But only slightly...",
              "createdAt": "2020-02-28T02:31:42Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTI4NjY0",
          "commit": {
            "abbreviatedOid": "3c283f1"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T02:33:01Z",
          "updatedAt": "2020-02-28T02:33:01Z",
          "comments": [
            {
              "originalPosition": 416,
              "body": "It's exclusive. from str[a] to str[b] inclusive is (b - a + 1) characters.",
              "createdAt": "2020-02-28T02:33:01Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTI5Mjcx",
          "commit": {
            "abbreviatedOid": "1861c34"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T02:35:12Z",
          "updatedAt": "2020-02-28T02:35:12Z",
          "comments": [
            {
              "originalPosition": 1251,
              "body": "@chris-wood ? ",
              "createdAt": "2020-02-28T02:35:12Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTI5OTEz",
          "commit": {
            "abbreviatedOid": "83532af"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T02:37:42Z",
          "updatedAt": "2020-02-28T02:37:42Z",
          "comments": [
            {
              "originalPosition": 416,
              "body": "To be clearer, it includes str[a] but excludes str[b].",
              "createdAt": "2020-02-28T02:37:42Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTMwOTAw",
          "commit": {
            "abbreviatedOid": "7530181"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T02:41:19Z",
          "updatedAt": "2020-02-28T02:41:19Z",
          "comments": [
            {
              "originalPosition": 416,
              "body": "I clarified slightly.",
              "createdAt": "2020-02-28T02:41:19Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTUwNzIz",
          "commit": {
            "abbreviatedOid": "4021f2f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T04:07:58Z",
          "updatedAt": "2020-02-28T04:07:58Z",
          "comments": [
            {
              "originalPosition": 1216,
              "body": "I too think being explicit is better, as it doesn't rely on properties of the expansion function for separation. (@armfazh how would you imagine someone define `HASH_ID` if, say, they introduced an expansion variant such as `expand_message_md_like`?)",
              "createdAt": "2020-02-28T04:07:58Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTUxNTc3",
          "commit": {
            "abbreviatedOid": "4021f2f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T04:12:02Z",
          "updatedAt": "2020-02-28T04:12:02Z",
          "comments": [
            {
              "originalPosition": 1251,
              "body": "Interesting! I was fine with this text, but on reflection, I'm now leaning towards (a) fixing RO/NU and then (b) adding an extra blank field (with text clarifying its role). \r\n",
              "createdAt": "2020-02-28T04:12:02Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTcxMTUz",
          "commit": {
            "abbreviatedOid": "4021f2f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T05:43:49Z",
          "updatedAt": "2020-02-28T05:43:49Z",
          "comments": [
            {
              "originalPosition": 1251,
              "body": "I agree with you that the cleanest approach seems to be adding an extra field for user-defined info, like\r\n\r\n    CURVE_ID || \"-\" || HASH_ID || \"-\" || MAP_ID || \"-\" || ENC_VAR || \"-\" || USER_INFO || \"-\"\r\n\r\nThe only thing that's slightly unfortunate about this is that it means *all* suite names get longer (well, by one character) in order to make sure that user-defined fields don't break prefix-freeness. So, e.g., we will have to change the suite name to\r\n\r\n    P256-XMD:SHA.256-SSWU-RO--\r\n\r\n(note: *two* trailing hyphens)\r\n\r\nThe current version, where we let the user-defined fields live in ENC_VAR, is slightly uglier in principle, but in practice it makes the expected case (no user-defined fields) prettier.\r\n\r\nI think I favor optimizing for the expected case and letting the user-defined fields be slightly uglier. For all we no, no one will ever use them... and at least they pay their own cost rather than imposing it on everyone else.\r\n\r\n(But again, not to be dramatic... that \"cost\" is just one extra hyphen, after all...)",
              "createdAt": "2020-02-28T05:43:49Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NTE5Mzgw",
          "commit": {
            "abbreviatedOid": "4021f2f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T16:20:59Z",
          "updatedAt": "2020-02-28T16:21:00Z",
          "comments": [
            {
              "originalPosition": 1251,
              "body": "I think we need a tie breaker! @armfazh? ",
              "createdAt": "2020-02-28T16:20:59Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NTU2Mjc2",
          "commit": {
            "abbreviatedOid": "4021f2f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T17:15:42Z",
          "updatedAt": "2020-02-28T17:15:42Z",
          "comments": [
            {
              "originalPosition": 1251,
              "body": ":)\r\n\r\nIt occurs to me: since this is orthogonal to this PR (this text has been in the document for a while), maybe we can discuss in #213 along with the other Suite-ID--related change?",
              "createdAt": "2020-02-28T17:15:42Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NTYwMzg2",
          "commit": {
            "abbreviatedOid": "4021f2f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T17:22:45Z",
          "updatedAt": "2020-02-28T17:22:46Z",
          "comments": [
            {
              "originalPosition": 1251,
              "body": "I've added a comment on that issue. Can we move the discussion there so we can discuss in parallel with getting the code updated, etc?",
              "createdAt": "2020-02-28T17:22:46Z",
              "updatedAt": "2020-02-28T18:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NjIyMDE1",
          "commit": {
            "abbreviatedOid": "821b907"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-28T19:09:21Z",
          "updatedAt": "2020-02-28T19:09:21Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NjY0ODg1",
          "commit": {
            "abbreviatedOid": "821b907"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T20:26:24Z",
          "updatedAt": "2020-02-28T20:26:24Z",
          "comments": [
            {
              "originalPosition": 1251,
              "body": "\r\nI am ok on having two separators at the end, if no user info is added \r\nP256-XMD:SHA.256-SSWU-RO--\r\n\r\nhowever, one suggestion is to put algorithm variants between parenthesis, so, we ensure the last character is always ')' even if user input is omitted.\r\n\r\n(Let's move this thread to 213)",
              "createdAt": "2020-02-28T20:26:24Z",
              "updatedAt": "2020-02-28T20:26:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2Njk2MzI0",
          "commit": {
            "abbreviatedOid": "821b907"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T21:28:40Z",
          "updatedAt": "2020-02-28T21:28:41Z",
          "comments": [
            {
              "originalPosition": 1216,
              "body": "OK, since we now have a suite-ID issue, I'm going to assume that if we end up making a change to this we can do it there, too. I've added a link.",
              "createdAt": "2020-02-28T21:28:40Z",
              "updatedAt": "2020-02-28T21:28:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 214,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgxNjM2MzIw",
      "title": "new hash_to_field code / expand_message_md revisited",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/214",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR updates the code in `poc/` to use the new hash_to_field function from #212.\r\n\r\nI have not yet regenerated the test vectors. Shall I do that?",
      "createdAt": "2020-02-28T23:00:56Z",
      "updatedAt": "2020-03-06T17:19:53Z",
      "closedAt": "2020-03-05T18:46:05Z",
      "mergedAt": "2020-03-05T18:46:05Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "Is pairing-plus or whatever up to date?",
          "createdAt": "2020-02-29T07:47:48Z",
          "updatedAt": "2020-02-29T07:47:48Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is pairing-plus or whatever up to date?\r\n\r\nNot yet, that's next on my list.",
          "createdAt": "2020-02-29T08:41:45Z",
          "updatedAt": "2020-02-29T08:41:45Z"
        },
        {
          "author": "mratsim",
          "authorAssociation": "NONE",
          "body": "New test vectors would be very helpful",
          "createdAt": "2020-03-01T10:49:51Z",
          "updatedAt": "2020-03-01T10:49:51Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Using this new method for obtaining field elements, does it still preserves the guarantees required by the random oracle construction?\r\nPreviously, `u0` and `u1` were obtained from different RO instantiations, by means of appending an extra bit.\r\n`u0 = H (M || 0) and u1 = H (M || 1)`\r\nNow, it seems to me that we are querying the same RO for obtaining `u0` and `u1`.\r\n\r\n",
          "createdAt": "2020-03-02T19:40:19Z",
          "updatedAt": "2020-03-02T19:40:45Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> Using this new method for obtaining field elements, does it still preserves the guarantees required by the random oracle construction?\r\n\r\nYes.\r\n\r\nThere are two ways to argue this. One is to recall that the underlying RO-to-curve construction is really defined in terms of independent elements of F. Using two hash functions H0 and H1 that are modeled as independent random oracles satisfies this requirement, but it's not the only way to satisfy it---hash_to_field (with `count=2`) also gives two independent elements of F.\r\n\r\nThe other slightly less direct way is to observe that the output of expand_message inside of hash-to-field gives `2 * m * L` bytes that are uniformly distributed, and therefore we can define two independent random oracles in terms expand_message, just by splitting its output into two non-overlapping chunks of `m * L` bytes. This is precisely what happens inside of hash-to-field, so we can understand that function as essentially returning the evaluations of H0 and H1.\r\n\r\n(These are equivalent views of the world.)",
          "createdAt": "2020-03-02T21:06:11Z",
          "updatedAt": "2020-03-02T21:07:27Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's assume `H(m,2)` and that exactly `b0` and `b1` match the sizes of certain prime field. Then, `u0 = b0 mod p`, and `u1 = b1 mod p`.\r\nMy concern is that `b1` depends only on `b0`, since `b1` was calculated as the hash of `b0` (plus some prefix).\r\nSo, take a message `m` and calculate `b0`. At this point, `b1` is completely determined by `b0`, but not by other call to a RO using the original message. (in some sense `b0` fixes the output of `b1`).\r\nI am probably missing something. thoughts?\r\n",
          "createdAt": "2020-03-02T22:34:25Z",
          "updatedAt": "2020-03-02T22:34:25Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I see what you're saying.\r\n\r\nThe scenario you describe doesn't quite work because `b0` isn't output, only `b0_chopped`. But I think the idea is correct: consder the case where `b0_chopped || b1` is the 1st element and a substring of `b2 || b3` is the second element. Then b2 and b3 are fully determined by b1, and the adversary sees all of b1, so we still have the issue.\r\n\r\nI went back and looked at CDMP08, and now I see where the issue is coming from. Section 5 talks about building longer outputs by computing H(X || 1), H(X || 2), etc. The important thing here is that there's *no chaining* of output blocks in that construction. And as you say, using chaining on values that the attacker knows makes it possible to distinguish.\r\n\r\n(In contrast, HKDF *does* use chaining, but always combines the chained value with a secret value that the attacker never learns, namely, PRK.)\r\n\r\nI think the fix is straightforward (don't chain, just hash b0 over and over), but I'm going to think carefully about it and push some new text / code.\r\n\r\nThank you!!!",
          "createdAt": "2020-03-02T23:13:53Z",
          "updatedAt": "2020-03-02T23:14:37Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "> The scenario you describe doesn't quite work because `b0` isn't output, only `b0_chopped`. But I think the idea is correct: consder the case where `b0_chopped || b1` is the 1st element and a substring of `b2 || b3` is the second element. Then b2 and b3 are fully determined by b1, and the adversary sees all of b1, so we still have the issue.\r\n\r\nThis is exactly the scenario I had in mind, but I simplified to b0 and b1.\r\n\r\n \r\n> I went back and looked at CDMP08, and now I see where the issue is coming from. Section 5 talks about building longer outputs by computing H(X || 1), H(X || 2), etc. The important thing here is that there's _no chaining_ of output blocks in that construction. And as you say, using chaining on values that the attacker knows makes it possible to distinguish.\r\n\r\n \r\n> (In contrast, HKDF _does_ use chaining, but always combines the chained value with a secret value that the attacker never learns, namely, PRK.)\r\n\r\nExactly, another approach is to generate `n` values of `msg_prime`, one per field element requested.\r\n",
          "createdAt": "2020-03-02T23:21:07Z",
          "updatedAt": "2020-03-02T23:21:07Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, consider the following:\r\n\r\n~~~\r\nSteps:\r\n1. ell = ceil((len_in_bytes + k_in_bytes) / b_in_bytes)\r\n2. ABORT if ell > 256\r\n3. DST_prime = I2OSP(len(DST), 1) || DST\r\n4. b_0 = H(DST_prime || I2OSP(0, 1) || I2OSP(len_in_bytes, 2) || msg)\r\n5. for i in (1, ..., ell - 1):\r\n6.   b_i = H(DST_prime || I2OSP(i, 1) || b_0)                   #### change is here\r\n7. b_0_chopped = b_0[0 : (b_in_bytes - k_in_bytes)]\r\n8. pseudo_random_bytes = b_0_chopped || b_1 || ... || b_(ell - 1)\r\n9. return pseudo_random_bytes[0 : len_in_bytes]\r\n~~~\r\n\r\nThis avoids the chaining issue, because the attacker never sees `b_0`.\r\n\r\nIf we were extremely paranoid, we might not even output `b_0_chopped`. This would mean that the minimum number of hash invocations is 2 instead of 1, which will likely make some people unhappy. But that seems unnecessary, by the security argument for chopMD. Informally, an attacker who doesn't know b_0 cannot compute any more blocks, and here the attacker would have to guess k bits of b_0 in order to reconstruct.\r\n\r\nSo I guess I'm slightly in favor of outputting b_0_chopped, but I can be convinced otherwise. Thoughts @armfazh?\r\n\r\n---\r\n\r\nOne issue with the above that makes me quite nervous is that now only 1 byte (really, in the worst case, only 1 bit!!!) of the input of H is changing for each b_i. This is quite aggressive.\r\n\r\nA slightly better solution would be to do something like\r\n\r\n    b_i = H(DST_prime || I2OSP(i, 1) || b_0 || b_(i-1))\r\n\r\nThe big downside of this is that it significantly increases the number of hash invocations. We could get around that with something like:\r\n\r\n    b_i = H(DST_prime || I2OSP(i, 1) || b_0 ^ b_(i - 1))\r\n\r\nwhere `^` is bitwise XOR. This would require a special case for b_1, obviously!",
          "createdAt": "2020-03-02T23:36:12Z",
          "updatedAt": "2020-03-02T23:43:44Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "A third approach is to chain, but chop the output of every hash function, not just the first one. (The last block does not need to be chopped in this case.)\r\n\r\nLet's think about the cost of all three approaches. For all three approaches, we have\r\n\r\n    b_0 = H(DST || I2OSP(i, 0) || I2OSP(len_in_bytes, 2) || msg)\r\n\r\nFor subsequent blocks,\r\n\r\n- type1 is `b_i = H(DST || I2OSP(i, 1) || b_0 || b_(i-1))`\r\n- type 2 is `b_i = H(DST || I2OSP(i, 1) || b_0 ^ b_(i-1))`\r\n- type 3 is `b_i = H(DST || I2OSP(i, 1) || b_(i-1))` where all b_i are chopped by k bits before being output, except `b_(ell - 1)`.\r\n- type 4 is type 1, but `b_0` is not output\r\n- type 5 is type 2, but `b_0` is not output\r\n- type 6 is type 3, but `b_0` is not output\r\n\r\nType 6 doesn't really make any sense, but I've included it for completeness.\r\n\r\nLet's look first at output rates for different cases:\r\n\r\n| case | first block | middle blocks | last block |\r\n|---|---|---|---|\r\n| SHA-256, k = 128, type 1 or 2 | 16 bytes | 32 bytes | 32 bytes |\r\n| SHA-256, k = 128, type 3 | 16 bytes | 16 bytes | 32 bytes |\r\n| SHA-512, k = 128, type 1 or 2 | 48 bytes | 64 bytes | 64 bytes |\r\n| SHA-512, k = 128, type 3 | 48 bytes | 48 bytes | 64 bytes |\r\n| SHA-512, k = 256, type 1 or 2 | 32 bytes | 64 bytes | 64 bytes |\r\n| SHA-512, k = 256, type 3 | 32 bytes | 32 bytes | 64 bytes |\r\n\r\nTypes 4, 5, and 6 correspond to types 1, 2, and 3 (respectively), except that the \"first block\" column is always 0 (because `b_0` is never output).\r\n\r\nNow, let's look at number of compression function invocations. Assume that the input message is 32 bytes and DST is 16 bytes; this is roughly worst case (because long messages will dominate hashing cost).\r\n\r\n| case | first block | subsequent blocks |\r\n|---|---|---|\r\n| type 1 | 1 | 2 |\r\n| type 2 | 1 | 1 |\r\n| type 3 | 1 | 1 |\r\n\r\nClosed-form expressions for ell and number of invocations. Below, `ell` is the number of blocks that contribute to the output. For types 4, 5, and 6, one must first compute `b_0` and then hash `ell` blocks.\r\n\r\n- type 1:\r\n    - ell = `ceil((len_in_bytes + k_in_bytes) / b_in_bytes)`\r\n    - invocations: `1 + 2 * (ell - 1)`\r\n- type 2:\r\n    - ell = `ceil((len_in_bytes + k_in_bytes) / b_in_bytes)`\r\n    - invocations: `ell`\r\n- type 3:\r\n    - ell = `1 + ceil((len_in_bytes - b_in_bytes) / (b_in_bytes - k_in_bytes))`\r\n    - invocations: `ell`\r\n- type 4:\r\n    - ell = `ceil(len_in_bytes / b_in_bytes)`\r\n    - invocations: `1 + 2 * ell`\r\n- type 5:\r\n    - ell = `ceil(len_in_bytes / b_in_bytes)`\r\n    - invocations: `1 + ell`\r\n- type 6:\r\n    - ell = `1 + ceil((len_in_bytes - b_in_bytes) / (b_in_bytes - k_in_bytes))`\r\n    - invocations: `1 + ell`\r\n\r\nUsing the above, let's consider the cost of different scenarios:\r\n\r\n1. k = 128, p = 256 bits, m = 1 (like Curve25519)\r\n    a. count = 1 (len_in_bytes = 48), SHA-256\r\n    b. as above, SHA-512\r\n    c. count = 2 (len_in_bytes = 96), SHA-256\r\n    d. as above, SHA-512\r\n\r\n2. k = 128, p = 381 bits, m = 2 (like BLS12-381 G2)\r\n    a. count = 1 (len_in_bytes = 128), SHA-256\r\n    b. as above, SHA-512\r\n    c. count = 2 (len_in_bytes = 256), SHA-256\r\n    d. as above, SHA-512\r\n\r\n3. k = 256, p = 521 bits, m = 1 (like P521)\r\n    a. count = 1 (len_in_bytes = 98), SHA-512\r\n    b. count = 2 (len_in_bytes = 196), SHA-512\r\n\r\n4. k = 256, p = 581 bits, m = 8 (like BLS48-581 G2)\r\n    a. count = 1 (len_in_bytes = 840), SHA-512\r\n    b. count = 2 (len_in_bytes = 1680), SHA-512\r\n\r\n| Case | type 1 | 4 | type 2 | 5 | type 3 | 6 |\r\n|------|-------:|:--|-------:|:--|-------:|:--|\r\n| 1a | 3 | 5 | 2 | 3 | 2 | 3 |\r\n| 1b | 1 | 3 | 1 | 2 | 1 | 2 |\r\n| 1c | 7 | 7 | 4 | 4 | 5 | 6 |\r\n| 1d | 3 | 5 | 2 | 3 | 2 | 3 |\r\n| 2a | 9 | 9 | 5 | 5 | 7 | 8 |\r\n| 2b | 5 | 5 | 3 | 3 | 3 | 4 |\r\n| 2c | 17 | 17 | 9 | 9 | 15 | 16 |\r\n| 2d | 9 | 9 | 5 | 5 | 5 | 6 |\r\n| 3a | 5 | 5 | 3 | 3 | 3 | 4 |\r\n| 3b | 7 | 9 | 4 | 5 | 6 | 7 |\r\n| 4a | 27 | 29 | 14 | 15 | 26 | 27 |\r\n| 4b | 53 | 55 | 27 | 28 | 52 | 53 |\r\n\r\nNot surprisingly, type 2 is the cheapest across the board.\r\n\r\nMaybe slightly more surprisingly, types 1 and 3 have close to the same cost, but type 3 is basically always better.\r\n\r\n---\r\n\r\n~So my take is that type 2 is the winner, assuming that folks are OK requiring bitwise XOR. Otherwise, we should go with Type 3.~\r\n\r\n**EDIT** I think the \"right\" choice is really type 5, even though it costs one extra hash invocation for very short messages and very short outputs. So that's my vote.\r\n\r\nType 2 costs fewer hashes, but I'm less certain about its security. I'm roughly as confident in type 4 as type 5, but it's much more expensive. I'm least confident about type 3. And as I said above, type 6 really doesn't make any sense...",
          "createdAt": "2020-03-03T00:44:35Z",
          "updatedAt": "2020-03-03T04:35:34Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Just to be clear, I'll write down the pseudocode for each one:\r\n\r\nAll of them start in roughly the same way:\r\n\r\n~~~\r\n1. ell = ((compute using closed form given above))\r\n2. ABORT if ell > 256\r\n3. DST_prime = I2OSP(len(DST), 1) || DST\r\n4. chopped_length = b_in_bytes - k_in_bytes\r\n5. b_0 = H(DST_prime || I2OSP(0, 1) || I2OSP(len_in_bytes, 2) || msg)\r\n~~~\r\n\r\n# Type 1\r\n\r\n~~~\r\n6.  for i in (1, ..., ell - 1):\r\n7.    b_i = H(DST_prime || I2OSP(i, 1) || b_0 || b_(i - 1))\r\n8.  b_0_chopped = b_0[0 : chopped_length]\r\n9.  pseudo_random_bytes = b_0_chopped || b_1 || ... || b_(ell - 1)\r\n10. return pseudo_random_bytes[0 : len_in_bytes]\r\n~~~\r\n\r\n# Type 2\r\n\r\n~~~\r\n5.  b_1 = H(DST_prime || I2OSP(1, 1) || b_0)\r\n6.  for i in (2, ..., ell - 1):\r\n7.    b_i = H(DST_prime || I2OSP(i, 1) || b_0 ^ b_(i - 1))\r\n8.  b_0_chopped = b_0[0 : chopped_length]\r\n9.  pseudo_random_bytes = b_0_chopped || b_1 || ... || b_(ell - 1)\r\n10. return pseudo_random_bytes[0 : len_in_bytes]\r\n~~~\r\n\r\nHere, `^` is bitwise xor (always applied to equal-length bytestrings in the above).\r\n\r\n# Type 3\r\n\r\n~~~\r\n6.  for i in (1, ..., ell - 1):\r\n7.    b_i = H(DST_prime || I2OSP(i, 1) || b_(i - 1))\r\n8.    b_(i-1)_chopped = b_(i-1)[0 : chop_length]\r\n9.  pseudo_random_bytes = b_0_chopped || b_1_chopped || ... || b_(ell - 1)\r\n10. return pseudo_random_bytes[0 : len_in_bytes]\r\n~~~",
          "createdAt": "2020-03-03T00:52:01Z",
          "updatedAt": "2020-03-03T01:31:24Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually, it occurs to me that the construction as currently written (i.e., where `b_1` chains into `b_2`) probably *is* OK (though it probably still makes sense to try and improve it, as long as it's not too costly).\r\n\r\nThe reason is, the field elements at the output of hash-to-field do not uniquely determine the bytes at the output of expand-message. In all cases, we take (log(q) + k) bits and reduce them to log(q) bits. Hand-wavily, this means that the indifferentiability simulator has about 2^k choices it can make when mapping field elements to byte strings.\r\n\r\nThe proof is much cleaner if we can just make expand-message a random string, so probably it's best to do that. For this purpose I favor approach 2, since it adds the least overhead...",
          "createdAt": "2020-03-03T02:11:11Z",
          "updatedAt": "2020-03-03T02:11:32Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I revamped my [comment above](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/214#issuecomment-593707376) to include options that don't output any part of `b_0`.\r\n\r\nMy vote is to go with \"type 5.\" This is maybe slightly conservative and will make embedded folks slightly sadder. I'll update the document and code with proposed changes (we can always back them out).",
          "createdAt": "2020-03-03T04:43:14Z",
          "updatedAt": "2020-03-03T04:43:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Type 5 seems like the right compromise on balance. We maintain chaining while also mixing in `b_0` and keeping it hidden from the distinguisher, and the concatenated output is indistinguishable from a random string. And the additional XOR cost is negligible.\r\n\r\nThanks @armfazh for pointing out the issue! ",
          "createdAt": "2020-03-03T18:48:00Z",
          "updatedAt": "2020-03-03T18:49:16Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "I talked with Dan (Boneh) about \"type 5\" today, and he had two suggestions:\r\n\r\n1. When computing `b_0 = H(DST_prime || I2OSP(0, 1) || I2OSP(ell, 2) || msg)`, there's a danger that a badly-chosen DST will cause a short `msg` to be split across the first block boundary. The reason this is bad is that the entropy of `msg` ends up broken up across two invocations of the compression function, which could end up making some attacks (think: meet-in-the-middle) easier. He suggested that we fix this is by adding extra padding before `msg` to ensure that it starts right at the first block boundary.\r\n\r\n    This is slightly unfortunate because it guarantees one extra invocation of the compression function even for short inputs. In principle we could avoid the extra compression by adding a special case for very short `DST`/`msg` combinations. But that's pretty ugly, because it requires knowing a lot about the hash function's construction (e.g., SHA-256 has a minimum of 65 bits of padding after the message, so `msg` only fits completely in the first block when len(`DST`) + len(`msg`) <= 51 bytes.\r\n\r\n2. Similarly, if `DST` is too long, then `b_0` or `b_0 XOR b_(i - 1)` might end up broken across a block boundary in the `b_i` calculations. For SHA-256, limiting `DST_prime` to 22 bytes fixes this; for SHA-512, the magic number is 46 bytes.\r\n\r\nIt occurs to me that an alternative solution to both of the above issues is to switch the order of the inputs to the hash function; this guarantees that the critical inputs are always right at the beginning. In particular,\r\n\r\n    b_0 = H(msg || I2OSP(len_in_bytes, 2) || I2OSP(0, 1) || DST_prime)\r\n    b_1 = H(b_0 || I2OSP(1, 1) || DST_prime)\r\n    b_i = H(strxor(b_0, b_(i - 1)) || I2OSP(i, 1) || DST_prime)\r\n\r\nThis means we're doing domain separation as a suffix rather than as a prefix of the message. Does this make life more difficult when interacting with other protocols? I'm not exactly sure, but I can't see why it should.\r\n\r\nIn fact, it arguably makes life better, because any protocol that needs to compute another value of `H(msg || ...)` can reuse an intermediate state of that computation to save time when computing prk!\r\n\r\nNote that both of the worries above apply to SHA-2; for SHA-3, we don't really need to worry about any of this.",
          "createdAt": "2020-03-04T06:47:46Z",
          "updatedAt": "2020-03-04T08:18:12Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Quick note: I pinged Dan about swapping the input order and he said it looked fine.",
          "createdAt": "2020-03-04T18:58:21Z",
          "updatedAt": "2020-03-04T18:58:21Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Arrgh. As I was writing down a proof sketch I found an issue with swapping the argument order. Fortunately, it's not hard to fix, and there's a reasonably easy way of avoiding any performance ramifications.\r\n\r\nNext, I'm going to push a commit that implements this. As always, we can revert...\r\n\r\n## Executive summary\r\n\r\nAbove I proposed computing\r\n\r\n    b_0 = H( msg || I2OSP(len_in_bytes, 2) || I2OSP(0, 1) || DST_prime )\r\n\r\nTo make the proof go through, we should change this to\r\n\r\n    b_0 = H(I2OSP(0, input_block_size) || msg || I2OSP(len_in_bytes, 2) || I2OSP(0, 0) || DST_prime)\r\n\r\nIn other words, we should prepend 1 (input) block of 0s to msg before hashing.  For SHA-256 this is 64 bytes, for SHA-512 it's 128 bytes. This lets us rely directly on the security proofs for NMAC given in [CDMP05](https://cs.nyu.edu/~dodis/ps/merkle.pdf), as well as other analysis like [Bel06](https://eprint.iacr.org/2006/043).\r\n\r\nIn the rest of this post I'll first discuss why we ought to do this, and then describe how implementors can avoid actually computing another hash function invocation.\r\n\r\n## Why do we need this change?\r\n\r\nPreviously we were arguing that our construction was an implementation of the NMAC construction (really, the confusingly-named HMAC^f construction; for clarity I'll just call it NMAC) in Section 3.5 of CDMP05. The basis for this claim was that the first block of each invocation of H was unique, since we had the DST and the counter in there. (We can understand Dan's suggestion (1) above, padding the first block of the b_0 computation, as strengthening this argument.)\r\n\r\nUnfortunately, if we're putting the message first, we can't directly rely on the NMAC proof: since the adversary controls the first input block to the hash function, we have no guarantee that it's unique.\r\n\r\nCDMP05 fix this problem by prepending a block of 0s to the message. This works because it prevents the adversary from controlling the contents of the first block. Using our notation, this is secure essentially because the probability is negligible that b_0 == 0 or strxor(b_0, b_(i-1)) == 0.\r\n\r\n## What is the cost?\r\n\r\nDirectly implementing this change costs an extra compression function invocation.  But in practice it's possible to avoid this, just by saving the state of the hash function after it ingests 1 block of 0s, and hashing msg starting from that state.\r\n\r\nThe storage cost to implement this optimization is minimal (less than 100 bytes for the SHA-2 family), and in practice lots of SHA-2 implementations already let you do this. (This is true, for example, of the OpenSSL implementation.)\r\n\r\nThe other cost here is that it puts us back in a universe where we can't share a hash prefix with other computations of `H(msg || ...)`. But that seems like it's OK---upper-layer protocols are welcome to define a \"prehash mode\" if they're really worried about the cost of hashing messages.",
          "createdAt": "2020-03-04T19:47:55Z",
          "updatedAt": "2020-03-04T19:49:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Referencing the proof wholesale is great! Most hash function implementations allow the internal state to be set, so I don't foresee this to be a problem in practice (as you mention).",
          "createdAt": "2020-03-04T22:08:08Z",
          "updatedAt": "2020-03-04T22:08:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh are you OK with this change? If so, I\u2019ll merge it.",
          "createdAt": "2020-03-05T16:37:31Z",
          "updatedAt": "2020-03-05T16:37:31Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I am not sure whether the XOR maintains the security, or gives the attacker a new surface for attacks. I am not able to prove or disprove this claim.\r\nLet's move forward.",
          "createdAt": "2020-03-05T18:40:49Z",
          "updatedAt": "2020-03-05T18:40:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MTU3OTIw",
          "commit": {
            "abbreviatedOid": "3afe1af"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-04T22:04:34Z",
          "updatedAt": "2020-03-04T22:04:34Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": ":)",
              "createdAt": "2020-03-04T22:04:34Z",
              "updatedAt": "2020-03-05T08:20:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 215,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgxNjM3NTAy",
      "title": "remove explicit use of \"Long\" Weierstrass equations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/215",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR addresses the issues discussed in #195 by making the \"long Weierstrass\" transformations part of the Elligator2 map. The hope is that this makes the Elligator2 section clearer.\r\n\r\nIt also updates the code in `poc/` to match the descriptions in the text.\r\n\r\nCloses #195",
      "createdAt": "2020-02-28T23:05:02Z",
      "updatedAt": "2020-03-03T22:21:33Z",
      "closedAt": "2020-03-03T18:57:29Z",
      "mergedAt": "2020-03-03T18:57:29Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @armfazh! I've addressed all the comments.",
          "createdAt": "2020-03-02T21:34:57Z",
          "updatedAt": "2020-03-02T21:34:57Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Nice simplification! ",
          "createdAt": "2020-03-03T18:57:21Z",
          "updatedAt": "2020-03-03T18:57:21Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NDIzNTA0",
          "commit": {
            "abbreviatedOid": "849be2a"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Only few comments on the rational maps",
          "createdAt": "2020-03-02T18:25:26Z",
          "updatedAt": "2020-03-02T19:08:06Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "Here I am not sure whether the sign of `t` should be chosen before doing the transformation from long Weierstrass to Montgomery. \r\nSo line 10 should precede line 9.",
              "createdAt": "2020-03-02T18:25:27Z",
              "updatedAt": "2020-03-02T21:34:34Z"
            },
            {
              "originalPosition": 271,
              "body": "It seems that these references are not being used  [SP.800-185]  [DRST12]",
              "createdAt": "2020-03-02T18:35:26Z",
              "updatedAt": "2020-03-02T21:34:34Z"
            },
            {
              "originalPosition": 274,
              "body": "```suggestion\r\n## Twisted Edwards to Montgomery curves {#appx-rational-map-edw}\r\n```",
              "createdAt": "2020-03-02T18:36:07Z",
              "updatedAt": "2020-03-02T21:34:34Z"
            },
            {
              "originalPosition": 327,
              "body": "This condition is guaranteed by twisted Edwards curves definition.",
              "createdAt": "2020-03-02T18:38:11Z",
              "updatedAt": "2020-03-02T21:34:34Z"
            },
            {
              "originalPosition": 339,
              "body": "idem",
              "createdAt": "2020-03-02T18:42:15Z",
              "updatedAt": "2020-03-02T21:34:34Z"
            },
            {
              "originalPosition": 340,
              "body": "When `t=0` (a point of order two) must be mapped to `(0,-1) \\in E` (the point of order two).\r\nWhen `s=-1` it goes to `(0,1)\\in E`.",
              "createdAt": "2020-03-02T18:50:30Z",
              "updatedAt": "2020-03-02T21:34:34Z"
            },
            {
              "originalPosition": 328,
              "body": "Here are two cases, \r\n\r\n(0,-1) \\in E |--> (0,0) \\in M\r\n(0, 1) \\in E |--> (inf) \\in M\r\n",
              "createdAt": "2020-03-02T18:53:02Z",
              "updatedAt": "2020-03-02T21:34:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NTI4NzQ2",
          "commit": {
            "abbreviatedOid": "849be2a"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-02T21:09:30Z",
          "updatedAt": "2020-03-02T21:09:30Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "The way we define sign in the text, sign of t is equal to sign of u. Changing the sign of y and then computing t doesn't necessarily give the same result (depending on the value of K).\r\n\r\nFrom the point of view of the document, it's much simpler to define in terms of t than in terms of y, because y is a purely internal variable to the function.\r\n\r\nNote that this change to the document doesn't change signs for any existing suites, because all of those suites are for curves where K = 1.",
              "createdAt": "2020-03-02T21:09:30Z",
              "updatedAt": "2020-03-02T21:34:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NTUyMTA1",
          "commit": {
            "abbreviatedOid": "5379462"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-02T21:46:43Z",
          "updatedAt": "2020-03-02T21:46:44Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "> From the point of view of the document, it's much simpler to define in terms of t than in terms of y, because y is a purely internal variable to the function.\r\n\r\nYes, of course.\r\n\r\n> Changing the sign of y and then computing t doesn't necessarily give the same result (depending on the value of K).\r\n\r\nWell, this is exactly my point. But anyway, there are no breaking changes since K=1 as you said. So we can proceed as is.\r\n",
              "createdAt": "2020-03-02T21:46:44Z",
              "updatedAt": "2020-03-02T21:46:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NTUyNDY0",
          "commit": {
            "abbreviatedOid": "5379462"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-02T21:47:20Z",
          "updatedAt": "2020-03-02T21:47:20Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4MjM5NDIw",
          "commit": {
            "abbreviatedOid": "5379462"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-03T18:57:01Z",
          "updatedAt": "2020-03-03T18:57:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 217,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0MjY0MDM1",
      "title": "test vectors: add intermediate values, update DSTs, add vectors to document",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/217",
      "state": "MERGED",
      "author": "dot-asm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Intention is to facilitate intermediate data collection, which is\r\nthen can be emitted as part of test vectors.\r\n\r\nThis is rather a request for feedback, just to see if it would be considered as a viable approach for collecting intermediate data required for #216. Idea is not only record results like inputs to map_to_curve or clear_cofactor, but even arguments to CMOVs, so that one [can] pick specific vectors out of random set.\r\n",
      "createdAt": "2020-03-05T13:04:21Z",
      "updatedAt": "2020-03-09T17:21:08Z",
      "closedAt": "2020-03-09T17:21:08Z",
      "mergedAt": "2020-03-09T17:21:08Z",
      "mergedBy": "kwantam",
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Cool! This looks like a good idea. Not sure whether this will happen before the March 9th deadline for the next IETF meeting, but I'll try!",
          "createdAt": "2020-03-06T17:12:50Z",
          "updatedAt": "2020-03-06T17:12:50Z"
        },
        {
          "author": "dot-asm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In such case, I've re-based and fixed 'make test'.\r\n",
          "createdAt": "2020-03-06T22:31:35Z",
          "updatedAt": "2020-03-06T22:31:35Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "added intermediate values to suite printing and rebased to master",
          "createdAt": "2020-03-09T01:03:37Z",
          "updatedAt": "2020-03-09T01:03:37Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I've updated vectors, added a test vector appendix, and checked compatibility with Sage 8.1. This PR should be good to go.\r\n",
          "createdAt": "2020-03-09T06:11:14Z",
          "updatedAt": "2020-03-09T06:11:14Z"
        },
        {
          "author": "dot-asm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's not exactly my business, but I [for one] would appreciate if changes to `vector[\"P\"]` were a separate commit and bundled together with modification that triggers the change. I mean I'd appreciate if there was commit that added additional data to `vectors/\\*json`, but didn't change \"P\", and another commit that changes everything along with DST change (right?) that triggers it. So that one has distinct reference points to track. Again, not really my business, so feel free to ignore, but it would make it easier to follow the progression for bystanders such as myself :-)\r\n",
          "createdAt": "2020-03-09T11:33:42Z",
          "updatedAt": "2020-03-09T11:33:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh please review and merge if you're OK with this. ",
          "createdAt": "2020-03-09T14:00:52Z",
          "updatedAt": "2020-03-09T14:00:52Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> It's not exactly my business, but I [for one] would appreciate if changes to `vector[\"P\"]` were a separate commit and bundled together with modification that triggers the change.\r\n\r\nSure thing. I've inserted a commit that updates the vectors after adding extra data, but keeps P the same.",
          "createdAt": "2020-03-09T16:52:51Z",
          "updatedAt": "2020-03-09T16:52:51Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "I consider json vectors should contain the parameter `L` and `Z`.",
          "createdAt": "2020-03-09T16:57:09Z",
          "updatedAt": "2020-03-09T16:57:09Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, pushed one tiny change---there was a ';' where there should have been a ',' in one of the ciphersuite definitions.",
          "createdAt": "2020-03-09T16:57:17Z",
          "updatedAt": "2020-03-09T16:57:17Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "> I consider json vectors should contain the parameter `L` and `Z`.\r\n\r\nSure, I can add that quickly.",
          "createdAt": "2020-03-09T16:57:48Z",
          "updatedAt": "2020-03-09T16:57:48Z"
        },
        {
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh done. Good now?",
          "createdAt": "2020-03-09T17:17:46Z",
          "updatedAt": "2020-03-09T17:17:46Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, go forward.",
          "createdAt": "2020-03-09T17:18:36Z",
          "updatedAt": "2020-03-09T17:18:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMDk4NTU1",
          "commit": {
            "abbreviatedOid": "b895413"
          },
          "author": "dot-asm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-09T11:47:26Z",
          "updatedAt": "2020-03-09T11:47:27Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "There is kind of inconsistency in output. If \"u\" is emitted as an array, then it would be more consistent if \"Q\" was emitted as one as well. As opposite to \"Q0\" and \"Q1\" that is. Or vice versa. If there are \"Q0\" and \"Q1\", then \"u0\" and \"u1\" would be more consistent. [And If you settle for arrays, one can wonder if it would be appropriate to not emit variables as arrays if they have only one element?]\r\n",
              "createdAt": "2020-03-09T11:47:27Z",
              "updatedAt": "2020-03-09T17:19:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMTAwNDc5",
          "commit": {
            "abbreviatedOid": "b895413"
          },
          "author": "dot-asm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-09T11:50:54Z",
          "updatedAt": "2020-03-09T11:50:55Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "So \"may be overridden in descendents\" is no longer an option? It still might be useful...",
              "createdAt": "2020-03-09T11:50:55Z",
              "updatedAt": "2020-03-09T17:19:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMjA2Mzg1",
          "commit": {
            "abbreviatedOid": "b895413"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Approving in the interest of getting in by the deadline. We can fix any bugs that arise later!",
          "createdAt": "2020-03-09T14:00:34Z",
          "updatedAt": "2020-03-09T14:00:34Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMzM1NDMz",
          "commit": {
            "abbreviatedOid": "b895413"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-09T16:27:54Z",
          "updatedAt": "2020-03-09T16:27:54Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "The variable names and types are consistent with the pseudocode in Section 3.\r\n\r\nI don't want to change Q to an array in the pseudocode because we'd have to add another line initializing Q to an empty array (or at least *somehow* indicating that Q is an array).\r\n\r\nWe could instead do something like\r\n\r\n    (u0, u1) = hash_to_field(msg, 2)\r\n\r\nbut in the `encode_to_curve` case the corresponding Python-ish syntax would be\r\n\r\n    (u0,) = hash_to_field(msg, 1)\r\n\r\nwhich may not make sense to some readers. An alternative would be\r\n\r\n    [u0] = hash_to_field(msg, 1)\r\n\r\nbut this isn't consistent with the notation in hash_to_field.\r\n\r\nSo: I'm OK with the small inconsistency here, because it's in service of simplicity in the pseudocode.",
              "createdAt": "2020-03-09T16:27:54Z",
              "updatedAt": "2020-03-09T17:19:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMzM4Mjg4",
          "commit": {
            "abbreviatedOid": "b895413"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-09T16:31:24Z",
          "updatedAt": "2020-03-09T16:31:25Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "It turned out not to be useful: the descendants that we need are implemented directly below and only need to override `to_self`.\r\n\r\nAnyway, it can still be overridden in descendants in the normal way. The reason we had two versions of the function before was so that the `_hash` and `hash` functions could have slightly different behavior. This was complexity for no reason: it amounted to testing that doing math on an elliptic curve written in two ways gave the same result.",
              "createdAt": "2020-03-09T16:31:24Z",
              "updatedAt": "2020-03-09T17:19:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMzU1OTg2",
          "commit": {
            "abbreviatedOid": "97bbd7f"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-09T16:53:36Z",
          "updatedAt": "2020-03-09T16:53:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 219,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1OTMwMTc0",
      "title": "workgroup should be CFRG in frontmatter",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/219",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-10T04:24:13Z",
      "updatedAt": "2020-03-10T17:35:40Z",
      "closedAt": "2020-03-10T15:24:05Z",
      "mergedAt": "2020-03-10T15:24:05Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyMDU4Mjc4",
          "commit": {
            "abbreviatedOid": "0597533"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-10T15:24:00Z",
          "updatedAt": "2020-03-10T15:24:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 221,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg2MjcyMDk5",
      "title": "clarify hashed DST output length for XOF case",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/221",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "closes #220",
      "createdAt": "2020-03-10T17:36:42Z",
      "updatedAt": "2020-03-13T20:00:37Z",
      "closedAt": "2020-03-13T19:59:40Z",
      "mergedAt": "2020-03-13T19:59:40Z",
      "mergedBy": "kwantam",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyOTkyMDMx",
          "commit": {
            "abbreviatedOid": "e2a625f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-11T17:50:57Z",
          "updatedAt": "2020-03-11T17:50:57Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0NTQzOTky",
          "commit": {
            "abbreviatedOid": "e2a625f"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "\r\nSome references are not used [CN08] [DFL12] [MT07]",
          "createdAt": "2020-03-13T19:02:03Z",
          "updatedAt": "2020-03-13T19:02:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 224,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg4NzQ0NDE4",
      "title": "Add note about security level upper bound.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/224",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This closes #222.",
      "createdAt": "2020-03-15T15:39:44Z",
      "updatedAt": "2020-03-18T19:18:09Z",
      "closedAt": "2020-03-18T19:17:53Z",
      "mergedAt": "2020-03-18T19:17:52Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kwantam @armfazh I moved the note to the first occurrence of `k`. Please take a look!",
          "createdAt": "2020-03-18T15:58:37Z",
          "updatedAt": "2020-03-18T15:58:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2NDUxMDY5",
          "commit": {
            "abbreviatedOid": "f1d24e5"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I would like to prevent developers of, for example, using k=128 in a pairing-friendly curve. Then, it is likely that some years later, the actual security could be reduced to, say k=112. Hence, some of them could be tempted to set k=112 (or k=113 depending the paper they read).\r\n\r\nI think the document must stress that `k` must be fixed even in the case of a reduction on security. Since changing this parameter has a waterfall effect in the output of the hash, breaking compatibility.\r\n\r\nAlso open to read your thoughts.\r\n\r\n",
          "createdAt": "2020-03-17T22:33:11Z",
          "updatedAt": "2020-03-17T22:55:39Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I think this paragraph should appear earlier at Section 5.1 where it is introduced `k` by the first time.",
              "createdAt": "2020-03-17T22:33:11Z",
              "updatedAt": "2020-03-18T19:17:40Z"
            },
            {
              "originalPosition": 16,
              "body": "A small clash of notation, that can be easily solved, appears on Section 6.8.1 Rational Maps\r\n```\r\nAnalogous ambiguities in other standardized rational maps MUST be resolved in the same way: for any constant k whose sign is ambiguous, k MUST be chosen such that sgn0(k) == 1.\r\n```",
              "createdAt": "2020-03-17T22:37:18Z",
              "updatedAt": "2020-03-18T19:17:40Z"
            },
            {
              "originalPosition": 16,
              "body": "Also in Section 8.8 Defining a new hash curve. \r\nsays: \r\n`k` is the security level of the elliptic curve.\r\nshould say:\r\n`k` is the targeted security level of the suite.\r\n",
              "createdAt": "2020-03-17T22:42:02Z",
              "updatedAt": "2020-03-18T19:17:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2NTAyMjc5",
          "commit": {
            "abbreviatedOid": "f1d24e5"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I like having this in Security Considerations, but I think a backref in S5 would be good.\r\n\r\nGood catches on notational clashes, @armfazh!",
          "createdAt": "2020-03-18T01:07:42Z",
          "updatedAt": "2020-03-18T01:14:28Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "It's a good idea to make this issue obvious in Section 5, but I think the right way to do it is to have a forward reference from Section 5 (or wherever k is first mentioned) to here. I'd strongly prefer to keep discussion of security issues to the Security Considerations section, because (roughly speaking) Section 5 is normative, whereas this discussion is informative, and keeping them distinct will make things clearer.\r\n\r\n@armfazh do you have an idea of where in Section 5 would be a good place for a forward-reference?",
              "createdAt": "2020-03-18T01:07:42Z",
              "updatedAt": "2020-03-18T19:17:40Z"
            },
            {
              "originalPosition": 16,
              "body": "but I'd suggest \"target\" rather than \"targeted\"\r\n\r\nFor section 6.8.1, maybe use `const`?",
              "createdAt": "2020-03-18T01:10:21Z",
              "updatedAt": "2020-03-18T19:17:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2OTg4OTAx",
          "commit": {
            "abbreviatedOid": "f1d24e5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-18T15:41:11Z",
          "updatedAt": "2020-03-18T15:41:11Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Yeah, I felt a forward reference to the informative bits from Section 5 was best. ",
              "createdAt": "2020-03-18T15:41:11Z",
              "updatedAt": "2020-03-18T19:17:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2OTg5MzM5",
          "commit": {
            "abbreviatedOid": "f1d24e5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-18T15:41:38Z",
          "updatedAt": "2020-03-18T15:41:38Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Great catch!",
              "createdAt": "2020-03-18T15:41:38Z",
              "updatedAt": "2020-03-18T19:17:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2OTk0MjYx",
          "commit": {
            "abbreviatedOid": "f1d24e5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-18T15:46:47Z",
          "updatedAt": "2020-03-18T15:46:48Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "> For section 6.8.1, maybe use const?\r\n\r\nI was just going to use `c`, since that's what we use for constants.",
              "createdAt": "2020-03-18T15:46:47Z",
              "updatedAt": "2020-03-18T19:17:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MTQ3MTI1",
          "commit": {
            "abbreviatedOid": "fc51ec9"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-18T18:52:09Z",
          "updatedAt": "2020-03-18T18:52:10Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "in Section 5.1",
              "createdAt": "2020-03-18T18:52:09Z",
              "updatedAt": "2020-03-18T19:17:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MTYwNjY0",
          "commit": {
            "abbreviatedOid": "fc51ec9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-18T19:11:55Z",
          "updatedAt": "2020-03-18T19:11:55Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "> in Section 5.1\r\n\r\nHmm?",
              "createdAt": "2020-03-18T19:11:55Z",
              "updatedAt": "2020-03-18T19:17:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MTYzNzYw",
          "commit": {
            "abbreviatedOid": "fc51ec9"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "one last nit, it should say `suite` instead of `cryptosystem`.\r\n\r\n```\r\n- L = ceil((ceil(log2(p)) + k) / 8), where k is the security parameter of the cryptosystem (e.g., k = 128).\r\n```",
          "createdAt": "2020-03-18T19:16:38Z",
          "updatedAt": "2020-03-18T19:16:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MTY0Nzk5",
          "commit": {
            "abbreviatedOid": "0616f03"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-18T19:18:09Z",
          "updatedAt": "2020-03-18T19:18:09Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I am ok with the forward reference as is the latest commit.",
              "createdAt": "2020-03-18T19:18:09Z",
              "updatedAt": "2020-03-18T19:18:10Z"
            }
          ]
        }
      ]
    },
    {
      "number": 226,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkwNzE0MDcy",
      "title": "Pointing to named versions.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/226",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Go reference implementation supports v06 using a tagged commit.",
      "createdAt": "2020-03-18T23:22:39Z",
      "updatedAt": "2020-03-19T20:00:43Z",
      "closedAt": "2020-03-19T20:00:42Z",
      "mergedAt": "2020-03-19T20:00:42Z",
      "mergedBy": "kwantam",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MzE2MTcy",
          "commit": {
            "abbreviatedOid": "a13c81f"
          },
          "author": "kwantam",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm!",
          "createdAt": "2020-03-18T23:51:33Z",
          "updatedAt": "2020-03-18T23:51:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 228,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkxNjg1ODA3",
      "title": "give guidance on choosing k in Section 8",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/228",
      "state": "MERGED",
      "author": "kwantam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This implements @chris-wood's suggestion in #227.\r\n\r\ncloses #227",
      "createdAt": "2020-03-20T18:39:30Z",
      "updatedAt": "2020-03-21T00:35:11Z",
      "closedAt": "2020-03-20T23:33:14Z",
      "mergedAt": "2020-03-20T23:33:14Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM \u2014 thanks!",
          "createdAt": "2020-03-20T20:12:08Z",
          "updatedAt": "2020-03-20T20:12:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NzgyOTY2",
          "commit": {
            "abbreviatedOid": "53e5b1d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-20T20:11:52Z",
          "updatedAt": "2020-03-20T20:11:52Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NzkxMDQ1",
          "commit": {
            "abbreviatedOid": "53e5b1d"
          },
          "author": "armfazh",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-20T20:26:45Z",
          "updatedAt": "2020-03-20T20:26:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 229,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkzOTAxMjk5",
      "title": "Pointers to rust reference implementation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/229",
      "state": "OPEN",
      "author": "armfazh",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I've created a rust reference implementation compatible with v05 and v06",
      "createdAt": "2020-03-26T01:04:07Z",
      "updatedAt": "2020-03-26T01:04:07Z",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": []
    }
  ]
}